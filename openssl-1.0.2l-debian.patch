diff -uNr openssl-1.0.2l.orig/config openssl-1.0.2l/config
--- openssl-1.0.2l.orig/config	2017-05-25 20:54:38.000000000 +0800
+++ openssl-1.0.2l/config	2018-07-16 17:01:21.528442205 +0800
@@ -170,8 +170,8 @@
 	echo "${MACHINE}-whatever-linux1"; exit 0
 	;;
 
-    GNU*)
-	echo "hurd-x86"; exit 0;
+    GNU:*|GNU/*:*)
+	echo "${MACHINE}-gnuish"; exit 0;
 	;;
 
     LynxOS:*)
diff -uNr openssl-1.0.2l.orig/Configure openssl-1.0.2l/Configure
--- openssl-1.0.2l.orig/Configure	2017-05-25 20:54:38.000000000 +0800
+++ openssl-1.0.2l/Configure	2018-07-16 17:01:21.668443165 +0800
@@ -133,6 +133,10 @@
 # Warn that "make depend" should be run?
 my $warn_make_depend = 0;
 
+# There are no separate CFLAGS/CPPFLAGS/LDFLAGS, set everything in CFLAGS
+my $debian_cflags = `dpkg-buildflags --get CFLAGS` . `dpkg-buildflags --get CPPFLAGS` . `dpkg-buildflags --get LDFLAGS` . "-Wa,--noexecstack -Wall";
+$debian_cflags =~ s/\n/ /g;
+
 my $strict_warnings = 0;
 
 my $x86_gcc_des="DES_PTR DES_RISC1 DES_UNROLL";
@@ -369,6 +373,56 @@
 "osf1-alpha-cc",  "cc:-std1 -tune host -O4 -readonly_strings::(unknown):::SIXTY_FOUR_BIT_LONG RC4_CHUNK:${alpha_asm}:dlfcn:alpha-osf1-shared:::.so",
 "tru64-alpha-cc", "cc:-std1 -tune host -fast -readonly_strings::-pthread:::SIXTY_FOUR_BIT_LONG RC4_CHUNK:${alpha_asm}:dlfcn:alpha-osf1-shared::-msym:.so",
 
+# Debian GNU/* (various architectures)
+"debian-alpha","gcc:${debian_cflags}::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_RISC1 DES_UNROLL:${alpha_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-alpha-ev4","gcc:${debian_cflags} -mcpu=ev4::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_RISC1 DES_UNROLL:${alpha_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-alpha-ev5","gcc:${debian_cflags} -mcpu=ev5::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_RISC1 DES_UNROLL:${alpha_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-arm64","gcc:-DL_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL BF_PTR:${aarch64_asm}:linux64:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-armel","gcc:-DL_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL BF_PTR:${armv4_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-armhf","gcc:-DL_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL BF_PTR:${armv4_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-amd64", "gcc:-m64 -DL_ENDIAN ${debian_cflags} -DMD32_REG_T=int::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_INT DES_UNROLL:${x86_64_asm}:elf:dlfcn:linux-shared:-fPIC:-m64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::",
+"debian-avr32", "gcc:-DB_ENDIAN ${debian_cflags} -fomit-frame-pointer::-D_REENTRANT::-ldl:BN_LLONG_BF_PTR:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-kfreebsd-amd64","gcc:-m64 -DL_ENDIAN ${debian_cflags} -DMD32_REG_T=int::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_INT DES_UNROLL:${x86_64_asm}:elf:dlfcn:linux-shared:-fPIC:-m64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-kfreebsd-i386","gcc:-DL_ENDIAN ${debian_cflags} -march=i486::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-hppa","gcc:-DB_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG MD2_CHAR RC4_INDEX:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-hurd-i386","gcc:-DL_ENDIAN -O3 -Wa,--noexecstack -g -mtune=i486 -Wall::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-ia64","gcc:${debian_cflags}::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_UNROLL DES_INT:${ia64_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-i386","gcc:-DL_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-i386-i486","gcc:-DL_ENDIAN ${debian_cflags} -march=i486::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-i386-i586","gcc:-DL_ENDIAN ${debian_cflags} -march=i586::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-i386-i686/cmov","gcc:-DL_ENDIAN ${debian_cflags} -march=i686::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-m68k","gcc:-DB_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG MD2_CHAR RC4_INDEX:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-mips",   "gcc:-DB_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG RC2_CHAR RC4_INDEX DES_INT DES_UNROLL DES_RISC2:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-mipsel",   "gcc:-DL_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG RC2_CHAR RC4_INDEX DES_INT DES_UNROLL DES_RISC2:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-mipsn32",   "gcc:-DB_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG RC2_CHAR RC4_INDEX DES_INT DES_UNROLL DES_RISC2:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-mipsn32el",   "gcc:-DL_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG RC2_CHAR RC4_INDEX DES_INT DES_UNROLL DES_RISC2:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-mips64",   "gcc:-DB_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG RC2_CHAR RC4_INDEX DES_INT DES_UNROLL DES_RISC2:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-mips64el",   "gcc:-DL_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG RC2_CHAR RC4_INDEX DES_INT DES_UNROLL DES_RISC2:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-netbsd-i386",	"gcc:-DL_ENDIAN ${debian_cflags} -m486::(unknown):::BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${no_asm}:dlfcn:bsd-gcc-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-netbsd-m68k",	"gcc:-DB_ENDIAN ${debian_cflags}::(unknown):::BN_LLONG MD2_CHAR RC4_INDEX DES_UNROLL:${no_asm}:dlfcn:bsd-gcc-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-netbsd-sparc",	"gcc:-DB_ENDIAN ${debian_cflags} -mv8::(unknown):::BN_LLONG MD2_CHAR RC4_INDEX DES_UNROLL:${no_asm}:dlfcn:bsd-gcc-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-nios2", "gcc:-DB_ENDIAN ${debian_cflags}::(unknown)::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL BF_PTR:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-openbsd-alpha","gcc:${debian_cflags}::(unknown):::SIXTY_FOUR_BIT_LONG DES_INT DES_PTR DES_RISC2:${no_asm}:dlfcn:bsd-gcc-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-openbsd-i386",  "gcc:-DL_ENDIAN ${debian_cflags} -m486::(unknown):::BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_asm}:a.out:dlfcn:bsd-gcc-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-openbsd-mips","gcc:-DL_ENDIAN ${debian_cflags}::(unknown)::BN_LLONG MD2_CHAR RC4_INDEX RC4_CHAR DES_UNROLL DES_RISC2 DES_PTR BF_PTR:${no_asm}:dlfcn:bsd-gcc-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-or1k", "gcc:-DB_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG DES_RISC1:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-powerpc","gcc:-DB_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_RISC1 DES_UNROLL:${ppc32_asm}:linux32:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-powerpcspe","gcc:-DB_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_RISC1 DES_UNROLL:${ppc32_asm}:linux32:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-ppc64","gcc:-m64 -DB_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHAR RC4_CHUNK DES_RISC1 DES_UNROLL:${ppc64_asm}:linux64:dlfcn:linux-shared:-fPIC:-m64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-ppc64el","gcc:-m64 -DL_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHAR RC4_CHUNK DES_RISC1 DES_UNROLL:${ppc64_asm}:linux64le:dlfcn:linux-shared:-fPIC:-m64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-s390","gcc:-DB_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)", 
+"debian-s390x","gcc:-DB_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL:${s390x_asm}:64:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-sh3",   "gcc:-DL_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-sh4",   "gcc:-DL_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-sh3eb",   "gcc:-DB_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-sh4eb",   "gcc:-DB_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-m32r","gcc:-DB_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-sparc","gcc:-DB_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR:${sparcv9_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-sparc-v8","gcc:-DB_ENDIAN ${debian_cflags} -mcpu=v8 -DBN_DIV2W::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR:${sparcv8_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-sparc-v9","gcc:-DB_ENDIAN ${debian_cflags} -mcpu=v9 -Wa,-Av8plus -DULTRASPARC -DBN_DIV2W::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR:${sparcv9_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-sparc64","gcc:-m64 -DB_ENDIAN ${debian_cflags} -DULTRASPARC -DBN_DIV2W::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_INT DES_PTR DES_RISC1 DES_UNROLL BF_PTR:${sparcv9_asm}:dlfcn:linux-shared:-fPIC:-m64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-x32","gcc:-mx32 -DL_ENDIAN ${debian_cflags} -DMD32_REG_T=int::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT RC4_CHUNK DES_INT DES_UNROLL:${x86_64_asm}:elf:dlfcn:linux-shared:-fPIC:-mx32:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::x32",
+
 ####
 #### Variety of LINUX:-)
 ####
@@ -1681,6 +1735,8 @@
 		}
 	}
 
+$shared_ldflag .= " -Wl,--version-script=openssl.ld";
+
 open(IN,'<Makefile.org') || die "unable to read Makefile.org:$!\n";
 unlink("$Makefile.new") || die "unable to remove old $Makefile.new:$!\n" if -e "$Makefile.new";
 open(OUT,">$Makefile.new") || die "unable to create $Makefile.new:$!\n";
@@ -1783,7 +1839,8 @@
 	elsif ($shared_extension ne "" && $shared_extension =~ /^\.s([ol])\.[^\.]*\.[^\.]*$/)
 		{
 		my $sotmp = $1;
-		s/^SHARED_LIBS_LINK_EXTS=.*/SHARED_LIBS_LINK_EXTS=.s$sotmp.\$(SHLIB_MAJOR) .s$sotmp/;
+#		s/^SHARED_LIBS_LINK_EXTS=.*/SHARED_LIBS_LINK_EXTS=.s$sotmp.\$(SHLIB_MAJOR) .s$sotmp/;
+		s/^SHARED_LIBS_LINK_EXTS=.*/SHARED_LIBS_LINK_EXTS=.s$sotmp/;
 		}
 	elsif ($shared_extension ne "" && $shared_extension =~ /^\.[^\.]*\.[^\.]*\.dylib$/)
 		{
@@ -1925,7 +1982,7 @@
 		}
 	elsif	(/^#define\s+ENGINESDIR/)
 		{
-		my $foo = "$prefix/$libdir/engines";
+		my $foo = "$prefix/$libdir/openssl-1.0.0/engines";
 		$foo =~ s/\\/\\\\/g;
 		print OUT "#define ENGINESDIR \"$foo\"\n";
 		}
diff -uNr openssl-1.0.2l.orig/Configure.orig openssl-1.0.2l/Configure.orig
--- openssl-1.0.2l.orig/Configure.orig	1970-01-01 08:00:00.000000000 +0800
+++ openssl-1.0.2l/Configure.orig	2018-07-16 17:01:21.656443082 +0800
@@ -0,0 +1,2367 @@
+:
+eval 'exec perl -S $0 ${1+"$@"}'
+    if $running_under_some_shell;
+##
+##  Configure -- OpenSSL source tree configuration script
+##
+
+require 5.000;
+use strict;
+use File::Compare;
+
+# see INSTALL for instructions.
+
+my $usage="Usage: Configure [no-<cipher> ...] [enable-<cipher> ...] [experimental-<cipher> ...] [-Dxxx] [-lxxx] [-Lxxx] [-fxxx] [-Kxxx] [no-hw-xxx|no-hw] [[no-]threads] [[no-]shared] [[no-]zlib|zlib-dynamic] [no-asm] [no-dso] [no-krb5] [sctp] [386] [--prefix=DIR] [--openssldir=OPENSSLDIR] [--with-xxx[=vvv]] [--test-sanity] os/compiler[:flags]\n";
+
+# Options:
+#
+# --openssldir  install OpenSSL in OPENSSLDIR (Default: DIR/ssl if the
+#               --prefix option is given; /usr/local/ssl otherwise)
+# --prefix      prefix for the OpenSSL include, lib and bin directories
+#               (Default: the OPENSSLDIR directory)
+#
+# --install_prefix  Additional prefix for package builders (empty by
+#               default).  This needn't be set in advance, you can
+#               just as well use "make INSTALL_PREFIX=/whatever install".
+#
+# --with-krb5-dir  Declare where Kerberos 5 lives.  The libraries are expected
+#		to live in the subdirectory lib/ and the header files in
+#		include/.  A value is required.
+# --with-krb5-lib  Declare where the Kerberos 5 libraries live.  A value is
+#		required.
+#		(Default: KRB5_DIR/lib)
+# --with-krb5-include  Declare where the Kerberos 5 header files live.  A
+#		value is required.
+#		(Default: KRB5_DIR/include)
+# --with-krb5-flavor  Declare what flavor of Kerberos 5 is used.  Currently
+#		supported values are "MIT" and "Heimdal".  A value is required.
+#
+# --test-sanity Make a number of sanity checks on the data in this file.
+#               This is a debugging tool for OpenSSL developers.
+#
+# --cross-compile-prefix Add specified prefix to binutils components.
+#
+# no-hw-xxx     do not compile support for specific crypto hardware.
+#               Generic OpenSSL-style methods relating to this support
+#               are always compiled but return NULL if the hardware
+#               support isn't compiled.
+# no-hw         do not compile support for any crypto hardware.
+# [no-]threads  [don't] try to create a library that is suitable for
+#               multithreaded applications (default is "threads" if we
+#               know how to do it)
+# [no-]shared	[don't] try to create shared libraries when supported.
+# no-asm        do not use assembler
+# no-dso        do not compile in any native shared-library methods. This
+#               will ensure that all methods just return NULL.
+# no-krb5       do not compile in any KRB5 library or code.
+# [no-]zlib     [don't] compile support for zlib compression.
+# zlib-dynamic	Like "zlib", but the zlib library is expected to be a shared
+#		library and will be loaded in run-time by the OpenSSL library.
+# sctp          include SCTP support
+# enable-weak-ssl-ciphers
+#		Enable EXPORT and LOW SSLv3 ciphers that are disabled by
+#		default.  Note, weak SSLv2 ciphers are unconditionally
+#		disabled.
+# 386		generate 80386 code in assembly modules
+# no-sse2	disables IA-32 SSE2 code in assembly modules, the above
+#		mentioned '386' option implies this one
+# no-<cipher>   build without specified algorithm (rsa, idea, rc5, ...)
+# -<xxx> +<xxx> compiler options are passed through 
+#
+# DEBUG_SAFESTACK use type-safe stacks to enforce type-safety on stack items
+#		provided to stack calls. Generates unique stack functions for
+#		each possible stack type.
+# DES_PTR	use pointer lookup vs arrays in the DES in crypto/des/des_locl.h
+# DES_RISC1	use different DES_ENCRYPT macro that helps reduce register
+#		dependancies but needs to more registers, good for RISC CPU's
+# DES_RISC2	A different RISC variant.
+# DES_UNROLL	unroll the inner DES loop, sometimes helps, somtimes hinders.
+# DES_INT	use 'int' instead of 'long' for DES_LONG in crypto/des/des.h
+#		This is used on the DEC Alpha where long is 8 bytes
+#		and int is 4
+# BN_LLONG	use the type 'long long' in crypto/bn/bn.h
+# MD2_CHAR	use 'char' instead of 'int' for MD2_INT in crypto/md2/md2.h
+# MD2_LONG	use 'long' instead of 'int' for MD2_INT in crypto/md2/md2.h
+# IDEA_SHORT	use 'short' instead of 'int' for IDEA_INT in crypto/idea/idea.h
+# IDEA_LONG	use 'long' instead of 'int' for IDEA_INT in crypto/idea/idea.h
+# RC2_SHORT	use 'short' instead of 'int' for RC2_INT in crypto/rc2/rc2.h
+# RC2_LONG	use 'long' instead of 'int' for RC2_INT in crypto/rc2/rc2.h
+# RC4_CHAR	use 'char' instead of 'int' for RC4_INT in crypto/rc4/rc4.h
+# RC4_LONG	use 'long' instead of 'int' for RC4_INT in crypto/rc4/rc4.h
+# RC4_INDEX	define RC4_INDEX in crypto/rc4/rc4_locl.h.  This turns on
+#		array lookups instead of pointer use.
+# RC4_CHUNK	enables code that handles data aligned at long (natural CPU
+#		word) boundary.
+# RC4_CHUNK_LL	enables code that handles data aligned at long long boundary
+#		(intended for 64-bit CPUs running 32-bit OS).
+# BF_PTR	use 'pointer arithmatic' for Blowfish (unsafe on Alpha).
+# BF_PTR2	intel specific version (generic version is more efficient).
+#
+# Following are set automatically by this script
+#
+# MD5_ASM	use some extra md5 assember,
+# SHA1_ASM	use some extra sha1 assember, must define L_ENDIAN for x86
+# RMD160_ASM	use some extra ripemd160 assember,
+# SHA256_ASM	sha256_block is implemented in assembler
+# SHA512_ASM	sha512_block is implemented in assembler
+# AES_ASM	ASE_[en|de]crypt is implemented in assembler
+
+# Minimum warning options... any contributions to OpenSSL should at least get
+# past these. 
+
+my $gcc_devteam_warn = "-Wall -pedantic -DPEDANTIC -Wno-long-long -Wsign-compare -Wmissing-prototypes -Wshadow -Wformat -Wundef -Werror -DCRYPTO_MDEBUG_ALL -DCRYPTO_MDEBUG_ABORT -DREF_CHECK -DOPENSSL_NO_DEPRECATED";
+
+# TODO(openssl-team): fix problems and investigate if (at least) the following
+# warnings can also be enabled:
+# -Wconditional-uninitialized, -Wswitch-enum, -Wunused-macros,
+# -Wmissing-field-initializers, -Wmissing-variable-declarations,
+# -Wincompatible-pointer-types-discards-qualifiers, -Wcast-align,
+# -Wunreachable-code -Wunused-parameter -Wlanguage-extension-token
+# -Wextended-offsetof
+my $clang_disabled_warnings = "-Wno-unused-parameter -Wno-missing-field-initializers -Wno-language-extension-token  -Wno-extended-offsetof";
+
+# These are used in addition to $gcc_devteam_warn when the compiler is clang.
+# TODO(openssl-team): fix problems and investigate if (at least) the
+# following warnings can also be enabled: -Wconditional-uninitialized,
+# -Wswitch-enum, -Wunused-macros, -Wmissing-field-initializers,
+# -Wmissing-variable-declarations,
+# -Wincompatible-pointer-types-discards-qualifiers, -Wcast-align,
+# -Wunreachable-code -Wunused-parameter -Wlanguage-extension-token
+# -Wextended-offsetof
+my $clang_devteam_warn = "-Wno-unused-parameter -Wno-missing-field-initializers -Wno-language-extension-token -Wno-extended-offsetof -Qunused-arguments";
+
+# Warn that "make depend" should be run?
+my $warn_make_depend = 0;
+
+# There are no separate CFLAGS/CPPFLAGS/LDFLAGS, set everything in CFLAGS
+my $debian_cflags = `dpkg-buildflags --get CFLAGS` . `dpkg-buildflags --get CPPFLAGS` . `dpkg-buildflags --get LDFLAGS` . "-Wa,--noexecstack -Wall";
+$debian_cflags =~ s/\n/ /g;
+
+my $strict_warnings = 0;
+
+my $x86_gcc_des="DES_PTR DES_RISC1 DES_UNROLL";
+
+# MD2_CHAR slags pentium pros
+my $x86_gcc_opts="RC4_INDEX MD2_INT";
+
+# MODIFY THESE PARAMETERS IF YOU ARE GOING TO USE THE 'util/speed.sh SCRIPT
+# Don't worry about these normally
+
+my $tcc="cc";
+my $tflags="-fast -Xa";
+my $tbn_mul="";
+my $tlib="-lnsl -lsocket";
+#$bits1="SIXTEEN_BIT ";
+#$bits2="THIRTY_TWO_BIT ";
+my $bits1="THIRTY_TWO_BIT ";
+my $bits2="SIXTY_FOUR_BIT ";
+
+my $x86_asm="x86cpuid.o:bn-586.o co-586.o x86-mont.o x86-gf2m.o::des-586.o crypt586.o:aes-586.o vpaes-x86.o aesni-x86.o:bf-586.o:md5-586.o:sha1-586.o sha256-586.o sha512-586.o:cast-586.o:rc4-586.o:rmd-586.o:rc5-586.o:wp_block.o wp-mmx.o:cmll-x86.o:ghash-x86.o:";
+
+my $x86_elf_asm="$x86_asm:elf";
+
+my $x86_64_asm="x86_64cpuid.o:x86_64-gcc.o x86_64-mont.o x86_64-mont5.o x86_64-gf2m.o rsaz_exp.o rsaz-x86_64.o rsaz-avx2.o:ecp_nistz256.o ecp_nistz256-x86_64.o::aes-x86_64.o vpaes-x86_64.o bsaes-x86_64.o aesni-x86_64.o aesni-sha1-x86_64.o aesni-sha256-x86_64.o aesni-mb-x86_64.o::md5-x86_64.o:sha1-x86_64.o sha256-x86_64.o sha512-x86_64.o sha1-mb-x86_64.o sha256-mb-x86_64.o::rc4-x86_64.o rc4-md5-x86_64.o:::wp-x86_64.o:cmll-x86_64.o cmll_misc.o:ghash-x86_64.o aesni-gcm-x86_64.o:";
+my $ia64_asm="ia64cpuid.o:bn-ia64.o ia64-mont.o:::aes_core.o aes_cbc.o aes-ia64.o::md5-ia64.o:sha1-ia64.o sha256-ia64.o sha512-ia64.o::rc4-ia64.o rc4_skey.o:::::ghash-ia64.o::void";
+my $sparcv9_asm="sparcv9cap.o sparccpuid.o:bn-sparcv9.o sparcv9-mont.o sparcv9a-mont.o vis3-mont.o sparct4-mont.o sparcv9-gf2m.o::des_enc-sparc.o fcrypt_b.o dest4-sparcv9.o:aes_core.o aes_cbc.o aes-sparcv9.o aest4-sparcv9.o::md5-sparcv9.o:sha1-sparcv9.o sha256-sparcv9.o sha512-sparcv9.o::::::camellia.o cmll_misc.o cmll_cbc.o cmllt4-sparcv9.o:ghash-sparcv9.o::void";
+my $sparcv8_asm=":sparcv8.o::des_enc-sparc.o fcrypt_b.o:::::::::::::void";
+my $alpha_asm="alphacpuid.o:bn_asm.o alpha-mont.o::::::sha1-alpha.o:::::::ghash-alpha.o::void";
+my $mips64_asm=":bn-mips.o mips-mont.o:::aes_cbc.o aes-mips.o:::sha1-mips.o sha256-mips.o sha512-mips.o::::::::";
+my $mips32_asm=$mips64_asm; $mips32_asm =~ s/\s*sha512\-mips\.o//;
+my $s390x_asm="s390xcap.o s390xcpuid.o:bn-s390x.o s390x-mont.o s390x-gf2m.o:::aes-s390x.o aes-ctr.o aes-xts.o:::sha1-s390x.o sha256-s390x.o sha512-s390x.o::rc4-s390x.o:::::ghash-s390x.o:";
+my $armv4_asm="armcap.o armv4cpuid.o:bn_asm.o armv4-mont.o armv4-gf2m.o:::aes_cbc.o aes-armv4.o bsaes-armv7.o aesv8-armx.o:::sha1-armv4-large.o sha256-armv4.o sha512-armv4.o:::::::ghash-armv4.o ghashv8-armx.o::void";
+my $aarch64_asm="armcap.o arm64cpuid.o mem_clr.o::::aes_core.o aes_cbc.o aesv8-armx.o:::sha1-armv8.o sha256-armv8.o sha512-armv8.o:::::::ghashv8-armx.o:";
+my $parisc11_asm="pariscid.o:bn_asm.o parisc-mont.o:::aes_core.o aes_cbc.o aes-parisc.o:::sha1-parisc.o sha256-parisc.o sha512-parisc.o::rc4-parisc.o:::::ghash-parisc.o::32";
+my $parisc20_asm="pariscid.o:pa-risc2W.o parisc-mont.o:::aes_core.o aes_cbc.o aes-parisc.o:::sha1-parisc.o sha256-parisc.o sha512-parisc.o::rc4-parisc.o:::::ghash-parisc.o::64";
+my $ppc64_asm="ppccpuid.o ppccap.o:bn-ppc.o ppc-mont.o ppc64-mont.o:::aes_core.o aes_cbc.o aes-ppc.o vpaes-ppc.o aesp8-ppc.o:::sha1-ppc.o sha256-ppc.o sha512-ppc.o sha256p8-ppc.o sha512p8-ppc.o:::::::ghashp8-ppc.o:";
+my $ppc32_asm=$ppc64_asm;
+my $no_asm="::::::::::::::::void";
+
+# As for $BSDthreads. Idea is to maintain "collective" set of flags,
+# which would cover all BSD flavors. -pthread applies to them all, 
+# but is treated differently. OpenBSD expands is as -D_POSIX_THREAD
+# -lc_r, which is sufficient. FreeBSD 4.x expands it as -lc_r,
+# which has to be accompanied by explicit -D_THREAD_SAFE and
+# sometimes -D_REENTRANT. FreeBSD 5.x expands it as -lc_r, which
+# seems to be sufficient?
+my $BSDthreads="-pthread -D_THREAD_SAFE -D_REENTRANT";
+
+#config-string	$cc : $cflags : $unistd : $thread_cflag : $sys_id : $lflags : $bn_ops : $cpuid_obj : $bn_obj : $ec_obj : $des_obj : $aes_obj : $bf_obj : $md5_obj : $sha1_obj : $cast_obj : $rc4_obj : $rmd160_obj : $rc5_obj : $wp_obj : $cmll_obj : $modes_obj : $engines_obj : $dso_scheme : $shared_target : $shared_cflag : $shared_ldflag : $shared_extension : $ranlib : $arflags : $multilib
+
+my %table=(
+# File 'TABLE' (created by 'make TABLE') contains the data from this list,
+# formatted for better readability.
+
+
+#"b",		"${tcc}:${tflags}::${tlib}:${bits1}:${tbn_mul}::",
+#"bl-4c-2c",	"${tcc}:${tflags}::${tlib}:${bits1}BN_LLONG RC4_CHAR MD2_CHAR:${tbn_mul}::",
+#"bl-4c-ri",	"${tcc}:${tflags}::${tlib}:${bits1}BN_LLONG RC4_CHAR RC4_INDEX:${tbn_mul}::",
+#"b2-is-ri-dp",	"${tcc}:${tflags}::${tlib}:${bits2}IDEA_SHORT RC4_INDEX DES_PTR:${tbn_mul}::",
+
+# Our development configs
+"purify",	"purify gcc:-g -DPURIFY -Wall::(unknown)::-lsocket -lnsl::::",
+"debug",	"gcc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DBN_CTX_DEBUG -DCRYPTO_MDEBUG -DOPENSSL_NO_ASM -ggdb -g2 -Wformat -Wshadow -Wmissing-prototypes -Wmissing-declarations -Werror::(unknown)::-lefence::::",
+"debug-ben",	"gcc:$gcc_devteam_warn -DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DBN_CTX_DEBUG -DCRYPTO_MDEBUG -DDEBUG_SAFESTACK -O2 -pipe::(unknown):::::",
+"debug-ben-openbsd","gcc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DBN_CTX_DEBUG -DCRYPTO_MDEBUG -DPEDANTIC -DDEBUG_SAFESTACK -DOPENSSL_OPENBSD_DEV_CRYPTO -DOPENSSL_NO_ASM -O2 -pedantic -Wall -Wshadow -Werror -pipe::(unknown)::::",
+"debug-ben-openbsd-debug","gcc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DBN_CTX_DEBUG -DCRYPTO_MDEBUG -DPEDANTIC -DDEBUG_SAFESTACK -DOPENSSL_OPENBSD_DEV_CRYPTO -DOPENSSL_NO_ASM -g3 -O2 -pedantic -Wall -Wshadow -Werror -pipe::(unknown)::::",
+"debug-ben-debug",	"gcc44:$gcc_devteam_warn -DBN_DEBUG -DCONF_DEBUG -DDEBUG_SAFESTACK -DDEBUG_UNUSED -g3 -O2 -pipe::(unknown)::::::",
+"debug-ben-debug-64",	"gcc:$gcc_devteam_warn -Wno-error=overlength-strings -DBN_DEBUG -DCONF_DEBUG -DDEBUG_SAFESTACK -DDEBUG_UNUSED -g3 -O3 -pipe::${BSDthreads}:::SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_INT DES_UNROLL:${x86_64_asm}:elf:dlfcn:bsd-gcc-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debug-ben-macos",	"cc:$gcc_devteam_warn -arch i386 -DBN_DEBUG -DCONF_DEBUG -DDEBUG_SAFESTACK -DDEBUG_UNUSED -DOPENSSL_THREADS -D_REENTRANT -DDSO_DLFCN -DHAVE_DLFCN_H -O3 -DL_ENDIAN -g3 -pipe::(unknown)::-Wl,-search_paths_first::::",
+"debug-ben-macos-gcc46",	"gcc-mp-4.6:$gcc_devteam_warn -Wconversion -DBN_DEBUG -DCONF_DEBUG -DDEBUG_SAFESTACK -DDEBUG_UNUSED -DOPENSSL_THREADS -D_REENTRANT -DDSO_DLFCN -DHAVE_DLFCN_H -O3 -DL_ENDIAN -g3 -pipe::(unknown)::::::",
+"debug-ben-darwin64","cc:$gcc_devteam_warn -g -Wno-language-extension-token -Wno-extended-offsetof -arch x86_64 -O3 -DL_ENDIAN -Wall::-D_REENTRANT:MACOSX:-Wl,-search_paths_first%:SIXTY_FOUR_BIT_LONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL:".eval{my $asm=$x86_64_asm;$asm=~s/rc4\-[^:]+//;$asm}.":macosx:dlfcn:darwin-shared:-fPIC -fno-common:-arch x86_64 -dynamiclib:.\$(SHLIB_MAJOR).\$(SHLIB_MINOR).dylib",
+"debug-ben-debug-64-clang",	"clang:$gcc_devteam_warn -Wno-error=overlength-strings -Wno-error=extended-offsetof -Qunused-arguments -DBN_DEBUG -DCONF_DEBUG -DDEBUG_SAFESTACK -DDEBUG_UNUSED -g3 -O3 -pipe::${BSDthreads}:::SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_INT DES_UNROLL:${x86_64_asm}:elf:dlfcn:bsd-gcc-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debug-ben-no-opt",	"gcc: -Wall -Wmissing-prototypes -Wstrict-prototypes -Wmissing-declarations -DDEBUG_SAFESTACK -DCRYPTO_MDEBUG -Werror -DL_ENDIAN -DTERMIOS -Wall -g3::(unknown)::::::",
+"debug-ben-strict",	"gcc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DBN_CTX_DEBUG -DCRYPTO_MDEBUG -DCONST_STRICT -O2 -Wall -Wshadow -Werror -Wpointer-arith -Wcast-qual -Wwrite-strings -pipe::(unknown)::::::",
+"debug-rse","cc:-DTERMIOS -DL_ENDIAN -pipe -O -g -ggdb3 -Wall::(unknown):::BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}",
+"debug-bodo",	"gcc:$gcc_devteam_warn -Wno-error=overlength-strings -DBN_DEBUG -DBN_DEBUG_RAND -DCONF_DEBUG -DBIO_PAIR_DEBUG -m64 -DL_ENDIAN -DTERMIO -g -DMD32_REG_T=int::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_INT DES_UNROLL:${x86_64_asm}:elf:dlfcn:linux-shared:-fPIC:-m64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::64",
+"debug-steve64", "gcc:$gcc_devteam_warn -m64 -DL_ENDIAN -DTERMIO -DCONF_DEBUG -DDEBUG_SAFESTACK -Wno-overlength-strings -g::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_INT DES_UNROLL:${x86_64_asm}:elf:dlfcn:linux-shared:-fPIC:-m64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debug-steve32", "gcc:$gcc_devteam_warn -m32 -DL_ENDIAN -DCONF_DEBUG -DDEBUG_SAFESTACK -Wno-overlength-strings -g -pipe::-D_REENTRANT::-rdynamic -ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:linux-shared:-fPIC:-m32:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debug-steve-opt", "gcc:$gcc_devteam_warn -m64 -O3 -DL_ENDIAN -DTERMIO -DCONF_DEBUG -DDEBUG_SAFESTACK -g::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_INT DES_UNROLL:${x86_64_asm}:elf:dlfcn:linux-shared:-fPIC:-m64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debug-levitte-linux-elf","gcc:-DLEVITTE_DEBUG -DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DCRYPTO_MDEBUG -DL_ENDIAN -ggdb -g3 -Wall::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debug-levitte-linux-noasm","gcc:-DLEVITTE_DEBUG -DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DCRYPTO_MDEBUG -DOPENSSL_NO_ASM -DL_ENDIAN -ggdb -g3 -Wall::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debug-levitte-linux-elf-extreme","gcc:-DLEVITTE_DEBUG -DREF_CHECK -DCONF_DEBUG -DBN_DEBUG -DBN_DEBUG_RAND -DCRYPTO_MDEBUG -DENGINE_CONF_DEBUG -DL_ENDIAN -DPEDANTIC -ggdb -g3 -pedantic -ansi -Wall -W -Wundef -Wshadow -Wcast-align -Wstrict-prototypes -Wmissing-prototypes -Wno-long-long -Wundef -Wconversion -pipe::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debug-levitte-linux-noasm-extreme","gcc:-DLEVITTE_DEBUG -DREF_CHECK -DCONF_DEBUG -DBN_DEBUG -DBN_DEBUG_RAND -DCRYPTO_MDEBUG -DENGINE_CONF_DEBUG -DOPENSSL_NO_ASM -DL_ENDIAN -DPEDANTIC -ggdb -g3 -pedantic -ansi -Wall -W -Wundef -Wshadow -Wcast-align -Wstrict-prototypes -Wmissing-prototypes -Wno-long-long -Wundef -Wconversion -pipe::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debug-geoff32","gcc:-DBN_DEBUG -DBN_DEBUG_RAND -DBN_STRICT -DPURIFY -DOPENSSL_NO_DEPRECATED -DOPENSSL_NO_ASM -DOPENSSL_NO_INLINE_ASM -DL_ENDIAN -DTERMIO -DPEDANTIC -O1 -ggdb2 -Wall -Werror -Wundef -pedantic -Wshadow -Wpointer-arith -Wbad-function-cast -Wcast-align -Wsign-compare -Wmissing-prototypes -Wmissing-declarations -Wno-long-long::-D_REENTRANT::-ldl:BN_LLONG:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debug-geoff64","gcc:-DBN_DEBUG -DBN_DEBUG_RAND -DBN_STRICT -DPURIFY -DOPENSSL_NO_DEPRECATED -DOPENSSL_NO_ASM -DOPENSSL_NO_INLINE_ASM -DL_ENDIAN -DTERMIO -DPEDANTIC -O1 -ggdb2 -Wall -Werror -Wundef -pedantic -Wshadow -Wpointer-arith -Wbad-function-cast -Wcast-align -Wsign-compare -Wmissing-prototypes -Wmissing-declarations -Wno-long-long::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL BF_PTR:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debug-linux-pentium","gcc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DBN_CTX_DEBUG -DCRYPTO_MDEBUG -DL_ENDIAN -g -mcpu=pentium -Wall::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn",
+"debug-linux-ppro","gcc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DBN_CTX_DEBUG -DCRYPTO_MDEBUG -DL_ENDIAN -g -mcpu=pentiumpro -Wall::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn",
+"debug-linux-elf","gcc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DBN_CTX_DEBUG -DCRYPTO_MDEBUG -DL_ENDIAN -g -march=i486 -Wall::-D_REENTRANT::-lefence -ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debug-linux-elf-noefence","gcc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DBN_CTX_DEBUG -DCRYPTO_MDEBUG -DL_ENDIAN -g -march=i486 -Wall::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debug-linux-ia32-aes", "gcc:-DAES_EXPERIMENTAL -DL_ENDIAN -O3 -fomit-frame-pointer -Wall::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:x86cpuid.o:bn-586.o co-586.o x86-mont.o::des-586.o crypt586.o:aes_x86core.o aes_cbc.o aesni-x86.o:bf-586.o:md5-586.o:sha1-586.o sha256-586.o sha512-586.o:cast-586.o:rc4-586.o:rmd-586.o:rc5-586.o:wp_block.o wp-mmx.o::ghash-x86.o::elf:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debug-linux-generic32","gcc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DCRYPTO_MDEBUG -g -Wall::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL BF_PTR:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debug-linux-generic64","gcc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DCRYPTO_MDEBUG -DTERMIO -g -Wall::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL BF_PTR:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debug-linux-x86_64","gcc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DCRYPTO_MDEBUG -m64 -DL_ENDIAN -g -Wall::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_INT DES_UNROLL:${x86_64_asm}:elf:dlfcn:linux-shared:-fPIC:-m64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::64",
+"dist",		"cc:-O::(unknown)::::::",
+
+# Basic configs that should work on any (32 and less bit) box
+"gcc",		"gcc:-O3::(unknown):::BN_LLONG:::",
+"cc",		"cc:-O::(unknown)::::::",
+
+####VOS Configurations
+"vos-gcc","gcc:-O3 -Wall -DOPENSSL_SYSNAME_VOS -D_POSIX_C_SOURCE=200112L -D_BSD -D_VOS_EXTENDED_NAMES -DB_ENDIAN::(unknown):VOS:-Wl,-map:BN_LLONG:${no_asm}:::::.so:",
+"debug-vos-gcc","gcc:-O0 -g -Wall -DOPENSSL_SYSNAME_VOS -D_POSIX_C_SOURCE=200112L -D_BSD -D_VOS_EXTENDED_NAMES -DB_ENDIAN -DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DCRYPTO_MDEBUG::(unknown):VOS:-Wl,-map:BN_LLONG:${no_asm}:::::.so:",
+
+#### Solaris x86 with GNU C setups
+# -DOPENSSL_NO_INLINE_ASM switches off inline assembler. We have to do it
+# here because whenever GNU C instantiates an assembler template it
+# surrounds it with #APP #NO_APP comment pair which (at least Solaris
+# 7_x86) /usr/ccs/bin/as fails to assemble with "Illegal mnemonic"
+# error message.
+"solaris-x86-gcc","gcc:-O3 -fomit-frame-pointer -march=pentium -Wall -DL_ENDIAN -DOPENSSL_NO_INLINE_ASM::-D_REENTRANT::-lsocket -lnsl -ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:solaris-shared:-fPIC:-shared:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+# -shared -static-libgcc might appear controversial, but modules taken
+# from static libgcc do not have relocations and linking them into our
+# shared objects doesn't have any negative side-effects. On the contrary,
+# doing so makes it possible to use gcc shared build with Sun C. Given
+# that gcc generates faster code [thanks to inline assembler], I would
+# actually recommend to consider using gcc shared build even with vendor
+# compiler:-)
+#						<appro@fy.chalmers.se>
+"solaris64-x86_64-gcc","gcc:-m64 -O3 -Wall -DL_ENDIAN::-D_REENTRANT::-lsocket -lnsl -ldl:SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_INT DES_UNROLL:${x86_64_asm}:elf:dlfcn:solaris-shared:-fPIC:-m64 -shared -static-libgcc:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::/64",
+ 
+#### Solaris x86 with Sun C setups
+"solaris-x86-cc","cc:-fast -xarch=generic -O -Xa::-D_REENTRANT::-lsocket -lnsl -ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_PTR DES_UNROLL BF_PTR:${no_asm}:dlfcn:solaris-shared:-KPIC:-G -dy -z text:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"solaris64-x86_64-cc","cc:-fast -xarch=amd64 -xstrconst -Xa -DL_ENDIAN::-D_REENTRANT::-lsocket -lnsl -ldl:SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_INT DES_UNROLL:${x86_64_asm}:elf:dlfcn:solaris-shared:-KPIC:-xarch=amd64 -G -dy -z text:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::/64",
+
+#### SPARC Solaris with GNU C setups
+"solaris-sparcv7-gcc","gcc:-O3 -fomit-frame-pointer -Wall -DB_ENDIAN -DBN_DIV2W::-D_REENTRANT::-lsocket -lnsl -ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR:${no_asm}:dlfcn:solaris-shared:-fPIC:-shared:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"solaris-sparcv8-gcc","gcc:-mcpu=v8 -O3 -fomit-frame-pointer -Wall -DB_ENDIAN -DBN_DIV2W::-D_REENTRANT::-lsocket -lnsl -ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR:${sparcv8_asm}:dlfcn:solaris-shared:-fPIC:-shared:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+# -m32 should be safe to add as long as driver recognizes -mcpu=ultrasparc
+"solaris-sparcv9-gcc","gcc:-m32 -mcpu=ultrasparc -O3 -fomit-frame-pointer -Wall -DB_ENDIAN -DBN_DIV2W::-D_REENTRANT:ULTRASPARC:-lsocket -lnsl -ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR:${sparcv9_asm}:dlfcn:solaris-shared:-fPIC:-shared:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"solaris64-sparcv9-gcc","gcc:-m64 -mcpu=ultrasparc -O3 -Wall -DB_ENDIAN::-D_REENTRANT:ULTRASPARC:-lsocket -lnsl -ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_INT DES_PTR DES_RISC1 DES_UNROLL BF_PTR:${sparcv9_asm}:dlfcn:solaris-shared:-fPIC:-m64 -shared:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::/64",
+####
+"debug-solaris-sparcv8-gcc","gcc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DBN_CTX_DEBUG -DCRYPTO_MDEBUG_ALL -O -g -mcpu=v8 -Wall -DB_ENDIAN::-D_REENTRANT::-lsocket -lnsl -ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR:${sparcv8_asm}:dlfcn:solaris-shared:-fPIC:-shared:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debug-solaris-sparcv9-gcc","gcc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DBN_CTX_DEBUG -DCRYPTO_MDEBUG_ALL -DPEDANTIC -O -g -mcpu=ultrasparc -pedantic -ansi -Wall -Wshadow -Wno-long-long -D__EXTENSIONS__ -DB_ENDIAN -DBN_DIV2W::-D_REENTRANT:ULTRASPARC:-lsocket -lnsl -ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR:${sparcv9_asm}:dlfcn:solaris-shared:-fPIC:-shared:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+
+#### SPARC Solaris with Sun C setups
+# SC4.0 doesn't pass 'make test', upgrade to SC5.0 or SC4.2.
+# SC4.2 is ok, better than gcc even on bn as long as you tell it -xarch=v8
+# SC5.0 note: Compiler common patch 107357-01 or later is required!
+"solaris-sparcv7-cc","cc:-xO5 -xstrconst -xdepend -Xa -DB_ENDIAN -DBN_DIV2W::-D_REENTRANT::-lsocket -lnsl -ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_PTR DES_RISC1 DES_UNROLL BF_PTR:${no_asm}:dlfcn:solaris-shared:-KPIC:-G -dy -z text:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"solaris-sparcv8-cc","cc:-xarch=v8 -xO5 -xstrconst -xdepend -Xa -DB_ENDIAN -DBN_DIV2W::-D_REENTRANT::-lsocket -lnsl -ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_PTR DES_RISC1 DES_UNROLL BF_PTR:${sparcv8_asm}:dlfcn:solaris-shared:-KPIC:-G -dy -z text:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"solaris-sparcv9-cc","cc:-xtarget=ultra -xarch=v8plus -xO5 -xstrconst -xdepend -Xa -DB_ENDIAN -DBN_DIV2W::-D_REENTRANT:ULTRASPARC:-lsocket -lnsl -ldl:BN_LLONG RC4_CHAR RC4_CHUNK_LL DES_PTR DES_RISC1 DES_UNROLL BF_PTR:${sparcv9_asm}:dlfcn:solaris-shared:-KPIC:-G -dy -z text:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"solaris64-sparcv9-cc","cc:-xtarget=ultra -xarch=v9 -xO5 -xstrconst -xdepend -Xa -DB_ENDIAN::-D_REENTRANT:ULTRASPARC:-lsocket -lnsl -ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_INT DES_PTR DES_RISC1 DES_UNROLL BF_PTR:${sparcv9_asm}:dlfcn:solaris-shared:-KPIC:-xarch=v9 -G -dy -z text:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::/64",
+####
+"debug-solaris-sparcv8-cc","cc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DBN_CTX_DEBUG -DCRYPTO_MDEBUG_ALL -xarch=v8 -g -O -xstrconst -Xa -DB_ENDIAN -DBN_DIV2W::-D_REENTRANT::-lsocket -lnsl -ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_PTR DES_RISC1 DES_UNROLL BF_PTR:${sparcv8_asm}:dlfcn:solaris-shared:-KPIC:-G -dy -z text:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debug-solaris-sparcv9-cc","cc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DBN_CTX_DEBUG -DCRYPTO_MDEBUG_ALL -xtarget=ultra -xarch=v8plus -g -O -xstrconst -Xa -DB_ENDIAN -DBN_DIV2W::-D_REENTRANT:ULTRASPARC:-lsocket -lnsl -ldl:BN_LLONG RC4_CHAR RC4_CHUNK_LL DES_PTR DES_RISC1 DES_UNROLL BF_PTR:${sparcv9_asm}:dlfcn:solaris-shared:-KPIC:-G -dy -z text:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)", 
+
+#### SunOS configs, assuming sparc for the gcc one.
+#"sunos-cc", "cc:-O4 -DNOPROTO -DNOCONST::(unknown):SUNOS::DES_UNROLL:${no_asm}::",
+"sunos-gcc","gcc:-O3 -mcpu=v8 -Dssize_t=int::(unknown):SUNOS::BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL DES_PTR DES_RISC1:${no_asm}::",
+
+#### IRIX 5.x configs
+# -mips2 flag is added by ./config when appropriate.
+"irix-gcc","gcc:-O3 -DB_ENDIAN::(unknown):::BN_LLONG MD2_CHAR RC4_INDEX RC4_CHAR RC4_CHUNK DES_UNROLL DES_RISC2 DES_PTR BF_PTR:${mips32_asm}:o32:dlfcn:irix-shared:::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"irix-cc", "cc:-O2 -use_readonly_const -DB_ENDIAN::(unknown):::BN_LLONG RC4_CHAR RC4_CHUNK DES_PTR DES_RISC2 DES_UNROLL BF_PTR:${mips32_asm}:o32:dlfcn:irix-shared:::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+#### IRIX 6.x configs
+# Only N32 and N64 ABIs are supported. If you need O32 ABI build, invoke
+# './Configure irix-cc -o32' manually.
+"irix-mips3-gcc","gcc:-mabi=n32 -O3 -DB_ENDIAN -DBN_DIV3W::-D_SGI_MP_SOURCE:::MD2_CHAR RC4_INDEX RC4_CHAR RC4_CHUNK_LL DES_UNROLL DES_RISC2 DES_PTR BF_PTR SIXTY_FOUR_BIT:${mips64_asm}:n32:dlfcn:irix-shared::-mabi=n32:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::32",
+"irix-mips3-cc", "cc:-n32 -mips3 -O2 -use_readonly_const -G0 -rdata_shared -DB_ENDIAN -DBN_DIV3W::-D_SGI_MP_SOURCE:::DES_PTR RC4_CHAR RC4_CHUNK_LL DES_RISC2 DES_UNROLL BF_PTR SIXTY_FOUR_BIT:${mips64_asm}:n32:dlfcn:irix-shared::-n32:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::32",
+# N64 ABI builds.
+"irix64-mips4-gcc","gcc:-mabi=64 -mips4 -O3 -DB_ENDIAN -DBN_DIV3W::-D_SGI_MP_SOURCE:::RC4_CHAR RC4_CHUNK DES_RISC2 DES_UNROLL SIXTY_FOUR_BIT_LONG:${mips64_asm}:64:dlfcn:irix-shared::-mabi=64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::64",
+"irix64-mips4-cc", "cc:-64 -mips4 -O2 -use_readonly_const -G0 -rdata_shared -DB_ENDIAN -DBN_DIV3W::-D_SGI_MP_SOURCE:::RC4_CHAR RC4_CHUNK DES_RISC2 DES_UNROLL SIXTY_FOUR_BIT_LONG:${mips64_asm}:64:dlfcn:irix-shared::-64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::64",
+
+#### Unified HP-UX ANSI C configs.
+# Special notes:
+# - Originally we were optimizing at +O4 level. It should be noted
+#   that the only difference between +O3 and +O4 is global inter-
+#   procedural analysis. As it has to be performed during the link
+#   stage the compiler leaves behind certain pseudo-code in lib*.a
+#   which might be release or even patch level specific. Generating
+#   the machine code for and analyzing the *whole* program appears
+#   to be *extremely* memory demanding while the performance gain is
+#   actually questionable. The situation is intensified by the default
+#   HP-UX data set size limit (infamous 'maxdsiz' tunable) of 64MB
+#   which is way too low for +O4. In other words, doesn't +O3 make
+#   more sense?
+# - Keep in mind that the HP compiler by default generates code
+#   suitable for execution on the host you're currently compiling at.
+#   If the toolkit is ment to be used on various PA-RISC processors
+#   consider './config +DAportable'.
+# - +DD64 is chosen in favour of +DA2.0W because it's meant to be
+#   compatible with *future* releases.
+# - If you run ./Configure hpux-parisc-[g]cc manually don't forget to
+#   pass -D_REENTRANT on HP-UX 10 and later.
+# - -DMD32_XARRAY triggers workaround for compiler bug we ran into in
+#   32-bit message digests. (For the moment of this writing) HP C
+#   doesn't seem to "digest" too many local variables (they make "him"
+#   chew forever:-). For more details look-up MD32_XARRAY comment in
+#   crypto/sha/sha_lcl.h.
+#					<appro@fy.chalmers.se>
+#
+# Since there is mention of this in shlib/hpux10-cc.sh
+"hpux-parisc-cc-o4","cc:-Ae +O4 +ESlit -z -DB_ENDIAN -DBN_DIV2W -DMD32_XARRAY::-D_REENTRANT::-ldld:BN_LLONG DES_PTR DES_UNROLL DES_RISC1:${no_asm}:dl:hpux-shared:+Z:-b:.sl.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"hpux-parisc-gcc","gcc:-O3 -DB_ENDIAN -DBN_DIV2W::-D_REENTRANT::-Wl,+s -ldld:BN_LLONG DES_PTR DES_UNROLL DES_RISC1:${no_asm}:dl:hpux-shared:-fPIC:-shared:.sl.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"hpux-parisc1_1-gcc","gcc:-O3 -DB_ENDIAN -DBN_DIV2W::-D_REENTRANT::-Wl,+s -ldld:BN_LLONG DES_PTR DES_UNROLL DES_RISC1:${parisc11_asm}:dl:hpux-shared:-fPIC:-shared:.sl.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::/pa1.1",
+"hpux-parisc2-gcc","gcc:-march=2.0 -O3 -DB_ENDIAN -D_REENTRANT::::-Wl,+s -ldld:SIXTY_FOUR_BIT RC4_CHAR RC4_CHUNK DES_PTR DES_UNROLL DES_RISC1:".eval{my $asm=$parisc20_asm;$asm=~s/2W\./2\./;$asm=~s/:64/:32/;$asm}.":dl:hpux-shared:-fPIC:-shared:.sl.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::/pa20_32",
+"hpux64-parisc2-gcc","gcc:-O3 -DB_ENDIAN -D_REENTRANT::::-ldl:SIXTY_FOUR_BIT_LONG MD2_CHAR RC4_INDEX RC4_CHAR DES_UNROLL DES_RISC1 DES_INT::pa-risc2W.o:::::::::::::::void:dlfcn:hpux-shared:-fpic:-shared:.sl.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::/pa20_64",
+
+# More attempts at unified 10.X and 11.X targets for HP C compiler.
+#
+# Chris Ruemmler <ruemmler@cup.hp.com>
+# Kevin Steves <ks@hp.se>
+"hpux-parisc-cc","cc:+O3 +Optrs_strongly_typed -Ae +ESlit -DB_ENDIAN -DBN_DIV2W -DMD32_XARRAY::-D_REENTRANT::-Wl,+s -ldld:MD2_CHAR RC4_INDEX RC4_CHAR DES_UNROLL DES_RISC1 DES_INT:${no_asm}:dl:hpux-shared:+Z:-b:.sl.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"hpux-parisc1_1-cc","cc:+DA1.1 +O3 +Optrs_strongly_typed -Ae +ESlit -DB_ENDIAN -DMD32_XARRAY::-D_REENTRANT::-Wl,+s -ldld:MD2_CHAR RC4_INDEX RC4_CHAR DES_UNROLL DES_RISC1 DES_INT:${parisc11_asm}:dl:hpux-shared:+Z:-b:.sl.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::/pa1.1",
+"hpux-parisc2-cc","cc:+DA2.0 +DS2.0 +O3 +Optrs_strongly_typed -Ae +ESlit -DB_ENDIAN -DMD32_XARRAY -D_REENTRANT::::-Wl,+s -ldld:SIXTY_FOUR_BIT MD2_CHAR RC4_INDEX RC4_CHAR DES_UNROLL DES_RISC1 DES_INT:".eval{my $asm=$parisc20_asm;$asm=~s/2W\./2\./;$asm=~s/:64/:32/;$asm}.":dl:hpux-shared:+Z:-b:.sl.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::/pa20_32",
+"hpux64-parisc2-cc","cc:+DD64 +O3 +Optrs_strongly_typed -Ae +ESlit -DB_ENDIAN -DMD32_XARRAY -D_REENTRANT::::-ldl:SIXTY_FOUR_BIT_LONG MD2_CHAR RC4_INDEX RC4_CHAR DES_UNROLL DES_RISC1 DES_INT:${parisc20_asm}:dlfcn:hpux-shared:+Z:+DD64 -b:.sl.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::/pa20_64",
+
+# HP/UX IA-64 targets
+"hpux-ia64-cc","cc:-Ae +DD32 +O2 +Olit=all -z -DB_ENDIAN -D_REENTRANT::::-ldl:SIXTY_FOUR_BIT MD2_CHAR RC4_INDEX DES_UNROLL DES_RISC1 DES_INT:${ia64_asm}:dlfcn:hpux-shared:+Z:+DD32 -b:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::/hpux32",
+# Frank Geurts <frank.geurts@nl.abnamro.com> has patiently assisted with
+# with debugging of the following config.
+"hpux64-ia64-cc","cc:-Ae +DD64 +O3 +Olit=all -z -DB_ENDIAN -D_REENTRANT::::-ldl:SIXTY_FOUR_BIT_LONG MD2_CHAR RC4_INDEX DES_UNROLL DES_RISC1 DES_INT:${ia64_asm}:dlfcn:hpux-shared:+Z:+DD64 -b:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::/hpux64",
+# GCC builds...
+"hpux-ia64-gcc","gcc:-O3 -DB_ENDIAN -D_REENTRANT::::-ldl:SIXTY_FOUR_BIT MD2_CHAR RC4_INDEX DES_UNROLL DES_RISC1 DES_INT:${ia64_asm}:dlfcn:hpux-shared:-fpic:-shared:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::/hpux32",
+"hpux64-ia64-gcc","gcc:-mlp64 -O3 -DB_ENDIAN -D_REENTRANT::::-ldl:SIXTY_FOUR_BIT_LONG MD2_CHAR RC4_INDEX DES_UNROLL DES_RISC1 DES_INT:${ia64_asm}:dlfcn:hpux-shared:-fpic:-mlp64 -shared:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::/hpux64", 
+
+# Legacy HPUX 9.X configs...
+"hpux-cc",	"cc:-DB_ENDIAN -DBN_DIV2W -DMD32_XARRAY -Ae +ESlit +O2 -z::(unknown)::-Wl,+s -ldld:DES_PTR DES_UNROLL DES_RISC1:${no_asm}:dl:hpux-shared:+Z:-b:.sl.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"hpux-gcc",	"gcc:-DB_ENDIAN -DBN_DIV2W -O3::(unknown)::-Wl,+s -ldld:DES_PTR DES_UNROLL DES_RISC1:${no_asm}:dl:hpux-shared:-fPIC:-shared:.sl.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+
+#### HP MPE/iX http://jazz.external.hp.com/src/openssl/
+"MPE/iX-gcc",	"gcc:-D_ENDIAN -DBN_DIV2W -O3 -D_POSIX_SOURCE -D_SOCKET_SOURCE -I/SYSLOG/PUB::(unknown):MPE:-L/SYSLOG/PUB -lsyslog -lsocket -lcurses:BN_LLONG DES_PTR DES_UNROLL DES_RISC1:::",
+
+# DEC Alpha OSF/1/Tru64 targets.
+#
+#	"What's in a name? That which we call a rose
+#	 By any other word would smell as sweet."
+#
+# - William Shakespeare, "Romeo & Juliet", Act II, scene II.
+#
+# For gcc, the following gave a %50 speedup on a 164 over the 'DES_INT' version
+#
+"osf1-alpha-gcc", "gcc:-O3::(unknown):::SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_UNROLL DES_RISC1:${alpha_asm}:dlfcn:alpha-osf1-shared:::.so",
+"osf1-alpha-cc",  "cc:-std1 -tune host -O4 -readonly_strings::(unknown):::SIXTY_FOUR_BIT_LONG RC4_CHUNK:${alpha_asm}:dlfcn:alpha-osf1-shared:::.so",
+"tru64-alpha-cc", "cc:-std1 -tune host -fast -readonly_strings::-pthread:::SIXTY_FOUR_BIT_LONG RC4_CHUNK:${alpha_asm}:dlfcn:alpha-osf1-shared::-msym:.so",
+
+# Debian GNU/* (various architectures)
+"debian-alpha","gcc:${debian_cflags}::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_RISC1 DES_UNROLL:${alpha_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-alpha-ev4","gcc:${debian_cflags} -mcpu=ev4::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_RISC1 DES_UNROLL:${alpha_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-alpha-ev5","gcc:${debian_cflags} -mcpu=ev5::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_RISC1 DES_UNROLL:${alpha_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-arm64","gcc:-DL_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL BF_PTR:${aarch64_asm}:linux64:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-armel","gcc:-DL_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL BF_PTR:${armv4_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-armhf","gcc:-DL_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL BF_PTR:${armv4_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-amd64", "gcc:-m64 -DL_ENDIAN ${debian_cflags} -DMD32_REG_T=int::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_INT DES_UNROLL:${x86_64_asm}:elf:dlfcn:linux-shared:-fPIC:-m64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::",
+"debian-avr32", "gcc:-DB_ENDIAN ${debian_cflags} -fomit-frame-pointer::-D_REENTRANT::-ldl:BN_LLONG_BF_PTR:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-kfreebsd-amd64","gcc:-m64 -DL_ENDIAN ${debian_cflags} -DMD32_REG_T=int::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_INT DES_UNROLL:${x86_64_asm}:elf:dlfcn:linux-shared:-fPIC:-m64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-kfreebsd-i386","gcc:-DL_ENDIAN ${debian_cflags} -march=i486::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-hppa","gcc:-DB_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG MD2_CHAR RC4_INDEX:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-hurd-i386","gcc:-DL_ENDIAN -O3 -Wa,--noexecstack -g -mtune=i486 -Wall::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-ia64","gcc:${debian_cflags}::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_UNROLL DES_INT:${ia64_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-i386","gcc:-DL_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-i386-i486","gcc:-DL_ENDIAN ${debian_cflags} -march=i486::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-i386-i586","gcc:-DL_ENDIAN ${debian_cflags} -march=i586::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-i386-i686/cmov","gcc:-DL_ENDIAN ${debian_cflags} -march=i686::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-m68k","gcc:-DB_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG MD2_CHAR RC4_INDEX:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-mips",   "gcc:-DB_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG RC2_CHAR RC4_INDEX DES_INT DES_UNROLL DES_RISC2:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-mipsel",   "gcc:-DL_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG RC2_CHAR RC4_INDEX DES_INT DES_UNROLL DES_RISC2:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-mipsn32",   "gcc:-DB_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG RC2_CHAR RC4_INDEX DES_INT DES_UNROLL DES_RISC2:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-mipsn32el",   "gcc:-DL_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG RC2_CHAR RC4_INDEX DES_INT DES_UNROLL DES_RISC2:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-mips64",   "gcc:-DB_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG RC2_CHAR RC4_INDEX DES_INT DES_UNROLL DES_RISC2:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-mips64el",   "gcc:-DL_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG RC2_CHAR RC4_INDEX DES_INT DES_UNROLL DES_RISC2:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-netbsd-i386",	"gcc:-DL_ENDIAN ${debian_cflags} -m486::(unknown):::BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${no_asm}:dlfcn:bsd-gcc-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-netbsd-m68k",	"gcc:-DB_ENDIAN ${debian_cflags}::(unknown):::BN_LLONG MD2_CHAR RC4_INDEX DES_UNROLL:${no_asm}:dlfcn:bsd-gcc-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-netbsd-sparc",	"gcc:-DB_ENDIAN ${debian_cflags} -mv8::(unknown):::BN_LLONG MD2_CHAR RC4_INDEX DES_UNROLL:${no_asm}:dlfcn:bsd-gcc-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-nios2", "gcc:-DB_ENDIAN ${debian_cflags}::(unknown)::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL BF_PTR:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-openbsd-alpha","gcc:${debian_cflags}::(unknown):::SIXTY_FOUR_BIT_LONG DES_INT DES_PTR DES_RISC2:${no_asm}:dlfcn:bsd-gcc-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-openbsd-i386",  "gcc:-DL_ENDIAN ${debian_cflags} -m486::(unknown):::BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_asm}:a.out:dlfcn:bsd-gcc-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-openbsd-mips","gcc:-DL_ENDIAN ${debian_cflags}::(unknown)::BN_LLONG MD2_CHAR RC4_INDEX RC4_CHAR DES_UNROLL DES_RISC2 DES_PTR BF_PTR:${no_asm}:dlfcn:bsd-gcc-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-or1k", "gcc:-DB_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG DES_RISC1:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-powerpc","gcc:-DB_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_RISC1 DES_UNROLL:${ppc32_asm}:linux32:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-powerpcspe","gcc:-DB_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_RISC1 DES_UNROLL:${ppc32_asm}:linux32:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-ppc64","gcc:-m64 -DB_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHAR RC4_CHUNK DES_RISC1 DES_UNROLL:${ppc64_asm}:linux64:dlfcn:linux-shared:-fPIC:-m64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-ppc64el","gcc:-m64 -DL_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHAR RC4_CHUNK DES_RISC1 DES_UNROLL:${ppc64_asm}:linux64le:dlfcn:linux-shared:-fPIC:-m64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-s390","gcc:-DB_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)", 
+"debian-s390x","gcc:-DB_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL:${s390x_asm}:64:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-sh3",   "gcc:-DL_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-sh4",   "gcc:-DL_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-sh3eb",   "gcc:-DB_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-sh4eb",   "gcc:-DB_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-m32r","gcc:-DB_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-sparc","gcc:-DB_ENDIAN ${debian_cflags}::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR:${sparcv9_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-sparc-v8","gcc:-DB_ENDIAN ${debian_cflags} -mcpu=v8 -DBN_DIV2W::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR:${sparcv8_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-sparc-v9","gcc:-DB_ENDIAN ${debian_cflags} -mcpu=v9 -Wa,-Av8plus -DULTRASPARC -DBN_DIV2W::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR:${sparcv9_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-sparc64","gcc:-m64 -DB_ENDIAN ${debian_cflags} -DULTRASPARC -DBN_DIV2W::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_INT DES_PTR DES_RISC1 DES_UNROLL BF_PTR:${sparcv9_asm}:dlfcn:linux-shared:-fPIC:-m64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debian-x32","gcc:-mx32 -DL_ENDIAN ${debian_cflags} -DMD32_REG_T=int::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT RC4_CHUNK DES_INT DES_UNROLL:${x86_64_asm}:elf:dlfcn:linux-shared:-fPIC:-mx32:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::x32",
+
+####
+#### Variety of LINUX:-)
+####
+# *-generic* is endian-neutral target, but ./config is free to
+# throw in -D[BL]_ENDIAN, whichever appropriate...
+"linux-generic32","gcc:-O3 -fomit-frame-pointer -Wall::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL BF_PTR:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"linux-ppc",	"gcc:-DB_ENDIAN -O3 -Wall::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_RISC1 DES_UNROLL:${ppc32_asm}:linux32:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+
+#######################################################################
+# Note that -march is not among compiler options in below linux-armv4
+# target line. Not specifying one is intentional to give you choice to:
+#
+# a) rely on your compiler default by not specifying one;
+# b) specify your target platform explicitly for optimal performance,
+#    e.g. -march=armv6 or -march=armv7-a;
+# c) build "universal" binary that targets *range* of platforms by
+#    specifying minimum and maximum supported architecture;
+#
+# As for c) option. It actually makes no sense to specify maximum to be
+# less than ARMv7, because it's the least requirement for run-time
+# switch between platform-specific code paths. And without run-time
+# switch performance would be equivalent to one for minimum. Secondly,
+# there are some natural limitations that you'd have to accept and
+# respect. Most notably you can *not* build "universal" binary for
+# big-endian platform. This is because ARMv7 processor always picks
+# instructions in little-endian order. Another similar limitation is
+# that -mthumb can't "cross" -march=armv6t2 boundary, because that's
+# where it became Thumb-2. Well, this limitation is a bit artificial,
+# because it's not really impossible, but it's deemed too tricky to
+# support. And of course you have to be sure that your binutils are
+# actually up to the task of handling maximum target platform. With all
+# this in mind here is an example of how to configure "universal" build:
+#
+#       ./Configure linux-armv4 -march=armv6 -D__ARM_MAX_ARCH__=8
+#
+"linux-armv4",	"gcc: -O3 -Wall::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL BF_PTR:${armv4_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"linux-aarch64","gcc: -O3 -Wall::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL BF_PTR:${aarch64_asm}:linux64:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+# Configure script adds minimally required -march for assembly support,
+# if no -march was specified at command line. mips32 and mips64 below
+# refer to contemporary MIPS Architecture specifications, MIPS32 and
+# MIPS64, rather than to kernel bitness.
+"linux-mips32",	"gcc:-mabi=32 -O3 -Wall -DBN_DIV3W::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL BF_PTR:${mips32_asm}:o32:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"linux-mips64",   "gcc:-mabi=n32 -O3 -Wall -DBN_DIV3W::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL BF_PTR:${mips64_asm}:n32:dlfcn:linux-shared:-fPIC:-mabi=n32:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::32",
+"linux64-mips64",   "gcc:-mabi=64 -O3 -Wall -DBN_DIV3W::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL BF_PTR:${mips64_asm}:64:dlfcn:linux-shared:-fPIC:-mabi=64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::64",
+#### IA-32 targets...
+"linux-ia32-icc",	"icc:-DL_ENDIAN -O2::-D_REENTRANT::-ldl -no_cpprt:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:linux-shared:-KPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"linux-elf",	"gcc:-DL_ENDIAN -O3 -fomit-frame-pointer -Wall::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"linux-aout",	"gcc:-DL_ENDIAN -O3 -fomit-frame-pointer -march=i486 -Wall::(unknown):::BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_asm}:a.out",
+####
+"linux-generic64","gcc:-O3 -Wall::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL BF_PTR:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"linux-ppc64",	"gcc:-m64 -DB_ENDIAN -O3 -Wall::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHAR RC4_CHUNK DES_RISC1 DES_UNROLL:${ppc64_asm}:linux64:dlfcn:linux-shared:-fPIC:-m64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::64",
+"linux-ppc64le","gcc:-m64 -DL_ENDIAN -O3 -Wall::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHAR RC4_CHUNK DES_RISC1 DES_UNROLL:$ppc64_asm:linux64le:dlfcn:linux-shared:-fPIC:-m64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::",
+"linux-ia64",	"gcc:-DL_ENDIAN -DTERMIO -O3 -Wall::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_UNROLL DES_INT:${ia64_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"linux-ia64-icc","icc:-DL_ENDIAN -O2 -Wall::-D_REENTRANT::-ldl -no_cpprt:SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_RISC1 DES_INT:${ia64_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"linux-x86_64",	"gcc:-m64 -DL_ENDIAN -O3 -Wall::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_INT DES_UNROLL:${x86_64_asm}:elf:dlfcn:linux-shared:-fPIC:-m64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::64",
+"linux-x86_64-clang",	"clang: -m64 -DL_ENDIAN -O3 -Wall -Wextra $clang_disabled_warnings -Qunused-arguments::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_INT DES_UNROLL:${x86_64_asm}:elf:dlfcn:linux-shared:-fPIC:-m64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::64",
+"debug-linux-x86_64-clang",	"clang: -DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DCRYPTO_MDEBUG -m64 -DL_ENDIAN -g -Wall -Wextra $clang_disabled_warnings -Qunused-arguments::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_INT DES_UNROLL:${x86_64_asm}:elf:dlfcn:linux-shared:-fPIC:-m64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::64",
+"linux-x86_64-icc", "icc:-DL_ENDIAN -O2::-D_REENTRANT::-ldl -no_cpprt:SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_INT DES_UNROLL:${x86_64_asm}:elf:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::64",
+"linux-x32",	"gcc:-mx32 -DL_ENDIAN -O3 -Wall::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT RC4_CHUNK_LL DES_INT DES_UNROLL:${x86_64_asm}:elf:dlfcn:linux-shared:-fPIC:-mx32:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::x32",
+"linux64-s390x",	"gcc:-m64 -DB_ENDIAN -O3 -Wall::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL:${s390x_asm}:64:dlfcn:linux-shared:-fPIC:-m64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::64",
+#### So called "highgprs" target for z/Architecture CPUs
+# "Highgprs" is kernel feature first implemented in Linux 2.6.32, see
+# /proc/cpuinfo. The idea is to preserve most significant bits of
+# general purpose registers not only upon 32-bit process context
+# switch, but even on asynchronous signal delivery to such process.
+# This makes it possible to deploy 64-bit instructions even in legacy
+# application context and achieve better [or should we say adequate]
+# performance. The build is binary compatible with linux-generic32,
+# and the idea is to be able to install the resulting libcrypto.so
+# alongside generic one, e.g. as /lib/highgprs/libcrypto.so.x.y, for
+# ldconfig and run-time linker to autodiscover. Unfortunately it
+# doesn't work just yet, because of couple of bugs in glibc
+# sysdeps/s390/dl-procinfo.c affecting ldconfig and ld.so.1...
+"linux32-s390x",	"gcc:-m31 -Wa,-mzarch -DB_ENDIAN -O3 -Wall::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL:".eval{my $asm=$s390x_asm;$asm=~s/bn\-s390x\.o/bn_asm.o/;$asm}.":31:dlfcn:linux-shared:-fPIC:-m31:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::/highgprs",
+#### SPARC Linux setups
+# Ray Miller <ray.miller@computing-services.oxford.ac.uk> has patiently
+# assisted with debugging of following two configs.
+"linux-sparcv8","gcc:-mcpu=v8 -DB_ENDIAN -O3 -fomit-frame-pointer -Wall -DBN_DIV2W::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR:${sparcv8_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+# it's a real mess with -mcpu=ultrasparc option under Linux, but
+# -Wa,-Av8plus should do the trick no matter what.
+"linux-sparcv9","gcc:-m32 -mcpu=ultrasparc -DB_ENDIAN -O3 -fomit-frame-pointer -Wall -Wa,-Av8plus -DBN_DIV2W::-D_REENTRANT:ULTRASPARC:-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR:${sparcv9_asm}:dlfcn:linux-shared:-fPIC:-m32:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+# GCC 3.1 is a requirement
+"linux64-sparcv9","gcc:-m64 -mcpu=ultrasparc -DB_ENDIAN -O3 -fomit-frame-pointer -Wall::-D_REENTRANT:ULTRASPARC:-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_INT DES_PTR DES_RISC1 DES_UNROLL BF_PTR:${sparcv9_asm}:dlfcn:linux-shared:-fPIC:-m64:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):::64",
+#### Alpha Linux with GNU C and Compaq C setups
+# Special notes:
+# - linux-alpha+bwx-gcc is ment to be used from ./config only. If you
+#   ought to run './Configure linux-alpha+bwx-gcc' manually, do
+#   complement the command line with -mcpu=ev56, -mcpu=ev6 or whatever
+#   which is appropriate.
+# - If you use ccc keep in mind that -fast implies -arch host and the
+#   compiler is free to issue instructions which gonna make elder CPU
+#   choke. If you wish to build "blended" toolkit, add -arch generic
+#   *after* -fast and invoke './Configure linux-alpha-ccc' manually.
+#
+#					<appro@fy.chalmers.se>
+#
+"linux-alpha-gcc","gcc:-O3 -DL_ENDIAN::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_RISC1 DES_UNROLL:${alpha_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"linux-alpha+bwx-gcc","gcc:-O3 -DL_ENDIAN::-D_REENTRANT::-ldl:SIXTY_FOUR_BIT_LONG RC4_CHAR RC4_CHUNK DES_RISC1 DES_UNROLL:${alpha_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"linux-alpha-ccc","ccc:-fast -readonly_strings -DL_ENDIAN::-D_REENTRANT:::SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_INT DES_PTR DES_RISC1 DES_UNROLL:${alpha_asm}",
+"linux-alpha+bwx-ccc","ccc:-fast -readonly_strings -DL_ENDIAN::-D_REENTRANT:::SIXTY_FOUR_BIT_LONG RC4_CHAR RC4_CHUNK DES_INT DES_PTR DES_RISC1 DES_UNROLL:${alpha_asm}",
+
+# Android: linux-* but without pointers to headers and libs.
+"android","gcc:-mandroid -I\$(ANDROID_DEV)/include -B\$(ANDROID_DEV)/lib -O3 -fomit-frame-pointer -Wall::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL BF_PTR:${no_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"android-x86","gcc:-mandroid -I\$(ANDROID_DEV)/include -B\$(ANDROID_DEV)/lib -O3 -fomit-frame-pointer -Wall::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:".eval{my $asm=${x86_elf_asm};$asm=~s/:elf/:android/;$asm}.":dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"android-armv7","gcc:-march=armv7-a -mandroid -I\$(ANDROID_DEV)/include -B\$(ANDROID_DEV)/lib -O3 -fomit-frame-pointer -Wall::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL BF_PTR:${armv4_asm}:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"android-mips","gcc:-mandroid -I\$(ANDROID_DEV)/include -B\$(ANDROID_DEV)/lib -O3 -Wall::-D_REENTRANT::-ldl:BN_LLONG RC4_CHAR RC4_CHUNK DES_INT DES_UNROLL BF_PTR:${mips32_asm}:o32:dlfcn:linux-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+
+#### *BSD [do see comment about ${BSDthreads} above!]
+"BSD-generic32","gcc:-O3 -fomit-frame-pointer -Wall::${BSDthreads}:::BN_LLONG RC2_CHAR RC4_INDEX DES_INT DES_UNROLL:${no_asm}:dlfcn:bsd-gcc-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"BSD-x86",	"gcc:-DL_ENDIAN -O3 -fomit-frame-pointer -Wall::${BSDthreads}:::BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_asm}:a.out:dlfcn:bsd-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"BSD-x86-elf",	"gcc:-DL_ENDIAN -O3 -fomit-frame-pointer -Wall::${BSDthreads}:::BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:bsd-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"debug-BSD-x86-elf",	"gcc:-DL_ENDIAN -O3 -Wall -g::${BSDthreads}:::BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:bsd-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"BSD-sparcv8",	"gcc:-DB_ENDIAN -O3 -mcpu=v8 -Wall::${BSDthreads}:::BN_LLONG RC2_CHAR RC4_INDEX DES_INT DES_UNROLL:${sparcv8_asm}:dlfcn:bsd-gcc-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+
+"BSD-generic64","gcc:-O3 -Wall::${BSDthreads}:::SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_INT DES_UNROLL:${no_asm}:dlfcn:bsd-gcc-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+# -DMD32_REG_T=int doesn't actually belong in sparc64 target, it
+# simply *happens* to work around a compiler bug in gcc 3.3.3,
+# triggered by RIPEMD160 code.
+"BSD-sparc64",	"gcc:-DB_ENDIAN -O3 -DMD32_REG_T=int -Wall::${BSDthreads}:::BN_LLONG RC2_CHAR RC4_CHUNK DES_INT DES_PTR DES_RISC2 BF_PTR:${sparcv9_asm}:dlfcn:bsd-gcc-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"BSD-ia64",	"gcc:-DL_ENDIAN -O3 -Wall::${BSDthreads}:::SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_UNROLL DES_INT:${ia64_asm}:dlfcn:bsd-gcc-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"BSD-x86_64",	"cc:-DL_ENDIAN -O3 -Wall::${BSDthreads}:::SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_INT DES_UNROLL:${x86_64_asm}:elf:dlfcn:bsd-gcc-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+
+"bsdi-elf-gcc",     "gcc:-DPERL5 -DL_ENDIAN -fomit-frame-pointer -O3 -march=i486 -Wall::(unknown)::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:bsd-gcc-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+
+"nextstep",	"cc:-O -Wall:<libc.h>:(unknown):::BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:::",
+"nextstep3.3",	"cc:-O3 -Wall:<libc.h>:(unknown):::BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:::",
+
+# NCR MP-RAS UNIX ver 02.03.01
+"ncr-scde","cc:-O6 -Xa -Hoff=BEHAVED -686 -Hwide -Hiw::(unknown)::-lsocket -lnsl -lc89:${x86_gcc_des} ${x86_gcc_opts}:::",
+
+# QNX
+"qnx4",	"cc:-DL_ENDIAN -DTERMIO::(unknown):::${x86_gcc_des} ${x86_gcc_opts}:",
+"QNX6",       "gcc:::::-lsocket::${no_asm}:dlfcn:bsd-gcc-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"QNX6-i386",  "gcc:-DL_ENDIAN -O2 -Wall::::-lsocket:${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:bsd-gcc-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+
+# BeOS
+"beos-x86-r5",   "gcc:-DL_ENDIAN -DTERMIOS -O3 -fomit-frame-pointer -mcpu=pentium -Wall::-D_REENTRANT:BEOS:-lbe -lnet:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:beos:beos-shared:-fPIC -DPIC:-shared:.so",
+"beos-x86-bone", "gcc:-DL_ENDIAN -DTERMIOS -O3 -fomit-frame-pointer -mcpu=pentium -Wall::-D_REENTRANT:BEOS:-lbe -lbind -lsocket:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:beos:beos-shared:-fPIC:-shared:.so",
+
+#### SCO/Caldera targets.
+#
+# Originally we had like unixware-*, unixware-*-pentium, unixware-*-p6, etc.
+# Now we only have blended unixware-* as it's the only one used by ./config.
+# If you want to optimize for particular microarchitecture, bypass ./config
+# and './Configure unixware-7 -Kpentium_pro' or whatever appropriate.
+# Note that not all targets include assembler support. Mostly because of
+# lack of motivation to support out-of-date platforms with out-of-date
+# compiler drivers and assemblers. Tim Rice <tim@multitalents.net> has
+# patiently assisted to debug most of it.
+#
+# UnixWare 2.0x fails destest with -O.
+"unixware-2.0","cc:-DFILIO_H -DNO_STRINGS_H::-Kthread::-lsocket -lnsl -lresolv -lx:${x86_gcc_des} ${x86_gcc_opts}:::",
+"unixware-2.1","cc:-O -DFILIO_H::-Kthread::-lsocket -lnsl -lresolv -lx:${x86_gcc_des} ${x86_gcc_opts}:::",
+"unixware-7","cc:-O -DFILIO_H -Kalloca::-Kthread::-lsocket -lnsl:BN_LLONG MD2_CHAR RC4_INDEX ${x86_gcc_des}:${x86_elf_asm}-1:dlfcn:svr5-shared:-Kpic::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"unixware-7-gcc","gcc:-DL_ENDIAN -DFILIO_H -O3 -fomit-frame-pointer -march=pentium -Wall::-D_REENTRANT::-lsocket -lnsl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}-1:dlfcn:gnu-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+# SCO 5 - Ben Laurie <ben@algroup.co.uk> says the -O breaks the SCO cc.
+"sco5-cc",  "cc:-belf::(unknown)::-lsocket -lnsl:${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}-1:dlfcn:svr3-shared:-Kpic::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"sco5-gcc",  "gcc:-O3 -fomit-frame-pointer::(unknown)::-lsocket -lnsl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}-1:dlfcn:svr3-shared:-fPIC::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+
+#### IBM's AIX.
+"aix3-cc",  "cc:-O -DB_ENDIAN -qmaxmem=16384::(unknown):AIX::BN_LLONG RC4_CHAR:::",
+"aix-gcc",  "gcc:-O -DB_ENDIAN::-pthread:AIX::BN_LLONG RC4_CHAR:${ppc32_asm}:aix32:dlfcn:aix-shared::-shared -Wl,-G:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)::-X32",
+"aix64-gcc","gcc:-maix64 -O -DB_ENDIAN::-pthread:AIX::SIXTY_FOUR_BIT_LONG RC4_CHAR:${ppc64_asm}:aix64:dlfcn:aix-shared::-maix64 -shared -Wl,-G:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)::-X64",
+# Below targets assume AIX 5. Idea is to effectively disregard $OBJECT_MODE
+# at build time. $OBJECT_MODE is respected at ./config stage!
+"aix-cc",   "cc:-q32 -O -DB_ENDIAN -qmaxmem=16384 -qro -qroconst::-qthreaded -D_THREAD_SAFE:AIX::BN_LLONG RC4_CHAR:${ppc32_asm}:aix32:dlfcn:aix-shared::-q32 -G:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)::-X 32",
+"aix64-cc", "cc:-q64 -O -DB_ENDIAN -qmaxmem=16384 -qro -qroconst::-qthreaded -D_THREAD_SAFE:AIX::SIXTY_FOUR_BIT_LONG RC4_CHAR:${ppc64_asm}:aix64:dlfcn:aix-shared::-q64 -G:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)::-X 64",
+
+#
+# Cray T90 and similar (SDSC)
+# It's Big-endian, but the algorithms work properly when B_ENDIAN is NOT
+# defined.  The T90 ints and longs are 8 bytes long, and apparently the
+# B_ENDIAN code assumes 4 byte ints.  Fortunately, the non-B_ENDIAN and
+# non L_ENDIAN code aligns the bytes in each word correctly.
+#
+# The BIT_FIELD_LIMITS define is to avoid two fatal compiler errors:
+#'Taking the address of a bit field is not allowed. '
+#'An expression with bit field exists as the operand of "sizeof" '
+# (written by Wayne Schroeder <schroede@SDSC.EDU>)
+#
+# j90 is considered the base machine type for unicos machines,
+# so this configuration is now called "cray-j90" ...
+"cray-j90", "cc: -DBIT_FIELD_LIMITS -DTERMIOS::(unknown):CRAY::SIXTY_FOUR_BIT_LONG DES_INT:::",
+
+#
+# Cray T3E (Research Center Juelich, beckman@acl.lanl.gov)
+#
+# The BIT_FIELD_LIMITS define was written for the C90 (it seems).  I added
+# another use.  Basically, the problem is that the T3E uses some bit fields
+# for some st_addr stuff, and then sizeof and address-of fails
+# I could not use the ams/alpha.o option because the Cray assembler, 'cam'
+# did not like it.
+"cray-t3e", "cc: -DBIT_FIELD_LIMITS -DTERMIOS::(unknown):CRAY::SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_INT:::",
+
+# DGUX, 88100.
+"dgux-R3-gcc",	"gcc:-O3 -fomit-frame-pointer::(unknown):::RC4_INDEX DES_UNROLL:::",
+"dgux-R4-gcc",	"gcc:-O3 -fomit-frame-pointer::(unknown)::-lnsl -lsocket:RC4_INDEX DES_UNROLL:::",
+"dgux-R4-x86-gcc",	"gcc:-O3 -fomit-frame-pointer -DL_ENDIAN::(unknown)::-lnsl -lsocket:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}",
+
+# Sinix/ReliantUNIX RM400
+# NOTE: The CDS++ Compiler up to V2.0Bsomething has the IRIX_CC_BUG optimizer problem. Better use -g  */
+"ReliantUNIX","cc:-KPIC -g -DTERMIOS -DB_ENDIAN::-Kthread:SNI:-lsocket -lnsl -lc -L/usr/ucblib -lucb:BN_LLONG DES_PTR DES_RISC2 DES_UNROLL BF_PTR:${no_asm}:dlfcn:reliantunix-shared:::.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR)",
+"SINIX","cc:-O::(unknown):SNI:-lsocket -lnsl -lc -L/usr/ucblib -lucb:RC4_INDEX RC4_CHAR:::",
+"SINIX-N","/usr/ucb/cc:-O2 -misaligned::(unknown)::-lucb:RC4_INDEX RC4_CHAR:::",
+
+# SIEMENS BS2000/OSD: an EBCDIC-based mainframe
+"BS2000-OSD","c89:-O -XLLML -XLLMK -XL -DB_ENDIAN -DCHARSET_EBCDIC::(unknown)::-lsocket -lnsl:THIRTY_TWO_BIT DES_PTR DES_UNROLL MD2_CHAR RC4_INDEX RC4_CHAR BF_PTR:::",
+
+# OS/390 Unix an EBCDIC-based Unix system on IBM mainframe
+# You need to compile using the c89.sh wrapper in the tools directory, because the
+# IBM compiler does not like the -L switch after any object modules.
+#
+"OS390-Unix","c89.sh:-O -DB_ENDIAN -DCHARSET_EBCDIC -DNO_SYS_PARAM_H  -D_ALL_SOURCE::(unknown):::THIRTY_TWO_BIT DES_PTR DES_UNROLL MD2_CHAR RC4_INDEX RC4_CHAR BF_PTR:::",
+
+# Visual C targets
+#
+# Win64 targets, WIN64I denotes IA-64 and WIN64A - AMD64
+"VC-WIN64I","cl:-W3 -Gs0 -Gy -nologo -DOPENSSL_SYSNAME_WIN32 -DWIN32_LEAN_AND_MEAN -DL_ENDIAN -DUNICODE -D_UNICODE -D_CRT_SECURE_NO_DEPRECATE:::WIN64I::SIXTY_FOUR_BIT RC4_CHUNK_LL DES_INT EXPORT_VAR_AS_FN:ia64cpuid.o:ia64.o ia64-mont.o:::aes_core.o aes_cbc.o aes-ia64.o::md5-ia64.o:sha1-ia64.o sha256-ia64.o sha512-ia64.o:::::::ghash-ia64.o::ias:win32",
+"VC-WIN64A","cl:-W3 -Gs0 -Gy -nologo -DOPENSSL_SYSNAME_WIN32 -DWIN32_LEAN_AND_MEAN -DL_ENDIAN -DUNICODE -D_UNICODE -D_CRT_SECURE_NO_DEPRECATE:::WIN64A::SIXTY_FOUR_BIT RC4_CHUNK_LL DES_INT EXPORT_VAR_AS_FN:".eval{my $asm=$x86_64_asm;$asm=~s/x86_64-gcc\.o/bn_asm.o/;$asm}.":auto:win32",
+"debug-VC-WIN64I","cl:-W3 -Gs0 -Gy -Zi -nologo -DOPENSSL_SYSNAME_WIN32 -DWIN32_LEAN_AND_MEAN -DL_ENDIAN -DUNICODE -D_UNICODE -D_CRT_SECURE_NO_DEPRECATE:::WIN64I::SIXTY_FOUR_BIT RC4_CHUNK_LL DES_INT EXPORT_VAR_AS_FN:ia64cpuid.o:ia64.o:::aes_core.o aes_cbc.o aes-ia64.o::md5-ia64.o:sha1-ia64.o sha256-ia64.o sha512-ia64.o:::::::ghash-ia64.o::ias:win32",
+"debug-VC-WIN64A","cl:-W3 -Gs0 -Gy -Zi -nologo -DOPENSSL_SYSNAME_WIN32 -DWIN32_LEAN_AND_MEAN -DL_ENDIAN -DUNICODE -D_UNICODE -D_CRT_SECURE_NO_DEPRECATE:::WIN64A::SIXTY_FOUR_BIT RC4_CHUNK_LL DES_INT EXPORT_VAR_AS_FN:".eval{my $asm=$x86_64_asm;$asm=~s/x86_64-gcc\.o/bn_asm.o/;$asm}.":auto:win32",
+# x86 Win32 target defaults to ANSI API, if you want UNICODE, complement
+# 'perl Configure VC-WIN32' with '-DUNICODE -D_UNICODE'
+"VC-WIN32","cl:-W3 -Gs0 -GF -Gy -nologo -DOPENSSL_SYSNAME_WIN32 -DWIN32_LEAN_AND_MEAN -DL_ENDIAN -D_CRT_SECURE_NO_DEPRECATE:::WIN32::BN_LLONG RC4_INDEX EXPORT_VAR_AS_FN ${x86_gcc_opts}:${x86_asm}:win32n:win32",
+# Unified CE target
+"debug-VC-WIN32","cl:-W3 -Gs0 -GF -Gy -Zi -nologo -DOPENSSL_SYSNAME_WIN32 -DWIN32_LEAN_AND_MEAN -DL_ENDIAN -D_CRT_SECURE_NO_DEPRECATE:::WIN32::BN_LLONG RC4_INDEX EXPORT_VAR_AS_FN ${x86_gcc_opts}:${x86_asm}:win32n:win32",
+"VC-CE","cl::::WINCE::BN_LLONG RC4_INDEX EXPORT_VAR_AS_FN ${x86_gcc_opts}:${no_asm}:win32",
+
+# Borland C++ 4.5
+"BC-32","bcc32::::WIN32::BN_LLONG DES_PTR RC4_INDEX EXPORT_VAR_AS_FN:${no_asm}:win32",
+
+# MinGW
+"mingw", "gcc:-mno-cygwin -DL_ENDIAN -DWIN32_LEAN_AND_MEAN -fomit-frame-pointer -O3 -march=i486 -Wall::-D_MT:MINGW32:-lws2_32 -lgdi32 -lcrypt32:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts} EXPORT_VAR_AS_FN:${x86_asm}:coff:win32:cygwin-shared:-D_WINDLL -DOPENSSL_USE_APPLINK:-mno-cygwin:.dll.a",
+# As for OPENSSL_USE_APPLINK. Applink makes it possible to use .dll
+# compiled with one compiler with application compiled with another
+# compiler. It's possible to engage Applink support in mingw64 build,
+# but it's not done, because till mingw64 supports structured exception
+# handling, one can't seriously consider its binaries for using with
+# non-mingw64 run-time environment. And as mingw64 is always consistent
+# with itself, Applink is never engaged and can as well be omitted.
+"mingw64", "gcc:-mno-cygwin -DL_ENDIAN -O3 -Wall -DWIN32_LEAN_AND_MEAN -DUNICODE -D_UNICODE::-D_MT:MINGW64:-lws2_32 -lgdi32 -lcrypt32:SIXTY_FOUR_BIT RC4_CHUNK_LL DES_INT EXPORT_VAR_AS_FN:${x86_64_asm}:mingw64:win32:cygwin-shared:-D_WINDLL:-mno-cygwin:.dll.a",
+
+# UWIN 
+"UWIN", "cc:-DTERMIOS -DL_ENDIAN -O -Wall:::UWIN::BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${no_asm}:win32",
+
+# Cygwin
+"Cygwin", "gcc:-DTERMIOS -DL_ENDIAN -fomit-frame-pointer -O3 -march=i486 -Wall:::CYGWIN::BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_asm}:coff:dlfcn:cygwin-shared:-D_WINDLL:-shared:.dll.a",
+"Cygwin-x86_64", "gcc:-DTERMIOS -DL_ENDIAN -O3 -Wall:::CYGWIN::SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_INT DES_UNROLL:${x86_64_asm}:mingw64:dlfcn:cygwin-shared:-D_WINDLL:-shared:.dll.a",
+
+# NetWare from David Ward (dsward@novell.com)
+# requires either MetroWerks NLM development tools, or gcc / nlmconv
+# NetWare defaults socket bio to WinSock sockets. However,
+# the builds can be configured to use BSD sockets instead.
+# netware-clib => legacy CLib c-runtime support
+"netware-clib", "mwccnlm::::::${x86_gcc_opts}::",
+"netware-clib-bsdsock", "mwccnlm::::::${x86_gcc_opts}::",
+"netware-clib-gcc", "i586-netware-gcc:-nostdinc -I/ndk/nwsdk/include/nlm -I/ndk/ws295sdk/include -DL_ENDIAN -DNETWARE_CLIB -DOPENSSL_SYSNAME_NETWARE -O2 -Wall:::::${x86_gcc_opts}::",
+"netware-clib-bsdsock-gcc", "i586-netware-gcc:-nostdinc -I/ndk/nwsdk/include/nlm -DNETWARE_BSDSOCK -DNETDB_USE_INTERNET -DL_ENDIAN -DNETWARE_CLIB -DOPENSSL_SYSNAME_NETWARE -O2 -Wall:::::${x86_gcc_opts}::",
+# netware-libc => LibC/NKS support
+"netware-libc", "mwccnlm::::::BN_LLONG ${x86_gcc_opts}::",
+"netware-libc-bsdsock", "mwccnlm::::::BN_LLONG ${x86_gcc_opts}::",
+"netware-libc-gcc", "i586-netware-gcc:-nostdinc -I/ndk/libc/include -I/ndk/libc/include/winsock -DL_ENDIAN -DNETWARE_LIBC -DOPENSSL_SYSNAME_NETWARE -DTERMIO -O2 -Wall:::::BN_LLONG ${x86_gcc_opts}::",
+"netware-libc-bsdsock-gcc", "i586-netware-gcc:-nostdinc -I/ndk/libc/include -DNETWARE_BSDSOCK -DL_ENDIAN -DNETWARE_LIBC -DOPENSSL_SYSNAME_NETWARE -DTERMIO -O2 -Wall:::::BN_LLONG ${x86_gcc_opts}::",
+
+# DJGPP
+"DJGPP", "gcc:-I/dev/env/WATT_ROOT/inc -DTERMIO -DL_ENDIAN -fomit-frame-pointer -O2 -Wall:::MSDOS:-L/dev/env/WATT_ROOT/lib -lwatt:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_asm}:a.out:",
+
+# Ultrix from Bernhard Simon <simon@zid.tuwien.ac.at>
+"ultrix-cc","cc:-std1 -O -Olimit 2500 -DL_ENDIAN::(unknown):::::::",
+"ultrix-gcc","gcc:-O3 -DL_ENDIAN::(unknown):::BN_LLONG::::",
+# K&R C is no longer supported; you need gcc on old Ultrix installations
+##"ultrix","cc:-O2 -DNOPROTO -DNOCONST -DL_ENDIAN::(unknown):::::::",
+
+##### MacOS X (a.k.a. Rhapsody or Darwin) setup
+"rhapsody-ppc-cc","cc:-O3 -DB_ENDIAN::(unknown):MACOSX_RHAPSODY::BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR:${no_asm}::",
+"darwin-ppc-cc","cc:-arch ppc -O3 -DB_ENDIAN -Wa,-force_cpusubtype_ALL::-D_REENTRANT:MACOSX:-Wl,-search_paths_first%:BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR:${ppc32_asm}:osx32:dlfcn:darwin-shared:-fPIC -fno-common:-arch ppc -dynamiclib:.\$(SHLIB_MAJOR).\$(SHLIB_MINOR).dylib",
+"darwin64-ppc-cc","cc:-arch ppc64 -O3 -DB_ENDIAN::-D_REENTRANT:MACOSX:-Wl,-search_paths_first%:SIXTY_FOUR_BIT_LONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR:${ppc64_asm}:osx64:dlfcn:darwin-shared:-fPIC -fno-common:-arch ppc64 -dynamiclib:.\$(SHLIB_MAJOR).\$(SHLIB_MINOR).dylib",
+"darwin-i386-cc","cc:-arch i386 -O3 -fomit-frame-pointer -DL_ENDIAN::-D_REENTRANT:MACOSX:-Wl,-search_paths_first%:BN_LLONG RC4_INT RC4_CHUNK DES_UNROLL BF_PTR:".eval{my $asm=$x86_asm;$asm=~s/cast\-586\.o//;$asm}.":macosx:dlfcn:darwin-shared:-fPIC -fno-common:-arch i386 -dynamiclib:.\$(SHLIB_MAJOR).\$(SHLIB_MINOR).dylib",
+"debug-darwin-i386-cc","cc:-arch i386 -g3 -DL_ENDIAN::-D_REENTRANT:MACOSX:-Wl,-search_paths_first%:BN_LLONG RC4_INT RC4_CHUNK DES_UNROLL BF_PTR:${x86_asm}:macosx:dlfcn:darwin-shared:-fPIC -fno-common:-arch i386 -dynamiclib:.\$(SHLIB_MAJOR).\$(SHLIB_MINOR).dylib",
+"darwin64-x86_64-cc","cc:-arch x86_64 -O3 -DL_ENDIAN -Wall::-D_REENTRANT:MACOSX:-Wl,-search_paths_first%:SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_INT DES_UNROLL:".eval{my $asm=$x86_64_asm;$asm=~s/rc4\-[^:]+//;$asm}.":macosx:dlfcn:darwin-shared:-fPIC -fno-common:-arch x86_64 -dynamiclib:.\$(SHLIB_MAJOR).\$(SHLIB_MINOR).dylib",
+"debug-darwin64-x86_64-cc","cc:-arch x86_64 -ggdb -g2 -O0 -DL_ENDIAN -Wall::-D_REENTRANT:MACOSX:-Wl,-search_paths_first%:SIXTY_FOUR_BIT_LONG RC4_CHUNK DES_INT DES_UNROLL:".eval{my $asm=$x86_64_asm;$asm=~s/rc4\-[^:]+//;$asm}.":macosx:dlfcn:darwin-shared:-fPIC -fno-common:-arch x86_64 -dynamiclib:.\$(SHLIB_MAJOR).\$(SHLIB_MINOR).dylib",
+"debug-darwin-ppc-cc","cc:-DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DCRYPTO_MDEBUG -DB_ENDIAN -g -Wall -O::-D_REENTRANT:MACOSX::BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR:${ppc32_asm}:osx32:dlfcn:darwin-shared:-fPIC:-dynamiclib:.\$(SHLIB_MAJOR).\$(SHLIB_MINOR).dylib",
+# iPhoneOS/iOS
+"iphoneos-cross","llvm-gcc:-O3 -isysroot \$(CROSS_TOP)/SDKs/\$(CROSS_SDK) -fomit-frame-pointer -fno-common::-D_REENTRANT:iOS:-Wl,-search_paths_first%:BN_LLONG RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR:${no_asm}:dlfcn:darwin-shared:-fPIC -fno-common:-dynamiclib:.\$(SHLIB_MAJOR).\$(SHLIB_MINOR).dylib",
+
+##### A/UX
+"aux3-gcc","gcc:-O2 -DTERMIO::(unknown):AUX:-lbsd:RC4_CHAR RC4_CHUNK DES_UNROLL BF_PTR:::",
+
+##### Sony NEWS-OS 4.x
+"newsos4-gcc","gcc:-O -DB_ENDIAN::(unknown):NEWS4:-lmld -liberty:BN_LLONG RC4_CHAR RC4_CHUNK DES_PTR DES_RISC1 DES_UNROLL BF_PTR::::",
+
+##### GNU Hurd
+"hurd-x86",  "gcc:-DL_ENDIAN -O3 -fomit-frame-pointer -march=i486 -Wall::-D_REENTRANT::-ldl:BN_LLONG ${x86_gcc_des} ${x86_gcc_opts}:${x86_elf_asm}:dlfcn:linux-shared:-fPIC",
+
+##### OS/2 EMX
+"OS2-EMX", "gcc::::::::",
+
+##### VxWorks for various targets
+"vxworks-ppc60x","ccppc:-D_REENTRANT -mrtp -mhard-float -mstrict-align -fno-implicit-fp -DPPC32_fp60x -O2 -fstrength-reduce -fno-builtin -fno-strict-aliasing -Wall -DCPU=PPC32 -DTOOL_FAMILY=gnu -DTOOL=gnu -I\$(WIND_BASE)/target/usr/h -I\$(WIND_BASE)/target/usr/h/wrn/coreip:::VXWORKS:-Wl,--defsym,__wrs_rtp_base=0xe0000000 -L \$(WIND_BASE)/target/usr/lib/ppc/PPC32/common:::::",
+"vxworks-ppcgen","ccppc:-D_REENTRANT -mrtp -msoft-float -mstrict-align -O1 -fno-builtin -fno-strict-aliasing -Wall -DCPU=PPC32 -DTOOL_FAMILY=gnu -DTOOL=gnu -I\$(WIND_BASE)/target/usr/h -I\$(WIND_BASE)/target/usr/h/wrn/coreip:::VXWORKS:-Wl,--defsym,__wrs_rtp_base=0xe0000000 -L \$(WIND_BASE)/target/usr/lib/ppc/PPC32/sfcommon:::::",
+"vxworks-ppc405","ccppc:-g -msoft-float -mlongcall -DCPU=PPC405 -I\$(WIND_BASE)/target/h:::VXWORKS:-r:::::",
+"vxworks-ppc750","ccppc:-ansi -nostdinc -DPPC750 -D_REENTRANT -fvolatile -fno-builtin -fno-for-scope -fsigned-char -Wall -msoft-float -mlongcall -DCPU=PPC604 -I\$(WIND_BASE)/target/h \$(DEBUG_FLAG):::VXWORKS:-r:::::",
+"vxworks-ppc750-debug","ccppc:-ansi -nostdinc -DPPC750 -D_REENTRANT -fvolatile -fno-builtin -fno-for-scope -fsigned-char -Wall -msoft-float -mlongcall -DCPU=PPC604 -I\$(WIND_BASE)/target/h -DBN_DEBUG -DREF_CHECK -DCONF_DEBUG -DBN_CTX_DEBUG -DCRYPTO_MDEBUG -DPEDANTIC -DDEBUG_SAFESTACK -DDEBUG -g:::VXWORKS:-r:::::",
+"vxworks-ppc860","ccppc:-nostdinc -msoft-float -DCPU=PPC860 -DNO_STRINGS_H -I\$(WIND_BASE)/target/h:::VXWORKS:-r:::::",
+"vxworks-simlinux","ccpentium:-B\$(WIND_BASE)/host/\$(WIND_HOST_TYPE)/lib/gcc-lib/ -D_VSB_CONFIG_FILE=\"\$(WIND_BASE)/target/lib/h/config/vsbConfig.h\" -DL_ENDIAN -DCPU=SIMLINUX -DTOOL_FAMILY=gnu -DTOOL=gnu -fno-builtin -fno-defer-pop -DNO_STRINGS_H -I\$(WIND_BASE)/target/h -I\$(WIND_BASE)/target/h/wrn/coreip -DOPENSSL_NO_HW_PADLOCK:::VXWORKS:-r::${no_asm}::::::ranlibpentium:",
+"vxworks-mips","ccmips:-mrtp -mips2 -O -G 0 -B\$(WIND_BASE)/host/\$(WIND_HOST_TYPE)/lib/gcc-lib/ -D_VSB_CONFIG_FILE=\"\$(WIND_BASE)/target/lib/h/config/vsbConfig.h\" -DCPU=MIPS32 -msoft-float -mno-branch-likely -DTOOL_FAMILY=gnu -DTOOL=gnu -fno-builtin -fno-defer-pop -DNO_STRINGS_H -I\$(WIND_BASE)/target/usr/h -I\$(WIND_BASE)/target/h/wrn/coreip::-D_REENTRANT:VXWORKS:-Wl,--defsym,__wrs_rtp_base=0xe0000000 -L \$(WIND_BASE)/target/usr/lib/mips/MIPSI32/sfcommon::${mips32_asm}:o32::::::ranlibmips:",
+
+##### Compaq Non-Stop Kernel (Tandem)
+"tandem-c89","c89:-Ww -D__TANDEM -D_XOPEN_SOURCE -D_XOPEN_SOURCE_EXTENDED=1 -D_TANDEM_SOURCE -DB_ENDIAN::(unknown):::THIRTY_TWO_BIT:::",
+
+# uClinux
+"uClinux-dist","$ENV{'CC'}:\$(CFLAGS)::-D_REENTRANT::\$(LDFLAGS) \$(LDLIBS):BN_LLONG:${no_asm}:$ENV{'LIBSSL_dlfcn'}:linux-shared:-fPIC:-shared:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):$ENV{'RANLIB'}::",
+"uClinux-dist64","$ENV{'CC'}:\$(CFLAGS)::-D_REENTRANT::\$(LDFLAGS) \$(LDLIBS):SIXTY_FOUR_BIT_LONG:${no_asm}:$ENV{'LIBSSL_dlfcn'}:linux-shared:-fPIC:-shared:.so.\$(SHLIB_MAJOR).\$(SHLIB_MINOR):$ENV{'RANLIB'}::",
+
+);
+
+my @MK1MF_Builds=qw(VC-WIN64I VC-WIN64A
+		    debug-VC-WIN64I debug-VC-WIN64A
+		    VC-NT VC-CE VC-WIN32 debug-VC-WIN32
+		    BC-32 
+		    netware-clib netware-clib-bsdsock
+		    netware-libc netware-libc-bsdsock);
+
+my $idx = 0;
+my $idx_cc = $idx++;
+my $idx_cflags = $idx++;
+my $idx_unistd = $idx++;
+my $idx_thread_cflag = $idx++;
+my $idx_sys_id = $idx++;
+my $idx_lflags = $idx++;
+my $idx_bn_ops = $idx++;
+my $idx_cpuid_obj = $idx++;
+my $idx_bn_obj = $idx++;
+my $idx_ec_obj = $idx++;
+my $idx_des_obj = $idx++;
+my $idx_aes_obj = $idx++;
+my $idx_bf_obj = $idx++;
+my $idx_md5_obj = $idx++;
+my $idx_sha1_obj = $idx++;
+my $idx_cast_obj = $idx++;
+my $idx_rc4_obj = $idx++;
+my $idx_rmd160_obj = $idx++;
+my $idx_rc5_obj = $idx++;
+my $idx_wp_obj = $idx++;
+my $idx_cmll_obj = $idx++;
+my $idx_modes_obj = $idx++;
+my $idx_engines_obj = $idx++;
+my $idx_perlasm_scheme = $idx++;
+my $idx_dso_scheme = $idx++;
+my $idx_shared_target = $idx++;
+my $idx_shared_cflag = $idx++;
+my $idx_shared_ldflag = $idx++;
+my $idx_shared_extension = $idx++;
+my $idx_ranlib = $idx++;
+my $idx_arflags = $idx++;
+my $idx_multilib = $idx++;
+
+my $prefix="";
+my $libdir="";
+my $openssldir="";
+my $exe_ext="";
+my $install_prefix= "$ENV{'INSTALL_PREFIX'}";
+my $cross_compile_prefix="";
+my $fipsdir="/usr/local/ssl/fips-2.0";
+my $fipslibdir="";
+my $baseaddr="0xFB00000";
+my $no_threads=0;
+my $threads=0;
+my $no_shared=0; # but "no-shared" is default
+my $zlib=1;      # but "no-zlib" is default
+my $no_krb5=0;   # but "no-krb5" is implied unless "--with-krb5-..." is used
+my $no_rfc3779=1; # but "no-rfc3779" is default
+my $no_asm=0;
+my $no_dso=0;
+my $no_gmp=0;
+my @skip=();
+my $Makefile="Makefile";
+my $des_locl="crypto/des/des_locl.h";
+my $des	="crypto/des/des.h";
+my $bn	="crypto/bn/bn.h";
+my $md2	="crypto/md2/md2.h";
+my $rc4	="crypto/rc4/rc4.h";
+my $rc4_locl="crypto/rc4/rc4_locl.h";
+my $idea	="crypto/idea/idea.h";
+my $rc2	="crypto/rc2/rc2.h";
+my $bf	="crypto/bf/bf_locl.h";
+my $bn_asm	="bn_asm.o";
+my $des_enc="des_enc.o fcrypt_b.o";
+my $aes_enc="aes_core.o aes_cbc.o";
+my $bf_enc	="bf_enc.o";
+my $cast_enc="c_enc.o";
+my $rc4_enc="rc4_enc.o rc4_skey.o";
+my $rc5_enc="rc5_enc.o";
+my $md5_obj="";
+my $sha1_obj="";
+my $rmd160_obj="";
+my $cmll_enc="camellia.o cmll_misc.o cmll_cbc.o";
+my $processor="";
+my $default_ranlib;
+my $perl;
+my $fips=0;
+
+if (exists $ENV{FIPSDIR})
+	{
+	$fipsdir = $ENV{FIPSDIR};
+	$fipsdir =~ s/\/$//;
+	}
+
+# All of the following is disabled by default (RC5 was enabled before 0.9.8):
+
+my %disabled = ( # "what"         => "comment" [or special keyword "experimental"]
+		 "ec_nistp_64_gcc_128" => "default",
+		 "gmp"		  => "default",
+		 "jpake"          => "experimental",
+		 "libunbound"     => "experimental",
+		 "md2"            => "default",
+		 "rc5"            => "default",
+		 "rfc3779"	  => "default",
+		 "sctp"           => "default",
+		 "shared"         => "default",
+		 "ssl-trace"	  => "default",
+		 "ssl2"           => "default",
+		 "store"	  => "experimental",
+		 "unit-test"	  => "default",
+		 "weak-ssl-ciphers" => "default",
+		 "zlib"           => "default",
+		 "zlib-dynamic"   => "default"
+	       );
+my @experimental = ();
+
+# This is what $depflags will look like with the above defaults
+# (we need this to see if we should advise the user to run "make depend"):
+my $default_depflags = " -DOPENSSL_NO_EC_NISTP_64_GCC_128 -DOPENSSL_NO_GMP -DOPENSSL_NO_JPAKE -DOPENSSL_NO_LIBUNBOUND -DOPENSSL_NO_MD2 -DOPENSSL_NO_RC5 -DOPENSSL_NO_RFC3779 -DOPENSSL_NO_SCTP -DOPENSSL_NO_SSL_TRACE -DOPENSSL_NO_SSL2 -DOPENSSL_NO_STORE -DOPENSSL_NO_UNIT_TEST -DOPENSSL_NO_WEAK_SSL_CIPHERS";
+
+# Explicit "no-..." options will be collected in %disabled along with the defaults.
+# To remove something from %disabled, use "enable-foo" (unless it's experimental).
+# For symmetry, "disable-foo" is a synonym for "no-foo".
+
+# For features called "experimental" here, a more explicit "experimental-foo" is needed to enable.
+# We will collect such requests in @experimental.
+# To avoid accidental use of experimental features, applications will have to use -DOPENSSL_EXPERIMENTAL_FOO.
+
+
+my $no_sse2=0;
+
+&usage if ($#ARGV < 0);
+
+my $flags;
+my $depflags;
+my $openssl_experimental_defines;
+my $openssl_algorithm_defines;
+my $openssl_thread_defines;
+my $openssl_sys_defines="";
+my $openssl_other_defines;
+my $libs;
+my $libkrb5="";
+my $target;
+my $options;
+my $symlink;
+my $make_depend=0;
+my %withargs=();
+
+my @argvcopy=@ARGV;
+my $argvstring="";
+my $argv_unprocessed=1;
+
+while($argv_unprocessed)
+	{
+	$flags="";
+	$depflags="";
+	$openssl_experimental_defines="";
+	$openssl_algorithm_defines="";
+	$openssl_thread_defines="";
+	$openssl_sys_defines="";
+	$openssl_other_defines="";
+	$libs="";
+	$target="";
+	$options="";
+	$symlink=1;
+
+	$argv_unprocessed=0;
+	$argvstring=join(' ',@argvcopy);
+
+PROCESS_ARGS:
+	foreach (@argvcopy)
+		{
+		s /^-no-/no-/; # some people just can't read the instructions
+
+		# rewrite some options in "enable-..." form
+		s /^-?-?shared$/enable-shared/;
+		s /^sctp$/enable-sctp/;
+		s /^threads$/enable-threads/;
+		s /^zlib$/enable-zlib/;
+		s /^zlib-dynamic$/enable-zlib-dynamic/;
+
+		if (/^no-(.+)$/ || /^disable-(.+)$/)
+			{
+			if (!($disabled{$1} eq "experimental"))
+				{
+				if ($1 eq "ssl")
+					{
+					$disabled{"ssl2"} = "option(ssl)";
+					$disabled{"ssl3"} = "option(ssl)";
+					}
+				elsif ($1 eq "tls")
+					{
+					$disabled{"tls1"} = "option(tls)"
+					}
+				elsif ($1 eq "ssl3-method")
+					{
+					$disabled{"ssl3-method"} = "option(ssl)";
+					$disabled{"ssl3"} = "option(ssl)";
+					}
+				else
+					{
+					$disabled{$1} = "option";
+					}
+				}			
+			}
+		elsif (/^enable-(.+)$/ || /^experimental-(.+)$/)
+			{
+			my $algo = $1;
+			if ($disabled{$algo} eq "experimental")
+				{
+				die "You are requesting an experimental feature; please say 'experimental-$algo' if you are sure\n"
+					unless (/^experimental-/);
+				push @experimental, $algo;
+				}
+			delete $disabled{$algo};
+
+			$threads = 1 if ($algo eq "threads");
+			}
+		elsif (/^--test-sanity$/)
+			{
+			exit(&test_sanity());
+			}
+		elsif (/^--strict-warnings/)
+			{
+			$strict_warnings = 1;
+			}
+		elsif (/^reconfigure/ || /^reconf/)
+			{
+			if (open(IN,"<$Makefile"))
+				{
+				while (<IN>)
+					{
+					chomp;
+					if (/^CONFIGURE_ARGS=(.*)/)
+						{
+						$argvstring=$1;
+						@argvcopy=split(' ',$argvstring);
+						die "Incorrect data to reconfigure, please do a normal configuration\n"
+							if (grep(/^reconf/,@argvcopy));
+						print "Reconfiguring with: $argvstring\n";
+						$argv_unprocessed=1;
+						close(IN);
+						last PROCESS_ARGS;
+						}
+					}
+				close(IN);
+				}
+			die "Insufficient data to reconfigure, please do a normal configuration\n";
+			}
+		elsif (/^386$/)
+			{ $processor=386; }
+		elsif (/^fips$/)
+			{
+			$fips=1;
+			}
+		elsif (/^rsaref$/)
+			{
+			# No RSAref support any more since it's not needed.
+			# The check for the option is there so scripts aren't
+			# broken
+			}
+		elsif (/^[-+]/)
+			{
+			if (/^--prefix=(.*)$/)
+				{
+				$prefix=$1;
+				}
+			elsif (/^--libdir=(.*)$/)
+				{
+				$libdir=$1;
+				}
+			elsif (/^--openssldir=(.*)$/)
+				{
+				$openssldir=$1;
+				}
+			elsif (/^--install.prefix=(.*)$/)
+				{
+				$install_prefix=$1;
+				}
+			elsif (/^--with-krb5-(dir|lib|include|flavor)=(.*)$/)
+				{
+				$withargs{"krb5-".$1}=$2;
+				}
+			elsif (/^--with-zlib-lib=(.*)$/)
+				{
+				$withargs{"zlib-lib"}=$1;
+				}
+			elsif (/^--with-zlib-include=(.*)$/)
+				{
+				$withargs{"zlib-include"}="-I$1";
+				}
+			elsif (/^--with-fipsdir=(.*)$/)
+				{
+				$fipsdir="$1";
+				}
+			elsif (/^--with-fipslibdir=(.*)$/)
+				{
+				$fipslibdir="$1";
+				}
+			elsif (/^--with-baseaddr=(.*)$/)
+				{
+				$baseaddr="$1";
+				}
+			elsif (/^--cross-compile-prefix=(.*)$/)
+				{
+				$cross_compile_prefix=$1;
+				}
+			elsif (/^-[lL](.*)$/ or /^-Wl,/)
+				{
+				$libs.=$_." ";
+				}
+			else	# common if (/^[-+]/), just pass down...
+				{
+				$_ =~ s/%([0-9a-f]{1,2})/chr(hex($1))/gei;
+				$flags.=$_." ";
+				}
+			}
+		elsif ($_ =~ /^([^:]+):(.+)$/)
+			{
+			eval "\$table{\$1} = \"$2\""; # allow $xxx constructs in the string
+			$target=$1;
+			}
+		else
+			{
+			die "target already defined - $target (offending arg: $_)\n" if ($target ne "");
+			$target=$_;
+			}
+
+		unless ($_ eq $target || /^no-/ || /^disable-/)
+			{
+			# "no-..." follows later after implied disactivations
+			# have been derived.  (Don't take this too seroiusly,
+			# we really only write OPTIONS to the Makefile out of
+			# nostalgia.)
+
+			if ($options eq "")
+				{ $options = $_; }
+			else
+				{ $options .= " ".$_; }
+			}
+		}
+	}
+
+
+
+if ($processor eq "386")
+	{
+	$disabled{"sse2"} = "forced";
+	}
+
+if (!defined($withargs{"krb5-flavor"}) || $withargs{"krb5-flavor"} eq "")
+	{
+	$disabled{"krb5"} = "krb5-flavor not specified";
+	}
+
+if (!defined($disabled{"zlib-dynamic"}))
+	{
+	# "zlib-dynamic" was specifically enabled, so enable "zlib"
+	delete $disabled{"zlib"};
+	}
+
+if (defined($disabled{"rijndael"}))
+	{
+	$disabled{"aes"} = "forced";
+	}
+if (defined($disabled{"des"}))
+	{
+	$disabled{"mdc2"} = "forced";
+	}
+if (defined($disabled{"ec"}))
+	{
+	$disabled{"ecdsa"} = "forced";
+	$disabled{"ecdh"} = "forced";
+	}
+
+# SSL 2.0 requires MD5 and RSA
+if (defined($disabled{"md5"}) || defined($disabled{"rsa"}))
+	{
+	$disabled{"ssl2"} = "forced";
+	}
+
+if ($fips && $fipslibdir eq "")
+	{
+	$fipslibdir = $fipsdir . "/lib/";
+	}
+
+# RSAX ENGINE sets default non-FIPS RSA method.
+if ($fips)
+	{
+	$disabled{"rsax"} = "forced";
+	}
+
+# SSL 3.0 and TLS requires MD5 and SHA and either RSA or DSA+DH
+if (defined($disabled{"md5"}) || defined($disabled{"sha"})
+    || (defined($disabled{"rsa"})
+        && (defined($disabled{"dsa"}) || defined($disabled{"dh"}))))
+	{
+	$disabled{"ssl3"} = "forced";
+	$disabled{"tls1"} = "forced";
+	}
+
+if (defined($disabled{"ec"}) || defined($disabled{"dsa"})
+    || defined($disabled{"dh"}))
+	{
+	$disabled{"gost"} = "forced";
+	}
+
+# SRP and HEARTBEATS require TLSEXT
+if (defined($disabled{"tlsext"}))
+	{
+	$disabled{"srp"} = "forced";
+	$disabled{"heartbeats"} = "forced";
+	}
+
+if ($target eq "TABLE") {
+	foreach $target (sort keys %table) {
+		print_table_entry($target);
+	}
+	exit 0;
+}
+
+if ($target eq "LIST") {
+	foreach (sort keys %table) {
+		print;
+		print "\n";
+	}
+	exit 0;
+}
+
+if ($target =~ m/^CygWin32(-.*)$/) {
+	$target = "Cygwin".$1;
+}
+
+print "Configuring for $target\n";
+
+&usage if (!defined($table{$target}));
+
+
+foreach (sort (keys %disabled))
+	{
+	$options .= " no-$_";
+
+	printf "    no-%-12s %-10s", $_, "[$disabled{$_}]";
+
+	if (/^dso$/)
+		{ $no_dso = 1; }
+	elsif (/^threads$/)
+		{ $no_threads = 1; }
+	elsif (/^shared$/)
+		{ $no_shared = 1; }
+	elsif (/^zlib$/)
+		{ $zlib = 0; }
+	elsif (/^static-engine$/)
+		{ }
+	elsif (/^zlib-dynamic$/)
+		{ }
+	elsif (/^symlinks$/)
+		{ $symlink = 0; }
+	elsif (/^sse2$/)
+		{ $no_sse2 = 1; }
+	else
+		{
+		my ($ALGO, $algo);
+		($ALGO = $algo = $_) =~ tr/[\-a-z]/[_A-Z]/;
+
+		if (/^asm$/ || /^err$/ || /^hw$/ || /^hw-/)
+			{
+			$openssl_other_defines .= "#define OPENSSL_NO_$ALGO\n";
+			print " OPENSSL_NO_$ALGO";
+		
+			if (/^err$/)	{ $flags .= "-DOPENSSL_NO_ERR "; }
+			elsif (/^asm$/)	{ $no_asm = 1; }
+			}
+		else
+			{
+			$openssl_algorithm_defines .= "#define OPENSSL_NO_$ALGO\n";
+			print " OPENSSL_NO_$ALGO";
+
+			if (/^krb5$/)
+				{ $no_krb5 = 1; }
+			else
+				{
+				push @skip, $algo;
+				# fix-up crypto/directory name(s)
+				@skip[$#skip]="whrlpool" if $algo eq "whirlpool";
+				print " (skip dir)";
+
+				$depflags .= " -DOPENSSL_NO_$ALGO";
+				}
+			}
+		}
+
+	print "\n";
+	}
+
+my $exp_cflags = "";
+foreach (sort @experimental)
+	{
+	my $ALGO;
+	($ALGO = $_) =~ tr/[a-z]/[A-Z]/;
+
+	# opensslconf.h will set OPENSSL_NO_... unless OPENSSL_EXPERIMENTAL_... is defined
+	$openssl_experimental_defines .= "#define OPENSSL_NO_$ALGO\n";
+	$exp_cflags .= " -DOPENSSL_EXPERIMENTAL_$ALGO";
+	}
+
+my $IsMK1MF=scalar grep /^$target$/,@MK1MF_Builds;
+
+$exe_ext=".exe" if ($target eq "Cygwin" || $target eq "DJGPP" || $target =~ /^mingw/);
+$exe_ext=".nlm" if ($target =~ /netware/);
+$exe_ext=".pm"  if ($target =~ /vos/);
+$openssldir="/usr/local/ssl" if ($openssldir eq "" and $prefix eq "");
+$prefix=$openssldir if $prefix eq "";
+
+$default_ranlib= &which("ranlib") or $default_ranlib="true";
+$perl=$ENV{'PERL'} or $perl=&which("perl5") or $perl=&which("perl")
+  or $perl="perl";
+my $make = $ENV{'MAKE'} || "make";
+
+$cross_compile_prefix=$ENV{'CROSS_COMPILE'} if $cross_compile_prefix eq "";
+
+chop $openssldir if $openssldir =~ /\/$/;
+chop $prefix if $prefix =~ /.\/$/;
+
+$openssldir=$prefix . "/ssl" if $openssldir eq "";
+$openssldir=$prefix . "/" . $openssldir if $openssldir !~ /(^\/|^[a-zA-Z]:[\\\/])/;
+
+
+print "IsMK1MF=$IsMK1MF\n";
+
+my @fields = split(/\s*:\s*/,$table{$target} . ":" x 30 , -1);
+my $cc = $fields[$idx_cc];
+# Allow environment CC to override compiler...
+if($ENV{CC}) {
+    $cc = $ENV{CC};
+}
+
+my $cflags = $fields[$idx_cflags];
+my $unistd = $fields[$idx_unistd];
+my $thread_cflag = $fields[$idx_thread_cflag];
+my $sys_id = $fields[$idx_sys_id];
+my $lflags = $fields[$idx_lflags];
+my $bn_ops = $fields[$idx_bn_ops];
+my $cpuid_obj = $fields[$idx_cpuid_obj];
+my $bn_obj = $fields[$idx_bn_obj];
+my $ec_obj = $fields[$idx_ec_obj];
+my $des_obj = $fields[$idx_des_obj];
+my $aes_obj = $fields[$idx_aes_obj];
+my $bf_obj = $fields[$idx_bf_obj];
+my $md5_obj = $fields[$idx_md5_obj];
+my $sha1_obj = $fields[$idx_sha1_obj];
+my $cast_obj = $fields[$idx_cast_obj];
+my $rc4_obj = $fields[$idx_rc4_obj];
+my $rmd160_obj = $fields[$idx_rmd160_obj];
+my $rc5_obj = $fields[$idx_rc5_obj];
+my $wp_obj = $fields[$idx_wp_obj];
+my $cmll_obj = $fields[$idx_cmll_obj];
+my $modes_obj = $fields[$idx_modes_obj];
+my $engines_obj = $fields[$idx_engines_obj];
+my $perlasm_scheme = $fields[$idx_perlasm_scheme];
+my $dso_scheme = $fields[$idx_dso_scheme];
+my $shared_target = $fields[$idx_shared_target];
+my $shared_cflag = $fields[$idx_shared_cflag];
+my $shared_ldflag = $fields[$idx_shared_ldflag];
+my $shared_extension = $fields[$idx_shared_extension];
+my $ranlib = $ENV{'RANLIB'} || $fields[$idx_ranlib];
+my $ar = $ENV{'AR'} || "ar";
+my $arflags = $fields[$idx_arflags];
+my $windres = $ENV{'RC'} || $ENV{'WINDRES'} || "windres";
+my $multilib = $fields[$idx_multilib];
+
+# if $prefix/lib$multilib is not an existing directory, then
+# assume that it's not searched by linker automatically, in
+# which case adding $multilib suffix causes more grief than
+# we're ready to tolerate, so don't...
+$multilib="" if !-d "$prefix/lib$multilib";
+
+$libdir="lib$multilib" if $libdir eq "";
+
+$cflags = "$cflags$exp_cflags";
+
+# '%' in $lflags is used to split flags to "pre-" and post-flags
+my ($prelflags,$postlflags)=split('%',$lflags);
+if (defined($postlflags))	{ $lflags=$postlflags;	}
+else				{ $lflags=$prelflags; undef $prelflags;	}
+
+if ($target =~ /^mingw/ && `$cc --target-help 2>&1` !~ m/\-mno\-cygwin/m)
+	{
+	$cflags =~ s/\-mno\-cygwin\s*//;
+	$shared_ldflag =~ s/\-mno\-cygwin\s*//;
+	}
+
+if ($target =~ /linux.*\-mips/ && !$no_asm && $flags !~ /\-m(ips|arch=)/) {
+	# minimally required architecture flags for assembly modules
+	$cflags="-mips2 $cflags" if ($target =~ /mips32/);
+	$cflags="-mips3 $cflags" if ($target =~ /mips64/);
+}
+
+my $no_shared_warn=0;
+my $no_user_cflags=0;
+
+if ($flags ne "")	{ $cflags="$flags$cflags"; }
+else			{ $no_user_cflags=1;       }
+
+# Kerberos settings.  The flavor must be provided from outside, either through
+# the script "config" or manually.
+if (!$no_krb5)
+	{
+	my ($lresolv, $lpath, $lext);
+	if ($withargs{"krb5-flavor"} =~ /^[Hh]eimdal$/)
+		{
+		die "Sorry, Heimdal is currently not supported\n";
+		}
+	##### HACK to force use of Heimdal.
+	##### WARNING: Since we don't really have adequate support for Heimdal,
+	#####          using this will break the build.  You'll have to make
+	#####          changes to the source, and if you do, please send
+	#####          patches to openssl-dev@openssl.org
+	if ($withargs{"krb5-flavor"} =~ /^force-[Hh]eimdal$/)
+		{
+		warn "Heimdal isn't really supported.  Your build WILL break\n";
+		warn "If you fix the problems, please send a patch to openssl-dev\@openssl.org\n";
+		$withargs{"krb5-dir"} = "/usr/heimdal"
+			if $withargs{"krb5-dir"} eq "";
+		$withargs{"krb5-lib"} = "-L".$withargs{"krb5-dir"}.
+			"/lib -lgssapi -lkrb5 -lcom_err"
+			if $withargs{"krb5-lib"} eq "" && !$IsMK1MF;
+		$cflags="-DKRB5_HEIMDAL $cflags";
+		}
+	if ($withargs{"krb5-flavor"} =~ /^[Mm][Ii][Tt]/)
+		{
+		$withargs{"krb5-dir"} = "/usr/kerberos"
+			if $withargs{"krb5-dir"} eq "";
+		$withargs{"krb5-lib"} = "-L".$withargs{"krb5-dir"}.
+			"/lib -lgssapi_krb5 -lkrb5 -lcom_err -lk5crypto"
+			if $withargs{"krb5-lib"} eq "" && !$IsMK1MF;
+		$cflags="-DKRB5_MIT $cflags";
+		$withargs{"krb5-flavor"} =~ s/^[Mm][Ii][Tt][._-]*//;
+		if ($withargs{"krb5-flavor"} =~ /^1[._-]*[01]/)
+			{
+			$cflags="-DKRB5_MIT_OLD11 $cflags";
+			}
+		}
+	LRESOLV:
+	foreach $lpath ("/lib", "/usr/lib")
+		{
+		foreach $lext ("a", "so")
+			{
+			$lresolv = "$lpath/libresolv.$lext";
+			last LRESOLV	if (-r "$lresolv");
+			$lresolv = "";
+			}
+		}
+	$withargs{"krb5-lib"} .= " -lresolv"
+		if ("$lresolv" ne "");
+	$withargs{"krb5-include"} = "-I".$withargs{"krb5-dir"}."/include"
+		if $withargs{"krb5-include"} eq "" &&
+		   $withargs{"krb5-dir"} ne "";
+	}
+
+# The DSO code currently always implements all functions so that no
+# applications will have to worry about that from a compilation point
+# of view. However, the "method"s may return zero unless that platform
+# has support compiled in for them. Currently each method is enabled
+# by a define "DSO_<name>" ... we translate the "dso_scheme" config
+# string entry into using the following logic;
+my $dso_cflags;
+if (!$no_dso && $dso_scheme ne "")
+	{
+	$dso_scheme =~ tr/[a-z]/[A-Z]/;
+	if ($dso_scheme eq "DLFCN")
+		{
+		$dso_cflags = "-DDSO_DLFCN -DHAVE_DLFCN_H";
+		}
+	elsif ($dso_scheme eq "DLFCN_NO_H")
+		{
+		$dso_cflags = "-DDSO_DLFCN";
+		}
+	else
+		{
+		$dso_cflags = "-DDSO_$dso_scheme";
+		}
+	$cflags = "$dso_cflags $cflags";
+	}
+
+my $thread_cflags;
+my $thread_defines;
+if ($thread_cflag ne "(unknown)" && !$no_threads)
+	{
+	# If we know how to do it, support threads by default.
+	$threads = 1;
+	}
+if ($thread_cflag eq "(unknown)" && $threads)
+	{
+	# If the user asked for "threads", [s]he is also expected to
+	# provide any system-dependent compiler options that are
+	# necessary.
+	if ($no_user_cflags)
+		{
+		print "You asked for multi-threading support, but didn't\n";
+		print "provide any system-specific compiler options\n";
+		exit(1);
+		}
+	$thread_cflags="-DOPENSSL_THREADS $cflags" ;
+	$thread_defines .= "#define OPENSSL_THREADS\n";
+	}
+else
+	{
+	$thread_cflags="-DOPENSSL_THREADS $thread_cflag $cflags";
+	$thread_defines .= "#define OPENSSL_THREADS\n";
+#	my $def;
+#	foreach $def (split ' ',$thread_cflag)
+#		{
+#		if ($def =~ s/^-D// && $def !~ /^_/)
+#			{
+#			$thread_defines .= "#define $def\n";
+#			}
+#		}
+	}	
+
+$lflags="$libs$lflags" if ($libs ne "");
+
+if ($no_asm)
+	{
+	$cpuid_obj=$bn_obj=$ec_obj=
+	$des_obj=$aes_obj=$bf_obj=$cast_obj=$rc4_obj=$rc5_obj=$cmll_obj=
+	$modes_obj=$sha1_obj=$md5_obj=$rmd160_obj=$wp_obj=$engines_obj="";
+	}
+
+if (!$no_shared)
+	{
+	$cast_obj="";	# CAST assembler is not PIC
+	}
+
+if ($threads)
+	{
+	$cflags=$thread_cflags;
+	$openssl_thread_defines .= $thread_defines;
+	}
+
+if ($zlib)
+	{
+	$cflags = "-DZLIB $cflags";
+	if (defined($disabled{"zlib-dynamic"}))
+		{
+		if (defined($withargs{"zlib-lib"}))
+			{
+			$lflags = "$lflags -L" . $withargs{"zlib-lib"} . " -lz";
+			}
+		else
+			{
+			$lflags = "$lflags -lz";
+			}
+		}
+	else
+		{
+		$cflags = "-DZLIB_SHARED $cflags";
+		}
+	}
+
+# You will find shlib_mark1 and shlib_mark2 explained in Makefile.org
+my $shared_mark = "";
+if ($shared_target eq "")
+	{
+	$no_shared_warn = 1 if !$no_shared;
+	$no_shared = 1;
+	}
+if (!$no_shared)
+	{
+	if ($shared_cflag ne "")
+		{
+		$cflags = "$shared_cflag -DOPENSSL_PIC $cflags";
+		}
+	}
+
+if (!$IsMK1MF)
+	{
+	# add {no-}static-engine to options to allow mkdef.pl to work without extra arguments
+	if ($no_shared)
+		{
+		$openssl_other_defines.="#define OPENSSL_NO_DYNAMIC_ENGINE\n";
+		$options.=" static-engine";
+		}
+	else
+		{
+		$openssl_other_defines.="#define OPENSSL_NO_STATIC_ENGINE\n";
+		$options.=" no-static-engine";
+		}
+	}
+
+$cpuid_obj.=" uplink.o uplink-x86.o" if ($cflags =~ /\-DOPENSSL_USE_APPLINK/);
+
+#
+# Platform fix-ups
+#
+if ($target =~ /\-icc$/)	# Intel C compiler
+	{
+	my $iccver=0;
+	if (open(FD,"$cc -V 2>&1 |"))
+		{
+		while(<FD>) { $iccver=$1 if (/Version ([0-9]+)\./); }
+		close(FD);
+		}
+	if ($iccver>=8)
+		{
+		$cflags=~s/\-KPIC/-fPIC/;
+		# Eliminate unnecessary dependency from libirc.a. This is
+		# essential for shared library support, as otherwise
+		# apps/openssl can end up in endless loop upon startup...
+		$cflags.=" -Dmemcpy=__builtin_memcpy -Dmemset=__builtin_memset";
+		}
+	if ($iccver>=9)
+		{
+		$lflags.=" -i-static";
+		$lflags=~s/\-no_cpprt/-no-cpprt/;
+		}
+	if ($iccver>=10)
+		{
+		$lflags=~s/\-i\-static/-static-intel/;
+		}
+	if ($iccver>=11)
+		{
+		$cflags.=" -no-intel-extensions";	# disable Cilk
+		$lflags=~s/\-no\-cpprt/-no-cxxlib/;
+		}
+	}
+
+# Unlike other OSes (like Solaris, Linux, Tru64, IRIX) BSD run-time
+# linkers (tested OpenBSD, NetBSD and FreeBSD) "demand" RPATH set on
+# .so objects. Apparently application RPATH is not global and does
+# not apply to .so linked with other .so. Problem manifests itself
+# when libssl.so fails to load libcrypto.so. One can argue that we
+# should engrave this into Makefile.shared rules or into BSD-* config
+# lines above. Meanwhile let's try to be cautious and pass -rpath to
+# linker only when --prefix is not /usr.
+if ($target =~ /^BSD\-/)
+	{
+	$shared_ldflag.=" -Wl,-rpath,\$\$(LIBRPATH)" if ($prefix !~ m|^/usr[/]*$|);
+	}
+
+if ($sys_id ne "")
+	{
+	#$cflags="-DOPENSSL_SYSNAME_$sys_id $cflags";
+	$openssl_sys_defines="#define OPENSSL_SYSNAME_$sys_id\n";
+	}
+
+if ($ranlib eq "")
+	{
+	$ranlib = $default_ranlib;
+	}
+
+#my ($bn1)=split(/\s+/,$bn_obj);
+#$bn1 = "" unless defined $bn1;
+#$bn1=$bn_asm unless ($bn1 =~ /\.o$/);
+#$bn_obj="$bn1";
+
+$cpuid_obj="" if ($processor eq "386");
+
+$bn_obj = $bn_asm unless $bn_obj ne "";
+# bn-586 is the only one implementing bn_*_part_words
+$cflags.=" -DOPENSSL_BN_ASM_PART_WORDS" if ($bn_obj =~ /bn-586/);
+$cflags.=" -DOPENSSL_IA32_SSE2" if (!$no_sse2 && $bn_obj =~ /86/);
+
+$cflags.=" -DOPENSSL_BN_ASM_MONT" if ($bn_obj =~ /-mont/);
+$cflags.=" -DOPENSSL_BN_ASM_MONT5" if ($bn_obj =~ /-mont5/);
+$cflags.=" -DOPENSSL_BN_ASM_GF2m" if ($bn_obj =~ /-gf2m/);
+
+if ($fips)
+	{
+	$openssl_other_defines.="#define OPENSSL_FIPS\n";
+	$cflags .= " -I\$(FIPSDIR)/include";
+	}
+
+$cpuid_obj="mem_clr.o"	unless ($cpuid_obj =~ /\.o$/);
+$des_obj=$des_enc	unless ($des_obj =~ /\.o$/);
+$bf_obj=$bf_enc		unless ($bf_obj =~ /\.o$/);
+$cast_obj=$cast_enc	unless ($cast_obj =~ /\.o$/);
+$rc5_obj=$rc5_enc	unless ($rc5_obj =~ /\.o$/);
+if ($rc4_obj =~ /\.o$/)
+	{
+	$cflags.=" -DRC4_ASM";
+	}
+else
+	{
+	$rc4_obj=$rc4_enc;
+	}
+if ($sha1_obj =~ /\.o$/)
+	{
+#	$sha1_obj=$sha1_enc;
+	$cflags.=" -DSHA1_ASM"   if ($sha1_obj =~ /sx86/ || $sha1_obj =~ /sha1/);
+	$cflags.=" -DSHA256_ASM" if ($sha1_obj =~ /sha256/);
+	$cflags.=" -DSHA512_ASM" if ($sha1_obj =~ /sha512/);
+	if ($sha1_obj =~ /sse2/)
+	    {	if ($no_sse2)
+		{   $sha1_obj =~ s/\S*sse2\S+//;        }
+		elsif ($cflags !~ /OPENSSL_IA32_SSE2/)
+		{   $cflags.=" -DOPENSSL_IA32_SSE2";    }
+	    }
+	}
+if ($md5_obj =~ /\.o$/)
+	{
+#	$md5_obj=$md5_enc;
+	$cflags.=" -DMD5_ASM";
+	}
+if ($rmd160_obj =~ /\.o$/)
+	{
+#	$rmd160_obj=$rmd160_enc;
+	$cflags.=" -DRMD160_ASM";
+	}
+if ($aes_obj =~ /\.o$/)
+	{
+	$cflags.=" -DAES_ASM" if ($aes_obj =~ m/\baes\-/);;
+	# aes-ctr.o is not a real file, only indication that assembler
+	# module implements AES_ctr32_encrypt...
+	$cflags.=" -DAES_CTR_ASM" if ($aes_obj =~ s/\s*aes\-ctr\.o//);
+	# aes-xts.o indicates presense of AES_xts_[en|de]crypt...
+	$cflags.=" -DAES_XTS_ASM" if ($aes_obj =~ s/\s*aes\-xts\.o//);
+	$aes_obj =~ s/\s*(vpaes|aesni)\-x86\.o//g if ($no_sse2);
+	$cflags.=" -DVPAES_ASM" if ($aes_obj =~ m/vpaes/);
+	$cflags.=" -DBSAES_ASM" if ($aes_obj =~ m/bsaes/);
+	}
+else	{
+	$aes_obj=$aes_enc;
+	}
+$wp_obj="" if ($wp_obj =~ /mmx/ && $processor eq "386");
+if ($wp_obj =~ /\.o$/ && !$disabled{"whirlpool"})
+	{
+	$cflags.=" -DWHIRLPOOL_ASM";
+	}
+else	{
+	$wp_obj="wp_block.o";
+	}
+$cmll_obj=$cmll_enc	unless ($cmll_obj =~ /.o$/);
+if ($modes_obj =~ /ghash\-/)
+	{
+	$cflags.=" -DGHASH_ASM";
+	}
+if ($ec_obj =~ /ecp_nistz256/)
+	{
+	$cflags.=" -DECP_NISTZ256_ASM";
+	}
+
+# "Stringify" the C flags string.  This permits it to be made part of a string
+# and works as well on command lines.
+$cflags =~ s/([\\\"])/\\\1/g;
+
+my $version = "unknown";
+my $version_num = "unknown";
+my $major = "unknown";
+my $minor = "unknown";
+my $shlib_version_number = "unknown";
+my $shlib_version_history = "unknown";
+my $shlib_major = "unknown";
+my $shlib_minor = "unknown";
+
+open(IN,'<crypto/opensslv.h') || die "unable to read opensslv.h:$!\n";
+while (<IN>)
+	{
+	$version=$1 if /OPENSSL.VERSION.TEXT.*OpenSSL (\S+) /;
+	$version_num=$1 if /OPENSSL.VERSION.NUMBER.*0x(\S+)/;
+	$shlib_version_number=$1 if /SHLIB_VERSION_NUMBER *"([^"]+)"/;
+	$shlib_version_history=$1 if /SHLIB_VERSION_HISTORY *"([^"]*)"/;
+	}
+close(IN);
+if ($shlib_version_history ne "") { $shlib_version_history .= ":"; }
+
+if ($version =~ /(^[0-9]*)\.([0-9\.]*)/)
+	{
+	$major=$1;
+	$minor=$2;
+	}
+
+if ($shlib_version_number =~ /(^[0-9]*)\.([0-9\.]*)/)
+	{
+	$shlib_major=$1;
+	$shlib_minor=$2;
+	}
+
+my $ecc = $cc;
+$ecc = "clang" if `$cc --version 2>&1` =~ /clang/;
+
+if ($strict_warnings)
+	{
+	my $wopt;
+	die "ERROR --strict-warnings requires gcc or clang" unless ($ecc =~ /gcc$/ or $ecc =~ /clang$/);
+	foreach $wopt (split /\s+/, $gcc_devteam_warn)
+		{
+		$cflags .= " $wopt" unless ($cflags =~ /(^|\s)$wopt(\s|$)/)
+		}
+	if ($ecc eq "clang")
+		{
+		foreach $wopt (split /\s+/, $clang_devteam_warn)
+			{
+			$cflags .= " $wopt" unless ($cflags =~ /(^|\s)$wopt(\s|$)/)
+			}
+		}
+	}
+
+open(IN,'<Makefile.org') || die "unable to read Makefile.org:$!\n";
+unlink("$Makefile.new") || die "unable to remove old $Makefile.new:$!\n" if -e "$Makefile.new";
+open(OUT,">$Makefile.new") || die "unable to create $Makefile.new:$!\n";
+print OUT "### Generated automatically from Makefile.org by Configure.\n\n";
+my $sdirs=0;
+while (<IN>)
+	{
+	chomp;
+	$sdirs = 1 if /^SDIRS=/;
+	if ($sdirs) {
+		my $dir;
+		foreach $dir (@skip) {
+			s/(\s)$dir /$1/;
+			s/\s$dir$//;
+			}
+		}
+	$sdirs = 0 unless /\\$/;
+        s/engines // if (/^DIRS=/ && $disabled{"engine"});
+	s/ccgost// if (/^ENGDIRS=/ && $disabled{"gost"});
+	s/^VERSION=.*/VERSION=$version/;
+	s/^MAJOR=.*/MAJOR=$major/;
+	s/^MINOR=.*/MINOR=$minor/;
+	s/^SHLIB_VERSION_NUMBER=.*/SHLIB_VERSION_NUMBER=$shlib_version_number/;
+	s/^SHLIB_VERSION_HISTORY=.*/SHLIB_VERSION_HISTORY=$shlib_version_history/;
+	s/^SHLIB_MAJOR=.*/SHLIB_MAJOR=$shlib_major/;
+	s/^SHLIB_MINOR=.*/SHLIB_MINOR=$shlib_minor/;
+	s/^SHLIB_EXT=.*/SHLIB_EXT=$shared_extension/;
+	s/^INSTALLTOP=.*$/INSTALLTOP=$prefix/;
+	s/^MULTILIB=.*$/MULTILIB=$multilib/;
+	s/^OPENSSLDIR=.*$/OPENSSLDIR=$openssldir/;
+	s/^LIBDIR=.*$/LIBDIR=$libdir/;
+	s/^INSTALL_PREFIX=.*$/INSTALL_PREFIX=$install_prefix/;
+	s/^PLATFORM=.*$/PLATFORM=$target/;
+	s/^OPTIONS=.*$/OPTIONS=$options/;
+	s/^CONFIGURE_ARGS=.*$/CONFIGURE_ARGS=$argvstring/;
+	if ($cross_compile_prefix)
+		{
+		s/^CC=.*$/CROSS_COMPILE= $cross_compile_prefix\nCC= \$\(CROSS_COMPILE\)$cc/;
+		s/^AR=\s*/AR= \$\(CROSS_COMPILE\)/;
+		s/^NM=\s*/NM= \$\(CROSS_COMPILE\)/;
+		s/^RANLIB=\s*/RANLIB= \$\(CROSS_COMPILE\)/;
+		s/^RC=\s*/RC= \$\(CROSS_COMPILE\)/;
+		s/^MAKEDEPPROG=.*$/MAKEDEPPROG= \$\(CROSS_COMPILE\)$cc/ if $cc eq "gcc";
+		}
+	else	{
+		s/^CC=.*$/CC= $cc/;
+		s/^AR=\s*ar/AR= $ar/;
+		s/^RANLIB=.*/RANLIB= $ranlib/;
+		s/^RC=.*/RC= $windres/;
+		s/^MAKEDEPPROG=.*$/MAKEDEPPROG= $cc/ if $cc eq "gcc";
+		s/^MAKEDEPPROG=.*$/MAKEDEPPROG= $cc/ if $ecc eq "gcc" || $ecc eq "clang";
+		}
+	s/^CFLAG=.*$/CFLAG= $cflags/;
+	s/^DEPFLAG=.*$/DEPFLAG=$depflags/;
+	s/^PEX_LIBS=.*$/PEX_LIBS= $prelflags/;
+	s/^EX_LIBS=.*$/EX_LIBS= $lflags/;
+	s/^EXE_EXT=.*$/EXE_EXT= $exe_ext/;
+	s/^CPUID_OBJ=.*$/CPUID_OBJ= $cpuid_obj/;
+	s/^BN_ASM=.*$/BN_ASM= $bn_obj/;
+	s/^EC_ASM=.*$/EC_ASM= $ec_obj/;
+	s/^DES_ENC=.*$/DES_ENC= $des_obj/;
+	s/^AES_ENC=.*$/AES_ENC= $aes_obj/;
+	s/^BF_ENC=.*$/BF_ENC= $bf_obj/;
+	s/^CAST_ENC=.*$/CAST_ENC= $cast_obj/;
+	s/^RC4_ENC=.*$/RC4_ENC= $rc4_obj/;
+	s/^RC5_ENC=.*$/RC5_ENC= $rc5_obj/;
+	s/^MD5_ASM_OBJ=.*$/MD5_ASM_OBJ= $md5_obj/;
+	s/^SHA1_ASM_OBJ=.*$/SHA1_ASM_OBJ= $sha1_obj/;
+	s/^RMD160_ASM_OBJ=.*$/RMD160_ASM_OBJ= $rmd160_obj/;
+	s/^WP_ASM_OBJ=.*$/WP_ASM_OBJ= $wp_obj/;
+	s/^CMLL_ENC=.*$/CMLL_ENC= $cmll_obj/;
+	s/^MODES_ASM_OBJ.=*$/MODES_ASM_OBJ= $modes_obj/;
+	s/^ENGINES_ASM_OBJ.=*$/ENGINES_ASM_OBJ= $engines_obj/;
+	s/^PERLASM_SCHEME=.*$/PERLASM_SCHEME= $perlasm_scheme/;
+	s/^PROCESSOR=.*/PROCESSOR= $processor/;
+	s/^ARFLAGS=.*/ARFLAGS= $arflags/;
+	s/^PERL=.*/PERL= $perl/;
+	s/^KRB5_INCLUDES=.*/KRB5_INCLUDES=$withargs{"krb5-include"}/;
+	s/^LIBKRB5=.*/LIBKRB5=$withargs{"krb5-lib"}/;
+	s/^LIBZLIB=.*/LIBZLIB=$withargs{"zlib-lib"}/;
+	s/^ZLIB_INCLUDE=.*/ZLIB_INCLUDE=$withargs{"zlib-include"}/;
+
+	s/^FIPSDIR=.*/FIPSDIR=$fipsdir/;
+	s/^FIPSLIBDIR=.*/FIPSLIBDIR=$fipslibdir/;
+	s/^FIPSCANLIB=.*/FIPSCANLIB=libcrypto/ if $fips;
+	s/^BASEADDR=.*/BASEADDR=$baseaddr/;
+
+	s/^SHLIB_TARGET=.*/SHLIB_TARGET=$shared_target/;
+	s/^SHLIB_MARK=.*/SHLIB_MARK=$shared_mark/;
+	s/^SHARED_LIBS=.*/SHARED_LIBS=\$(SHARED_CRYPTO) \$(SHARED_SSL)/ if (!$no_shared);
+	if ($shared_extension ne "" && $shared_extension =~ /^\.s([ol])\.[^\.]*$/)
+		{
+		my $sotmp = $1;
+		s/^SHARED_LIBS_LINK_EXTS=.*/SHARED_LIBS_LINK_EXTS=.s$sotmp/;
+		}
+	elsif ($shared_extension ne "" && $shared_extension =~ /^\.[^\.]*\.dylib$/)
+		{
+		s/^SHARED_LIBS_LINK_EXTS=.*/SHARED_LIBS_LINK_EXTS=.dylib/;
+		}
+	elsif ($shared_extension ne "" && $shared_extension =~ /^\.s([ol])\.[^\.]*\.[^\.]*$/)
+		{
+		my $sotmp = $1;
+#		s/^SHARED_LIBS_LINK_EXTS=.*/SHARED_LIBS_LINK_EXTS=.s$sotmp.\$(SHLIB_MAJOR) .s$sotmp/;
+		s/^SHARED_LIBS_LINK_EXTS=.*/SHARED_LIBS_LINK_EXTS=.s$sotmp/;
+		}
+	elsif ($shared_extension ne "" && $shared_extension =~ /^\.[^\.]*\.[^\.]*\.dylib$/)
+		{
+		s/^SHARED_LIBS_LINK_EXTS=.*/SHARED_LIBS_LINK_EXTS=.\$(SHLIB_MAJOR).dylib .dylib/;
+		}
+	s/^SHARED_LDFLAGS=.*/SHARED_LDFLAGS=$shared_ldflag/;
+	print OUT $_."\n";
+	}
+close(IN);
+close(OUT);
+if ((compare($Makefile, "$Makefile.new"))
+	or file_newer('Configure', $Makefile)
+	or file_newer('config', $Makefile)
+	or file_newer('Makefile.org', $Makefile))
+	{
+	rename($Makefile,"$Makefile.bak") || die "unable to rename $Makefile\n" if -e $Makefile;
+	rename("$Makefile.new",$Makefile) || die "unable to rename $Makefile.new\n";
+	}
+else
+	{ unlink("$Makefile.new"); }
+
+print "CC            =$cc\n";
+print "CFLAG         =$cflags\n";
+print "EX_LIBS       =$lflags\n";
+print "CPUID_OBJ     =$cpuid_obj\n";
+print "BN_ASM        =$bn_obj\n";
+print "EC_ASM        =$ec_obj\n";
+print "DES_ENC       =$des_obj\n";
+print "AES_ENC       =$aes_obj\n";
+print "BF_ENC        =$bf_obj\n";
+print "CAST_ENC      =$cast_obj\n";
+print "RC4_ENC       =$rc4_obj\n";
+print "RC5_ENC       =$rc5_obj\n";
+print "MD5_OBJ_ASM   =$md5_obj\n";
+print "SHA1_OBJ_ASM  =$sha1_obj\n";
+print "RMD160_OBJ_ASM=$rmd160_obj\n";
+print "CMLL_ENC      =$cmll_obj\n";
+print "MODES_OBJ     =$modes_obj\n";
+print "ENGINES_OBJ   =$engines_obj\n";
+print "PROCESSOR     =$processor\n";
+print "RANLIB        =$ranlib\n";
+print "ARFLAGS       =$arflags\n";
+print "PERL          =$perl\n";
+print "KRB5_INCLUDES =",$withargs{"krb5-include"},"\n"
+	if $withargs{"krb5-include"} ne "";
+
+my $des_ptr=0;
+my $des_risc1=0;
+my $des_risc2=0;
+my $des_unroll=0;
+my $bn_ll=0;
+my $def_int=2;
+my $rc4_int=$def_int;
+my $md2_int=$def_int;
+my $idea_int=$def_int;
+my $rc2_int=$def_int;
+my $rc4_idx=0;
+my $rc4_chunk=0;
+my $bf_ptr=0;
+my @type=("char","short","int","long");
+my ($b64l,$b64,$b32,$b16,$b8)=(0,0,1,0,0);
+my $export_var_as_fn=0;
+
+my $des_int;
+
+foreach (sort split(/\s+/,$bn_ops))
+	{
+	$des_ptr=1 if /DES_PTR/;
+	$des_risc1=1 if /DES_RISC1/;
+	$des_risc2=1 if /DES_RISC2/;
+	$des_unroll=1 if /DES_UNROLL/;
+	$des_int=1 if /DES_INT/;
+	$bn_ll=1 if /BN_LLONG/;
+	$rc4_int=0 if /RC4_CHAR/;
+	$rc4_int=3 if /RC4_LONG/;
+	$rc4_idx=1 if /RC4_INDEX/;
+	$rc4_chunk=1 if /RC4_CHUNK/;
+	$rc4_chunk=2 if /RC4_CHUNK_LL/;
+	$md2_int=0 if /MD2_CHAR/;
+	$md2_int=3 if /MD2_LONG/;
+	$idea_int=1 if /IDEA_SHORT/;
+	$idea_int=3 if /IDEA_LONG/;
+	$rc2_int=1 if /RC2_SHORT/;
+	$rc2_int=3 if /RC2_LONG/;
+	$bf_ptr=1 if $_ eq "BF_PTR";
+	$bf_ptr=2 if $_ eq "BF_PTR2";
+	($b64l,$b64,$b32,$b16,$b8)=(0,1,0,0,0) if /SIXTY_FOUR_BIT/;
+	($b64l,$b64,$b32,$b16,$b8)=(1,0,0,0,0) if /SIXTY_FOUR_BIT_LONG/;
+	($b64l,$b64,$b32,$b16,$b8)=(0,0,1,0,0) if /THIRTY_TWO_BIT/;
+	($b64l,$b64,$b32,$b16,$b8)=(0,0,0,1,0) if /SIXTEEN_BIT/;
+	($b64l,$b64,$b32,$b16,$b8)=(0,0,0,0,1) if /EIGHT_BIT/;
+	$export_var_as_fn=1 if /EXPORT_VAR_AS_FN/;
+	}
+
+open(IN,'<crypto/opensslconf.h.in') || die "unable to read crypto/opensslconf.h.in:$!\n";
+unlink("crypto/opensslconf.h.new") || die "unable to remove old crypto/opensslconf.h.new:$!\n" if -e "crypto/opensslconf.h.new";
+open(OUT,'>crypto/opensslconf.h.new') || die "unable to create crypto/opensslconf.h.new:$!\n";
+print OUT "/* opensslconf.h */\n";
+print OUT "/* WARNING: Generated automatically from opensslconf.h.in by Configure. */\n\n";
+
+print OUT "#ifdef  __cplusplus\n";
+print OUT "extern \"C\" {\n";
+print OUT "#endif\n";
+print OUT "/* OpenSSL was configured with the following options: */\n";
+my $openssl_algorithm_defines_trans = $openssl_algorithm_defines;
+$openssl_experimental_defines =~ s/^\s*#\s*define\s+OPENSSL_NO_(.*)/#ifndef OPENSSL_EXPERIMENTAL_$1\n# ifndef OPENSSL_NO_$1\n#  define OPENSSL_NO_$1\n# endif\n#endif/mg;
+$openssl_algorithm_defines_trans =~ s/^\s*#\s*define\s+OPENSSL_(.*)/# if defined(OPENSSL_$1) \&\& !defined($1)\n#  define $1\n# endif/mg;
+$openssl_algorithm_defines =~ s/^\s*#\s*define\s+(.*)/#ifndef $1\n# define $1\n#endif/mg;
+$openssl_algorithm_defines = "   /* no ciphers excluded */\n" if $openssl_algorithm_defines eq "";
+$openssl_thread_defines =~ s/^\s*#\s*define\s+(.*)/#ifndef $1\n# define $1\n#endif/mg;
+$openssl_sys_defines =~ s/^\s*#\s*define\s+(.*)/#ifndef $1\n# define $1\n#endif/mg;
+$openssl_other_defines =~ s/^\s*#\s*define\s+(.*)/#ifndef $1\n# define $1\n#endif/mg;
+print OUT $openssl_sys_defines;
+print OUT "#ifndef OPENSSL_DOING_MAKEDEPEND\n\n";
+print OUT $openssl_experimental_defines;
+print OUT "\n";
+print OUT $openssl_algorithm_defines;
+print OUT "\n#endif /* OPENSSL_DOING_MAKEDEPEND */\n\n";
+print OUT $openssl_thread_defines;
+print OUT $openssl_other_defines,"\n";
+
+print OUT "/* The OPENSSL_NO_* macros are also defined as NO_* if the application\n";
+print OUT "   asks for it.  This is a transient feature that is provided for those\n";
+print OUT "   who haven't had the time to do the appropriate changes in their\n";
+print OUT "   applications.  */\n";
+print OUT "#ifdef OPENSSL_ALGORITHM_DEFINES\n";
+print OUT $openssl_algorithm_defines_trans;
+print OUT "#endif\n\n";
+
+print OUT "#define OPENSSL_CPUID_OBJ\n\n" if ($cpuid_obj ne "mem_clr.o");
+
+while (<IN>)
+	{
+	if	(/^#define\s+OPENSSLDIR/)
+		{
+		my $foo = $openssldir;
+		$foo =~ s/\\/\\\\/g;
+		print OUT "#define OPENSSLDIR \"$foo\"\n";
+		}
+	elsif	(/^#define\s+ENGINESDIR/)
+		{
+		my $foo = "$prefix/$libdir/openssl-1.0.0/engines";
+		$foo =~ s/\\/\\\\/g;
+		print OUT "#define ENGINESDIR \"$foo\"\n";
+		}
+	elsif	(/^#((define)|(undef))\s+OPENSSL_EXPORT_VAR_AS_FUNCTION/)
+		{ printf OUT "#undef OPENSSL_EXPORT_VAR_AS_FUNCTION\n"
+			if $export_var_as_fn;
+		  printf OUT "#%s OPENSSL_EXPORT_VAR_AS_FUNCTION\n",
+			($export_var_as_fn)?"define":"undef"; }
+	elsif	(/^#define\s+OPENSSL_UNISTD/)
+		{
+		$unistd = "<unistd.h>" if $unistd eq "";
+		print OUT "#define OPENSSL_UNISTD $unistd\n";
+		}
+	elsif	(/^#((define)|(undef))\s+SIXTY_FOUR_BIT_LONG/)
+		{ printf OUT "#%s SIXTY_FOUR_BIT_LONG\n",($b64l)?"define":"undef"; }
+	elsif	(/^#((define)|(undef))\s+SIXTY_FOUR_BIT/)
+		{ printf OUT "#%s SIXTY_FOUR_BIT\n",($b64)?"define":"undef"; }
+	elsif	(/^#((define)|(undef))\s+THIRTY_TWO_BIT/)
+		{ printf OUT "#%s THIRTY_TWO_BIT\n",($b32)?"define":"undef"; }
+	elsif	(/^#((define)|(undef))\s+SIXTEEN_BIT/)
+		{ printf OUT "#%s SIXTEEN_BIT\n",($b16)?"define":"undef"; }
+	elsif	(/^#((define)|(undef))\s+EIGHT_BIT/)
+		{ printf OUT "#%s EIGHT_BIT\n",($b8)?"define":"undef"; }
+	elsif	(/^#((define)|(undef))\s+BN_LLONG\s*$/)
+		{ printf OUT "#%s BN_LLONG\n",($bn_ll)?"define":"undef"; }
+	elsif	(/^\#define\s+DES_LONG\s+.*/)
+		{ printf OUT "#define DES_LONG unsigned %s\n",
+			($des_int)?'int':'long'; }
+	elsif	(/^\#(define|undef)\s+DES_PTR/)
+		{ printf OUT "#%s DES_PTR\n",($des_ptr)?'define':'undef'; }
+	elsif	(/^\#(define|undef)\s+DES_RISC1/)
+		{ printf OUT "#%s DES_RISC1\n",($des_risc1)?'define':'undef'; }
+	elsif	(/^\#(define|undef)\s+DES_RISC2/)
+		{ printf OUT "#%s DES_RISC2\n",($des_risc2)?'define':'undef'; }
+	elsif	(/^\#(define|undef)\s+DES_UNROLL/)
+		{ printf OUT "#%s DES_UNROLL\n",($des_unroll)?'define':'undef'; }
+	elsif	(/^#define\s+RC4_INT\s/)
+		{ printf OUT "#define RC4_INT unsigned %s\n",$type[$rc4_int]; }
+	elsif	(/^#undef\s+RC4_CHUNK/)
+		{
+		printf OUT "#undef RC4_CHUNK\n" if $rc4_chunk==0;
+		printf OUT "#define RC4_CHUNK unsigned long\n" if $rc4_chunk==1;
+		printf OUT "#define RC4_CHUNK unsigned long long\n" if $rc4_chunk==2;
+		}
+	elsif	(/^#((define)|(undef))\s+RC4_INDEX/)
+		{ printf OUT "#%s RC4_INDEX\n",($rc4_idx)?"define":"undef"; }
+	elsif (/^#(define|undef)\s+I386_ONLY/)
+		{ printf OUT "#%s I386_ONLY\n", ($processor eq "386")?
+			"define":"undef"; }
+	elsif	(/^#define\s+MD2_INT\s/)
+		{ printf OUT "#define MD2_INT unsigned %s\n",$type[$md2_int]; }
+	elsif	(/^#define\s+IDEA_INT\s/)
+		{printf OUT "#define IDEA_INT unsigned %s\n",$type[$idea_int];}
+	elsif	(/^#define\s+RC2_INT\s/)
+		{printf OUT "#define RC2_INT unsigned %s\n",$type[$rc2_int];}
+	elsif (/^#(define|undef)\s+BF_PTR/)
+		{
+		printf OUT "#undef BF_PTR\n" if $bf_ptr == 0;
+		printf OUT "#define BF_PTR\n" if $bf_ptr == 1;
+		printf OUT "#define BF_PTR2\n" if $bf_ptr == 2;
+	        }
+	else
+		{ print OUT $_; }
+	}
+close(IN);
+print OUT "#ifdef  __cplusplus\n";
+print OUT "}\n";
+print OUT "#endif\n";
+close(OUT);
+if (compare("crypto/opensslconf.h.new","crypto/opensslconf.h"))
+	{
+	rename("crypto/opensslconf.h","crypto/opensslconf.h.bak") || die "unable to rename crypto/opensslconf.h\n" if -e "crypto/opensslconf.h";
+	rename("crypto/opensslconf.h.new","crypto/opensslconf.h") || die "unable to rename crypto/opensslconf.h.new\n";
+	}
+else
+	{ unlink("crypto/opensslconf.h.new"); }
+
+# Fix the date
+
+print "SIXTY_FOUR_BIT_LONG mode\n" if $b64l;
+print "SIXTY_FOUR_BIT mode\n" if $b64;
+print "THIRTY_TWO_BIT mode\n" if $b32;
+print "SIXTEEN_BIT mode\n" if $b16;
+print "EIGHT_BIT mode\n" if $b8;
+print "DES_PTR used\n" if $des_ptr;
+print "DES_RISC1 used\n" if $des_risc1;
+print "DES_RISC2 used\n" if $des_risc2;
+print "DES_UNROLL used\n" if $des_unroll;
+print "DES_INT used\n" if $des_int;
+print "BN_LLONG mode\n" if $bn_ll;
+print "RC4 uses u$type[$rc4_int]\n" if $rc4_int != $def_int;
+print "RC4_INDEX mode\n" if $rc4_idx;
+print "RC4_CHUNK is undefined\n" if $rc4_chunk==0;
+print "RC4_CHUNK is unsigned long\n" if $rc4_chunk==1;
+print "RC4_CHUNK is unsigned long long\n" if $rc4_chunk==2;
+print "MD2 uses u$type[$md2_int]\n" if $md2_int != $def_int;
+print "IDEA uses u$type[$idea_int]\n" if $idea_int != $def_int;
+print "RC2 uses u$type[$rc2_int]\n" if $rc2_int != $def_int;
+print "BF_PTR used\n" if $bf_ptr == 1; 
+print "BF_PTR2 used\n" if $bf_ptr == 2; 
+
+if($IsMK1MF) {
+	open (OUT,">crypto/buildinf.h") || die "Can't open buildinf.h";
+	printf OUT <<EOF;
+#ifndef MK1MF_BUILD
+  /* auto-generated by Configure for crypto/cversion.c:
+   * for Unix builds, crypto/Makefile.ssl generates functional definitions;
+   * Windows builds (and other mk1mf builds) compile cversion.c with
+   * -DMK1MF_BUILD and use definitions added to this file by util/mk1mf.pl. */
+  #error "Windows builds (PLATFORM=$target) use mk1mf.pl-created Makefiles"
+#endif
+EOF
+	close(OUT);
+} else {
+	my $make_command = "$make PERL=\'$perl\'";
+	my @make_targets = ();
+	push @make_targets, "links" if $symlink;
+	push @make_targets, "depend" if $depflags ne $default_depflags && $make_depend;
+	push @make_targets, "gentests" if $symlink;
+	foreach my $make_target (@make_targets) {
+	    (system "$make_command $make_target") == 0 or exit $?;
+	}
+	if ( $perl =~ m@^/@) {
+	    &dofile("tools/c_rehash",$perl,'^#!/', '#!%s','^my \$dir;$', 'my $dir = "' . $openssldir . '";', '^my \$prefix;$', 'my $prefix = "' . $prefix . '";');
+	    &dofile("apps/CA.pl",$perl,'^#!/', '#!%s');
+	} else {
+	    # No path for Perl known ...
+	    &dofile("tools/c_rehash",'/usr/local/bin/perl','^#!/', '#!%s','^my \$dir;$', 'my $dir = "' . $openssldir . '";',  '^my \$prefix;$', 'my $prefix = "' . $prefix . '";');
+	    &dofile("apps/CA.pl",'/usr/local/bin/perl','^#!/', '#!%s');
+	}
+	if ($depflags ne $default_depflags && !$make_depend) {
+	    $warn_make_depend++;
+	}
+}
+
+# create the ms/version32.rc file if needed
+if ($IsMK1MF && ($target !~ /^netware/)) {
+	my ($v1, $v2, $v3, $v4);
+	if ($version_num =~ /(^[0-9a-f]{1})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})/i) {
+		$v1=hex $1;
+		$v2=hex $2;
+		$v3=hex $3;
+		$v4=hex $4;
+	}
+	open (OUT,">ms/version32.rc") || die "Can't open ms/version32.rc";
+	print OUT <<EOF;
+#include <winver.h>
+
+LANGUAGE 0x09,0x01
+
+1 VERSIONINFO
+  FILEVERSION $v1,$v2,$v3,$v4
+  PRODUCTVERSION $v1,$v2,$v3,$v4
+  FILEFLAGSMASK 0x3fL
+#ifdef _DEBUG
+  FILEFLAGS 0x01L
+#else
+  FILEFLAGS 0x00L
+#endif
+  FILEOS VOS__WINDOWS32
+  FILETYPE VFT_DLL
+  FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+	BLOCK "040904b0"
+	BEGIN
+	    // Required:	    
+	    VALUE "CompanyName", "The OpenSSL Project, http://www.openssl.org/\\0"
+	    VALUE "FileDescription", "OpenSSL Shared Library\\0"
+	    VALUE "FileVersion", "$version\\0"
+#if defined(CRYPTO)
+	    VALUE "InternalName", "libeay32\\0"
+	    VALUE "OriginalFilename", "libeay32.dll\\0"
+#elif defined(SSL)
+	    VALUE "InternalName", "ssleay32\\0"
+	    VALUE "OriginalFilename", "ssleay32.dll\\0"
+#endif
+	    VALUE "ProductName", "The OpenSSL Toolkit\\0"
+	    VALUE "ProductVersion", "$version\\0"
+	    // Optional:
+	    //VALUE "Comments", "\\0"
+	    VALUE "LegalCopyright", "Copyright   1998-2005 The OpenSSL Project. Copyright  1995-1998 Eric A. Young, Tim J. Hudson. All rights reserved.\\0"
+	    //VALUE "LegalTrademarks", "\\0"
+	    //VALUE "PrivateBuild", "\\0"
+	    //VALUE "SpecialBuild", "\\0"
+	END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x409, 0x4b0
+    END
+END
+EOF
+	close(OUT);
+  }
+  
+print <<EOF;
+
+Configured for $target.
+EOF
+
+print <<\EOF if (!$no_threads && !$threads);
+
+The library could not be configured for supporting multi-threaded
+applications as the compiler options required on this system are not known.
+See file INSTALL for details if you need multi-threading.
+EOF
+
+print <<\EOF if ($no_shared_warn);
+
+You gave the option 'shared', which is not supported on this platform, so
+we will pretend you gave the option 'no-shared'.  If you know how to implement
+shared libraries, please let us know (but please first make sure you have
+tried with a current version of OpenSSL).
+EOF
+
+print <<EOF if ($warn_make_depend);
+
+*** Because of configuration changes, you MUST do the following before
+*** building:
+
+	make depend
+EOF
+
+exit(0);
+
+sub usage
+	{
+	print STDERR $usage;
+	print STDERR "\npick os/compiler from:\n";
+	my $j=0;
+	my $i;
+        my $k=0;
+	foreach $i (sort keys %table)
+		{
+		next if $i =~ /^debug/;
+		$k += length($i) + 1;
+		if ($k > 78)
+			{
+			print STDERR "\n";
+			$k=length($i);
+			}
+		print STDERR $i . " ";
+		}
+	foreach $i (sort keys %table)
+		{
+		next if $i !~ /^debug/;
+		$k += length($i) + 1;
+		if ($k > 78)
+			{
+			print STDERR "\n";
+			$k=length($i);
+			}
+		print STDERR $i . " ";
+		}
+	print STDERR "\n\nNOTE: If in doubt, on Unix-ish systems use './config'.\n";
+	exit(1);
+	}
+
+sub which
+	{
+	my($name)=@_;
+	my $path;
+	foreach $path (split /:/, $ENV{PATH})
+		{
+		if (-f "$path/$name$exe_ext" and -x _)
+			{
+			return "$path/$name$exe_ext" unless ($name eq "perl" and
+			 system("$path/$name$exe_ext -e " . '\'exit($]<5.0);\''));
+			}
+		}
+	}
+
+sub dofile
+	{
+	my $f; my $p; my %m; my @a; my $k; my $ff;
+	($f,$p,%m)=@_;
+
+	open(IN,"<$f.in") || open(IN,"<$f") || die "unable to open $f:$!\n";
+	@a=<IN>;
+	close(IN);
+	foreach $k (keys %m)
+		{
+		grep(/$k/ && ($_=sprintf($m{$k}."\n",$p)),@a);
+		}
+	open(OUT,">$f.new") || die "unable to open $f.new:$!\n";
+	print OUT @a;
+	close(OUT);
+	rename($f,"$f.bak") || die "unable to rename $f\n" if -e $f;
+	rename("$f.new",$f) || die "unable to rename $f.new\n";
+	}
+
+sub print_table_entry
+	{
+	my $target = shift;
+
+	my ($cc, $cflags, $unistd, $thread_cflag, $sys_id, $lflags,
+	    $bn_ops, $cpuid_obj, $bn_obj, $ec_obj, $des_obj, $aes_obj, $bf_obj,
+	    $md5_obj, $sha1_obj, $cast_obj, $rc4_obj, $rmd160_obj,
+	    $rc5_obj, $wp_obj, $cmll_obj, $modes_obj, $engines_obj,
+	    $perlasm_scheme, $dso_scheme, $shared_target, $shared_cflag,
+	    $shared_ldflag, $shared_extension, $ranlib, $arflags, $multilib)=
+	split(/\s*:\s*/,$table{$target} . ":" x 30 , -1);
+			
+	print <<EOF
+
+*** $target
+\$cc           = $cc
+\$cflags       = $cflags
+\$unistd       = $unistd
+\$thread_cflag = $thread_cflag
+\$sys_id       = $sys_id
+\$lflags       = $lflags
+\$bn_ops       = $bn_ops
+\$cpuid_obj    = $cpuid_obj
+\$bn_obj       = $bn_obj
+\$ec_obj       = $ec_obj
+\$des_obj      = $des_obj
+\$aes_obj      = $aes_obj
+\$bf_obj       = $bf_obj
+\$md5_obj      = $md5_obj
+\$sha1_obj     = $sha1_obj
+\$cast_obj     = $cast_obj
+\$rc4_obj      = $rc4_obj
+\$rmd160_obj   = $rmd160_obj
+\$rc5_obj      = $rc5_obj
+\$wp_obj       = $wp_obj
+\$cmll_obj     = $cmll_obj
+\$modes_obj    = $modes_obj
+\$engines_obj  = $engines_obj
+\$perlasm_scheme = $perlasm_scheme
+\$dso_scheme   = $dso_scheme
+\$shared_target= $shared_target
+\$shared_cflag = $shared_cflag
+\$shared_ldflag = $shared_ldflag
+\$shared_extension = $shared_extension
+\$ranlib       = $ranlib
+\$arflags      = $arflags
+\$multilib     = $multilib
+EOF
+	}
+
+sub test_sanity
+	{
+	my $errorcnt = 0;
+
+	print STDERR "=" x 70, "\n";
+	print STDERR "=== SANITY TESTING!\n";
+	print STDERR "=== No configuration will be done, all other arguments will be ignored!\n";
+	print STDERR "=" x 70, "\n";
+
+	foreach $target (sort keys %table)
+		{
+		@fields = split(/\s*:\s*/,$table{$target} . ":" x 30 , -1);
+
+		if ($fields[$idx_dso_scheme-1] =~ /^(beos|dl|dlfcn|win32|vms)$/)
+			{
+			$errorcnt++;
+			print STDERR "SANITY ERROR: '$target' has the dso_scheme [$idx_dso_scheme] values\n";
+			print STDERR "              in the previous field\n";
+			}
+		elsif ($fields[$idx_dso_scheme+1] =~ /^(beos|dl|dlfcn|win32|vms)$/)
+			{
+			$errorcnt++;
+			print STDERR "SANITY ERROR: '$target' has the dso_scheme [$idx_dso_scheme] values\n";
+			print STDERR "              in the following field\n";
+			}
+		elsif ($fields[$idx_dso_scheme] !~ /^(beos|dl|dlfcn|win32|vms|)$/)
+			{
+			$errorcnt++;
+			print STDERR "SANITY ERROR: '$target' has the dso_scheme [$idx_dso_scheme] field = ",$fields[$idx_dso_scheme],"\n";
+			print STDERR "              valid values are 'beos', 'dl', 'dlfcn', 'win32' and 'vms'\n";
+			}
+		}
+	print STDERR "No sanity errors detected!\n" if $errorcnt == 0;
+	return $errorcnt;
+	}
+
+sub file_newer
+	{
+	my ($file1, $file2) = @_;
+	return (stat($file1))[9] > (stat($file2))[9]
+	}
diff -uNr openssl-1.0.2l.orig/crypto/des/asm/desboth.pl openssl-1.0.2l/crypto/des/asm/desboth.pl
--- openssl-1.0.2l.orig/crypto/des/asm/desboth.pl	2017-05-25 20:54:34.000000000 +0800
+++ openssl-1.0.2l/crypto/des/asm/desboth.pl	2018-07-16 17:01:21.648443028 +0800
@@ -16,6 +16,11 @@
 
 	&push("edi");
 
+	&call   (&label("pic_point0"));
+	&set_label("pic_point0");
+	&blindpop("ebp");
+	&add    ("ebp", "\$_GLOBAL_OFFSET_TABLE_+[.-" . &label("pic_point0") . "]");
+
 	&comment("");
 	&comment("Load the data words");
 	&mov($L,&DWP(0,"ebx","",0));
@@ -47,15 +52,21 @@
 	&mov(&swtmp(2),	(DWC(($enc)?"1":"0")));
 	&mov(&swtmp(1),	"eax");
 	&mov(&swtmp(0),	"ebx");
-	&call("DES_encrypt2");
+	&exch("ebx", "ebp");
+	&call("DES_encrypt2\@PLT");
+	&exch("ebx", "ebp");
 	&mov(&swtmp(2),	(DWC(($enc)?"0":"1")));
 	&mov(&swtmp(1),	"edi");
 	&mov(&swtmp(0),	"ebx");
-	&call("DES_encrypt2");
+	&exch("ebx", "ebp");
+	&call("DES_encrypt2\@PLT");
+	&exch("ebx", "ebp");
 	&mov(&swtmp(2),	(DWC(($enc)?"1":"0")));
 	&mov(&swtmp(1),	"esi");
 	&mov(&swtmp(0),	"ebx");
-	&call("DES_encrypt2");
+	&exch("ebx", "ebp");
+	&call("DES_encrypt2\@PLT");
+	&exch("ebx", "ebp");
 
 	&stack_pop(3);
 	&mov($L,&DWP(0,"ebx","",0));
diff -uNr openssl-1.0.2l.orig/crypto/perlasm/cbc.pl openssl-1.0.2l/crypto/perlasm/cbc.pl
--- openssl-1.0.2l.orig/crypto/perlasm/cbc.pl	2017-05-25 20:54:34.000000000 +0800
+++ openssl-1.0.2l/crypto/perlasm/cbc.pl	2018-07-16 17:01:21.648443028 +0800
@@ -122,7 +122,11 @@
 	&mov(&DWP($data_off,"esp","",0),	"eax");	# put in array for call
 	&mov(&DWP($data_off+4,"esp","",0),	"ebx");	#
 
-	&call($enc_func);
+	&call	(&label("pic_point0"));
+	&set_label("pic_point0");
+	&blindpop("ebx");
+	&add	("ebx", "\$_GLOBAL_OFFSET_TABLE_+[.-" . &label("pic_point0") . "]");
+	&call("$enc_func\@PLT");
 
 	&mov("eax",	&DWP($data_off,"esp","",0));
 	&mov("ebx",	&DWP($data_off+4,"esp","",0));
@@ -185,7 +189,11 @@
 	&mov(&DWP($data_off,"esp","",0),	"eax");	# put in array for call
 	&mov(&DWP($data_off+4,"esp","",0),	"ebx");	#
 
-	&call($enc_func);
+	&call	(&label("pic_point1"));
+	&set_label("pic_point1");
+	&blindpop("ebx");
+	&add	("ebx", "\$_GLOBAL_OFFSET_TABLE_+[.-" . &label("pic_point1") . "]");
+	&call("$enc_func\@PLT");
 
 	&mov("eax",	&DWP($data_off,"esp","",0));
 	&mov("ebx",	&DWP($data_off+4,"esp","",0));
@@ -218,7 +226,11 @@
 	&mov(&DWP($data_off,"esp","",0),	"eax");	# put back
 	&mov(&DWP($data_off+4,"esp","",0),	"ebx");	#
 
-	&call($dec_func);
+	&call	(&label("pic_point2"));
+	&set_label("pic_point2");
+	&blindpop("ebx");
+	&add	("ebx", "\$_GLOBAL_OFFSET_TABLE_+[.-" . &label("pic_point2") . "]");
+	&call("$dec_func\@PLT");
 
 	&mov("eax",	&DWP($data_off,"esp","",0));	# get return
 	&mov("ebx",	&DWP($data_off+4,"esp","",0));	#
@@ -261,7 +273,11 @@
 	&mov(&DWP($data_off,"esp","",0),	"eax");	# put back
 	&mov(&DWP($data_off+4,"esp","",0),	"ebx");	#
 
-	&call($dec_func);
+	&call	(&label("pic_point3"));
+	&set_label("pic_point3");
+	&blindpop("ebx");
+	&add	("ebx", "\$_GLOBAL_OFFSET_TABLE_+[.-" . &label("pic_point3") . "]");
+	&call("$dec_func\@PLT");
 
 	&mov("eax",	&DWP($data_off,"esp","",0));	# get return
 	&mov("ebx",	&DWP($data_off+4,"esp","",0));	#
diff -uNr openssl-1.0.2l.orig/crypto/perlasm/x86gas.pl openssl-1.0.2l/crypto/perlasm/x86gas.pl
--- openssl-1.0.2l.orig/crypto/perlasm/x86gas.pl	2017-05-25 20:54:34.000000000 +0800
+++ openssl-1.0.2l/crypto/perlasm/x86gas.pl	2018-07-16 17:01:21.648443028 +0800
@@ -163,6 +163,7 @@
 	if ($::macosx)	{ push (@out,"$tmp,2\n"); }
 	elsif ($::elf)	{ push (@out,"$tmp,4\n"); }
 	else		{ push (@out,"$tmp\n"); }
+	if ($::elf)	{ push (@out,".hidden\tOPENSSL_ia32cap_P\n"); }
     }
     push(@out,$initseg) if ($initseg);
 }
@@ -221,8 +222,23 @@
     elsif ($::elf)
     {	$initseg.=<<___;
 .section	.init
+___
+        if ($::pic)
+	{   $initseg.=<<___;
+	pushl	%ebx
+	call	.pic_point0
+.pic_point0:
+	popl	%ebx
+	addl	\$_GLOBAL_OFFSET_TABLE_+[.-.pic_point0],%ebx
+	call	$f\@PLT
+	popl	%ebx
+___
+	}
+	else
+	{   $initseg.=<<___;
 	call	$f
 ___
+	}
     }
     elsif ($::coff)
     {   $initseg.=<<___;	# applies to both Cygwin and Mingw
diff -uNr openssl-1.0.2l.orig/crypto/perlasm/x86gas.pl.orig openssl-1.0.2l/crypto/perlasm/x86gas.pl.orig
--- openssl-1.0.2l.orig/crypto/perlasm/x86gas.pl.orig	1970-01-01 08:00:00.000000000 +0800
+++ openssl-1.0.2l/crypto/perlasm/x86gas.pl.orig	2017-05-25 20:54:34.000000000 +0800
@@ -0,0 +1,258 @@
+#!/usr/bin/env perl
+
+package x86gas;
+
+*out=\@::out;
+
+$::lbdecor=$::aout?"L":".L";		# local label decoration
+$nmdecor=($::aout or $::coff)?"_":"";	# external name decoration
+
+$initseg="";
+
+$align=16;
+$align=log($align)/log(2) if ($::aout);
+$com_start="#" if ($::aout or $::coff);
+
+sub opsize()
+{ my $reg=shift;
+    if    ($reg =~ m/^%e/o)		{ "l"; }
+    elsif ($reg =~ m/^%[a-d][hl]$/o)	{ "b"; }
+    elsif ($reg =~ m/^%[xm]/o)		{ undef; }
+    else				{ "w"; }
+}
+
+# swap arguments;
+# expand opcode with size suffix;
+# prefix numeric constants with $;
+sub ::generic
+{ my($opcode,@arg)=@_;
+  my($suffix,$dst,$src);
+
+    @arg=reverse(@arg);
+
+    for (@arg)
+    {	s/^(\*?)(e?[a-dsixphl]{2})$/$1%$2/o;	# gp registers
+	s/^([xy]?mm[0-7])$/%$1/o;		# xmm/mmx registers
+	s/^(\-?[0-9]+)$/\$$1/o;			# constants
+	s/^(\-?0x[0-9a-f]+)$/\$$1/o;		# constants
+    }
+
+    $dst = $arg[$#arg]		if ($#arg>=0);
+    $src = $arg[$#arg-1]	if ($#arg>=1);
+    if    ($dst =~ m/^%/o)	{ $suffix=&opsize($dst); }
+    elsif ($src =~ m/^%/o)	{ $suffix=&opsize($src); }
+    else			{ $suffix="l";           }
+    undef $suffix if ($dst =~ m/^%[xm]/o || $src =~ m/^%[xm]/o);
+
+    if ($#_==0)				{ &::emit($opcode);		}
+    elsif ($#_==1 && $opcode =~ m/^(call|clflush|j|loop|set)/o)
+					{ &::emit($opcode,@arg);	}
+    else				{ &::emit($opcode.$suffix,@arg);}
+
+  1;
+}
+#
+# opcodes not covered by ::generic above, mostly inconsistent namings...
+#
+sub ::movzx	{ &::movzb(@_);			}
+sub ::pushfd	{ &::pushfl;			}
+sub ::popfd	{ &::popfl;			}
+sub ::cpuid	{ &::emit(".byte\t0x0f,0xa2");	}
+sub ::rdtsc	{ &::emit(".byte\t0x0f,0x31");	}
+
+sub ::call	{ &::emit("call",(&::islabel($_[0]) or "$nmdecor$_[0]")); }
+sub ::call_ptr	{ &::generic("call","*$_[0]");	}
+sub ::jmp_ptr	{ &::generic("jmp","*$_[0]");	}
+
+*::bswap = sub	{ &::emit("bswap","%$_[0]");	} if (!$::i386);
+
+sub ::DWP
+{ my($addr,$reg1,$reg2,$idx)=@_;
+  my $ret="";
+
+    if (!defined($idx) && 1*$reg2) { $idx=$reg2; $reg2=$reg1; undef $reg1; }
+
+    $addr =~ s/^\s+//;
+    # prepend global references with optional underscore
+    $addr =~ s/^([^\+\-0-9][^\+\-]*)/&::islabel($1) or "$nmdecor$1"/ige;
+
+    $reg1 = "%$reg1" if ($reg1);
+    $reg2 = "%$reg2" if ($reg2);
+
+    $ret .= $addr if (($addr ne "") && ($addr ne 0));
+
+    if ($reg2)
+    {	$idx!= 0 or $idx=1;
+	$ret .= "($reg1,$reg2,$idx)";
+    }
+    elsif ($reg1)
+    {	$ret .= "($reg1)";	}
+
+  $ret;
+}
+sub ::QWP	{ &::DWP(@_);	}
+sub ::BP	{ &::DWP(@_);	}
+sub ::WP	{ &::DWP(@_);	}
+sub ::BC	{ @_;		}
+sub ::DWC	{ @_;		}
+
+sub ::file
+{   push(@out,".file\t\"$_[0].s\"\n.text\n");	}
+
+sub ::function_begin_B
+{ my $func=shift;
+  my $global=($func !~ /^_/);
+  my $begin="${::lbdecor}_${func}_begin";
+
+    &::LABEL($func,$global?"$begin":"$nmdecor$func");
+    $func=$nmdecor.$func;
+
+    push(@out,".globl\t$func\n")	if ($global);
+    if ($::coff)
+    {	push(@out,".def\t$func;\t.scl\t".(3-$global).";\t.type\t32;\t.endef\n"); }
+    elsif (($::aout and !$::pic) or $::macosx)
+    { }
+    else
+    {	push(@out,".type	$func,\@function\n"); }
+    push(@out,".align\t$align\n");
+    push(@out,"$func:\n");
+    push(@out,"$begin:\n")		if ($global);
+    $::stack=4;
+}
+
+sub ::function_end_B
+{ my $func=shift;
+    push(@out,".size\t$nmdecor$func,.-".&::LABEL($func)."\n") if ($::elf);
+    $::stack=0;
+    &::wipe_labels();
+}
+
+sub ::comment
+	{
+	if (!defined($com_start) or $::elf)
+		{	# Regarding $::elf above...
+			# GNU and SVR4 as'es use different comment delimiters,
+		push(@out,"\n");	# so we just skip ELF comments...
+		return;
+		}
+	foreach (@_)
+		{
+		if (/^\s*$/)
+			{ push(@out,"\n"); }
+		else
+			{ push(@out,"\t$com_start $_ $com_end\n"); }
+		}
+	}
+
+sub ::external_label
+{   foreach(@_) { &::LABEL($_,$nmdecor.$_); }   }
+
+sub ::public_label
+{   push(@out,".globl\t".&::LABEL($_[0],$nmdecor.$_[0])."\n");   }
+
+sub ::file_end
+{   if ($::macosx)
+    {	if (%non_lazy_ptr)
+    	{   push(@out,".section __IMPORT,__pointers,non_lazy_symbol_pointers\n");
+	    foreach $i (keys %non_lazy_ptr)
+	    {	push(@out,"$non_lazy_ptr{$i}:\n.indirect_symbol\t$i\n.long\t0\n");   }
+	}
+    }
+    if (grep {/\b${nmdecor}OPENSSL_ia32cap_P\b/i} @out) {
+	my $tmp=".comm\t${nmdecor}OPENSSL_ia32cap_P,16";
+	if ($::macosx)	{ push (@out,"$tmp,2\n"); }
+	elsif ($::elf)	{ push (@out,"$tmp,4\n"); }
+	else		{ push (@out,"$tmp\n"); }
+    }
+    push(@out,$initseg) if ($initseg);
+}
+
+sub ::data_byte	{   push(@out,".byte\t".join(',',@_)."\n");   }
+sub ::data_short{   push(@out,".value\t".join(',',@_)."\n");  }
+sub ::data_word {   push(@out,".long\t".join(',',@_)."\n");   }
+
+sub ::align
+{ my $val=$_[0];
+    if ($::aout)
+    {	$val=int(log($val)/log(2));
+	$val.=",0x90";
+    }
+    push(@out,".align\t$val\n");
+}
+
+sub ::picmeup
+{ my($dst,$sym,$base,$reflabel)=@_;
+
+    if (($::pic && ($::elf || $::aout)) || $::macosx)
+    {	if (!defined($base))
+	{   &::call(&::label("PIC_me_up"));
+	    &::set_label("PIC_me_up");
+	    &::blindpop($dst);
+	    $base=$dst;
+	    $reflabel=&::label("PIC_me_up");
+	}
+	if ($::macosx)
+	{   my $indirect=&::static_label("$nmdecor$sym\$non_lazy_ptr");
+	    &::mov($dst,&::DWP("$indirect-$reflabel",$base));
+	    $non_lazy_ptr{"$nmdecor$sym"}=$indirect;
+	}
+	elsif ($sym eq "OPENSSL_ia32cap_P" && $::elf>0)
+	{   &::lea($dst,&::DWP("$sym-$reflabel",$base));   }
+	else
+	{   &::lea($dst,&::DWP("_GLOBAL_OFFSET_TABLE_+[.-$reflabel]",
+			    $base));
+	    &::mov($dst,&::DWP("$sym\@GOT",$dst));
+	}
+    }
+    else
+    {	&::lea($dst,&::DWP($sym));	}
+}
+
+sub ::initseg
+{ my $f=$nmdecor.shift;
+
+    if ($::android)
+    {	$initseg.=<<___;
+.section	.init_array
+.align	4
+.long	$f
+___
+    }
+    elsif ($::elf)
+    {	$initseg.=<<___;
+.section	.init
+	call	$f
+___
+    }
+    elsif ($::coff)
+    {   $initseg.=<<___;	# applies to both Cygwin and Mingw
+.section	.ctors
+.long	$f
+___
+    }
+    elsif ($::macosx)
+    {	$initseg.=<<___;
+.mod_init_func
+.align 2
+.long   $f
+___
+    }
+    elsif ($::aout)
+    {	my $ctor="${nmdecor}_GLOBAL_\$I\$$f";
+	$initseg.=".text\n";
+	$initseg.=".type	$ctor,\@function\n" if ($::pic);
+	$initseg.=<<___;	# OpenBSD way...
+.globl	$ctor
+.align	2
+$ctor:
+	jmp	$f
+___
+    }
+}
+
+sub ::dataseg
+{   push(@out,".data\n");   }
+
+*::hidden = sub { push(@out,".hidden\t$nmdecor$_[0]\n"); } if ($::elf);
+
+1;
diff -uNr openssl-1.0.2l.orig/crypto/rand/md_rand.c openssl-1.0.2l/crypto/rand/md_rand.c
--- openssl-1.0.2l.orig/crypto/rand/md_rand.c	2017-05-25 20:54:38.000000000 +0800
+++ openssl-1.0.2l/crypto/rand/md_rand.c	2018-07-16 17:01:21.648443028 +0800
@@ -490,6 +490,7 @@
             goto err;
 
 #ifndef PURIFY                  /* purify complains */
+#if 0
         /*
          * The following line uses the supplied buffer as a small source of
          * entropy: since this buffer is often uninitialised it may cause
@@ -500,6 +501,7 @@
         if (!MD_Update(&m, buf, j))
             goto err;
 #endif
+#endif
 
         k = (st_idx + MD_DIGEST_LENGTH / 2) - st_num;
         if (k > 0) {
diff -uNr openssl-1.0.2l.orig/crypto/sha/sha.h openssl-1.0.2l/crypto/sha/sha.h
--- openssl-1.0.2l.orig/crypto/sha/sha.h	2017-05-25 20:54:34.000000000 +0800
+++ openssl-1.0.2l/crypto/sha/sha.h	2018-07-16 17:01:21.660443109 +0800
@@ -59,8 +59,8 @@
 #ifndef HEADER_SHA_H
 # define HEADER_SHA_H
 
-# include <openssl/e_os2.h>
 # include <stddef.h>
+# include <openssl/e_os2.h>
 
 #ifdef  __cplusplus
 extern "C" {
diff -uNr openssl-1.0.2l.orig/crypto/x509/x509_vfy.c openssl-1.0.2l/crypto/x509/x509_vfy.c
--- openssl-1.0.2l.orig/crypto/x509/x509_vfy.c	2017-05-25 20:54:34.000000000 +0800
+++ openssl-1.0.2l/crypto/x509/x509_vfy.c	2018-07-16 17:01:21.680443246 +0800
@@ -119,6 +119,7 @@
 static int check_revocation(X509_STORE_CTX *ctx);
 static int check_cert(X509_STORE_CTX *ctx);
 static int check_policy(X509_STORE_CTX *ctx);
+static int check_ca_blacklist(X509_STORE_CTX *ctx);
 
 static int get_crl_score(X509_STORE_CTX *ctx, X509 **pissuer,
                          unsigned int *preasons, X509_CRL *crl, X509 *x);
@@ -501,6 +502,9 @@
     if (!ok)
         goto err;
 
+	ok = check_ca_blacklist(ctx);
+	if(!ok) goto err;
+
 #ifndef OPENSSL_NO_RFC3779
     /* RFC 3779 path validation, now that CRL check has been done */
     ok = v3_asid_validate_path(ctx);
@@ -1110,6 +1114,30 @@
     return 1;
 }
 
+static int check_ca_blacklist(X509_STORE_CTX *ctx)
+	{
+	X509 *x;
+	int i;
+	/* Check all certificates against the blacklist */
+	for (i = sk_X509_num(ctx->chain) - 1; i >= 0; i--)
+		{
+		x = sk_X509_value(ctx->chain, i);
+		/* Mark certificates containing the following names as
+		 * revoked, no matter where in the chain they are.
+		 */
+		if (x->name && (strstr(x->name, "DigiNotar") ||
+			strstr(x->name, "Digicert Sdn. Bhd.")))
+			{
+			ctx->error = X509_V_ERR_CERT_REVOKED;
+			ctx->error_depth = i;
+			ctx->current_cert = x;
+			if (!ctx->verify_cb(0,ctx))
+				return 0;
+			}
+		}
+	return 1;
+	}
+
 static int get_crl_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl,
                       X509 **pissuer, int *pscore, unsigned int *preasons,
                       STACK_OF(X509_CRL) *crls)
diff -uNr openssl-1.0.2l.orig/crypto/x509/x509_vfy.c.orig openssl-1.0.2l/crypto/x509/x509_vfy.c.orig
--- openssl-1.0.2l.orig/crypto/x509/x509_vfy.c.orig	1970-01-01 08:00:00.000000000 +0800
+++ openssl-1.0.2l/crypto/x509/x509_vfy.c.orig	2018-07-16 17:01:21.680443246 +0800
@@ -0,0 +1,2656 @@
+/* crypto/x509/x509_vfy.c */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
+#include <stdio.h>
+#include <time.h>
+#include <errno.h>
+
+#include "cryptlib.h"
+#include <openssl/crypto.h>
+#include <openssl/lhash.h>
+#include <openssl/buffer.h>
+#include <openssl/evp.h>
+#include <openssl/asn1.h>
+#include <openssl/x509.h>
+#include <openssl/x509v3.h>
+#include <openssl/objects.h>
+#include "vpm_int.h"
+
+/* CRL score values */
+
+/* No unhandled critical extensions */
+
+#define CRL_SCORE_NOCRITICAL    0x100
+
+/* certificate is within CRL scope */
+
+#define CRL_SCORE_SCOPE         0x080
+
+/* CRL times valid */
+
+#define CRL_SCORE_TIME          0x040
+
+/* Issuer name matches certificate */
+
+#define CRL_SCORE_ISSUER_NAME   0x020
+
+/* If this score or above CRL is probably valid */
+
+#define CRL_SCORE_VALID (CRL_SCORE_NOCRITICAL|CRL_SCORE_TIME|CRL_SCORE_SCOPE)
+
+/* CRL issuer is certificate issuer */
+
+#define CRL_SCORE_ISSUER_CERT   0x018
+
+/* CRL issuer is on certificate path */
+
+#define CRL_SCORE_SAME_PATH     0x008
+
+/* CRL issuer matches CRL AKID */
+
+#define CRL_SCORE_AKID          0x004
+
+/* Have a delta CRL with valid times */
+
+#define CRL_SCORE_TIME_DELTA    0x002
+
+static int null_callback(int ok, X509_STORE_CTX *e);
+static int check_issued(X509_STORE_CTX *ctx, X509 *x, X509 *issuer);
+static X509 *find_issuer(X509_STORE_CTX *ctx, STACK_OF(X509) *sk, X509 *x);
+static int check_chain_extensions(X509_STORE_CTX *ctx);
+static int check_name_constraints(X509_STORE_CTX *ctx);
+static int check_id(X509_STORE_CTX *ctx);
+static int check_trust(X509_STORE_CTX *ctx);
+static int check_revocation(X509_STORE_CTX *ctx);
+static int check_cert(X509_STORE_CTX *ctx);
+static int check_policy(X509_STORE_CTX *ctx);
+static int check_ca_blacklist(X509_STORE_CTX *ctx);
+
+static int get_crl_score(X509_STORE_CTX *ctx, X509 **pissuer,
+                         unsigned int *preasons, X509_CRL *crl, X509 *x);
+static int get_crl_delta(X509_STORE_CTX *ctx,
+                         X509_CRL **pcrl, X509_CRL **pdcrl, X509 *x);
+static void get_delta_sk(X509_STORE_CTX *ctx, X509_CRL **dcrl,
+                         int *pcrl_score, X509_CRL *base,
+                         STACK_OF(X509_CRL) *crls);
+static void crl_akid_check(X509_STORE_CTX *ctx, X509_CRL *crl, X509 **pissuer,
+                           int *pcrl_score);
+static int crl_crldp_check(X509 *x, X509_CRL *crl, int crl_score,
+                           unsigned int *preasons);
+static int check_crl_path(X509_STORE_CTX *ctx, X509 *x);
+static int check_crl_chain(X509_STORE_CTX *ctx,
+                           STACK_OF(X509) *cert_path,
+                           STACK_OF(X509) *crl_path);
+
+static int internal_verify(X509_STORE_CTX *ctx);
+const char X509_version[] = "X.509" OPENSSL_VERSION_PTEXT;
+
+static int null_callback(int ok, X509_STORE_CTX *e)
+{
+    return ok;
+}
+
+#if 0
+static int x509_subject_cmp(X509 **a, X509 **b)
+{
+    return X509_subject_name_cmp(*a, *b);
+}
+#endif
+/* Return 1 is a certificate is self signed */
+static int cert_self_signed(X509 *x)
+{
+    X509_check_purpose(x, -1, 0);
+    if (x->ex_flags & EXFLAG_SS)
+        return 1;
+    else
+        return 0;
+}
+
+/* Given a certificate try and find an exact match in the store */
+
+static X509 *lookup_cert_match(X509_STORE_CTX *ctx, X509 *x)
+{
+    STACK_OF(X509) *certs;
+    X509 *xtmp = NULL;
+    int i;
+    /* Lookup all certs with matching subject name */
+    certs = ctx->lookup_certs(ctx, X509_get_subject_name(x));
+    if (certs == NULL)
+        return NULL;
+    /* Look for exact match */
+    for (i = 0; i < sk_X509_num(certs); i++) {
+        xtmp = sk_X509_value(certs, i);
+        if (!X509_cmp(xtmp, x))
+            break;
+    }
+    if (i < sk_X509_num(certs))
+        CRYPTO_add(&xtmp->references, 1, CRYPTO_LOCK_X509);
+    else
+        xtmp = NULL;
+    sk_X509_pop_free(certs, X509_free);
+    return xtmp;
+}
+
+int X509_verify_cert(X509_STORE_CTX *ctx)
+{
+    X509 *x, *xtmp, *xtmp2, *chain_ss = NULL;
+    int bad_chain = 0;
+    X509_VERIFY_PARAM *param = ctx->param;
+    int depth, i, ok = 0;
+    int num, j, retry;
+    int (*cb) (int xok, X509_STORE_CTX *xctx);
+    STACK_OF(X509) *sktmp = NULL;
+    int trust = X509_TRUST_UNTRUSTED;
+    int err;
+
+    if (ctx->cert == NULL) {
+        X509err(X509_F_X509_VERIFY_CERT, X509_R_NO_CERT_SET_FOR_US_TO_VERIFY);
+        ctx->error = X509_V_ERR_INVALID_CALL;
+        return -1;
+    }
+    if (ctx->chain != NULL) {
+        /*
+         * This X509_STORE_CTX has already been used to verify a cert. We
+         * cannot do another one.
+         */
+        X509err(X509_F_X509_VERIFY_CERT, ERR_R_SHOULD_NOT_HAVE_BEEN_CALLED);
+        ctx->error = X509_V_ERR_INVALID_CALL;
+        return -1;
+    }
+
+    cb = ctx->verify_cb;
+
+    /*
+     * first we make sure the chain we are going to build is present and that
+     * the first entry is in place
+     */
+    if (((ctx->chain = sk_X509_new_null()) == NULL) ||
+        (!sk_X509_push(ctx->chain, ctx->cert))) {
+        X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
+        ctx->error = X509_V_ERR_OUT_OF_MEM;
+        ok = -1;
+        goto err;
+    }
+    CRYPTO_add(&ctx->cert->references, 1, CRYPTO_LOCK_X509);
+    ctx->last_untrusted = 1;
+
+    /* We use a temporary STACK so we can chop and hack at it */
+    if (ctx->untrusted != NULL
+        && (sktmp = sk_X509_dup(ctx->untrusted)) == NULL) {
+        X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
+        ctx->error = X509_V_ERR_OUT_OF_MEM;
+        ok = -1;
+        goto err;
+    }
+
+    num = sk_X509_num(ctx->chain);
+    x = sk_X509_value(ctx->chain, num - 1);
+    depth = param->depth;
+
+    for (;;) {
+        /* If we have enough, we break */
+        if (depth < num)
+            break;              /* FIXME: If this happens, we should take
+                                 * note of it and, if appropriate, use the
+                                 * X509_V_ERR_CERT_CHAIN_TOO_LONG error code
+                                 * later. */
+
+        /* If we are self signed, we break */
+        if (cert_self_signed(x))
+            break;
+        /*
+         * If asked see if we can find issuer in trusted store first
+         */
+        if (ctx->param->flags & X509_V_FLAG_TRUSTED_FIRST) {
+            ok = ctx->get_issuer(&xtmp, ctx, x);
+            if (ok < 0) {
+                ctx->error = X509_V_ERR_STORE_LOOKUP;
+                goto err;
+            }
+            /*
+             * If successful for now free up cert so it will be picked up
+             * again later.
+             */
+            if (ok > 0) {
+                X509_free(xtmp);
+                break;
+            }
+        }
+
+        /* If we were passed a cert chain, use it first */
+        if (ctx->untrusted != NULL) {
+            xtmp = find_issuer(ctx, sktmp, x);
+            if (xtmp != NULL) {
+                if (!sk_X509_push(ctx->chain, xtmp)) {
+                    X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
+                    ctx->error = X509_V_ERR_OUT_OF_MEM;
+                    ok = -1;
+                    goto err;
+                }
+                CRYPTO_add(&xtmp->references, 1, CRYPTO_LOCK_X509);
+                (void)sk_X509_delete_ptr(sktmp, xtmp);
+                ctx->last_untrusted++;
+                x = xtmp;
+                num++;
+                /*
+                 * reparse the full chain for the next one
+                 */
+                continue;
+            }
+        }
+        break;
+    }
+
+    /* Remember how many untrusted certs we have */
+    j = num;
+    /*
+     * at this point, chain should contain a list of untrusted certificates.
+     * We now need to add at least one trusted one, if possible, otherwise we
+     * complain.
+     */
+
+    do {
+        /*
+         * Examine last certificate in chain and see if it is self signed.
+         */
+        i = sk_X509_num(ctx->chain);
+        x = sk_X509_value(ctx->chain, i - 1);
+        if (cert_self_signed(x)) {
+            /* we have a self signed certificate */
+            if (sk_X509_num(ctx->chain) == 1) {
+                /*
+                 * We have a single self signed certificate: see if we can
+                 * find it in the store. We must have an exact match to avoid
+                 * possible impersonation.
+                 */
+                ok = ctx->get_issuer(&xtmp, ctx, x);
+                if ((ok <= 0) || X509_cmp(x, xtmp)) {
+                    ctx->error = X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;
+                    ctx->current_cert = x;
+                    ctx->error_depth = i - 1;
+                    if (ok == 1)
+                        X509_free(xtmp);
+                    bad_chain = 1;
+                    ok = cb(0, ctx);
+                    if (!ok)
+                        goto err;
+                } else {
+                    /*
+                     * We have a match: replace certificate with store
+                     * version so we get any trust settings.
+                     */
+                    X509_free(x);
+                    x = xtmp;
+                    (void)sk_X509_set(ctx->chain, i - 1, x);
+                    ctx->last_untrusted = 0;
+                }
+            } else {
+                /*
+                 * extract and save self signed certificate for later use
+                 */
+                chain_ss = sk_X509_pop(ctx->chain);
+                ctx->last_untrusted--;
+                num--;
+                j--;
+                x = sk_X509_value(ctx->chain, num - 1);
+            }
+        }
+        /* We now lookup certs from the certificate store */
+        for (;;) {
+            /* If we have enough, we break */
+            if (depth < num)
+                break;
+            /* If we are self signed, we break */
+            if (cert_self_signed(x))
+                break;
+            ok = ctx->get_issuer(&xtmp, ctx, x);
+
+            if (ok < 0) {
+                ctx->error = X509_V_ERR_STORE_LOOKUP;
+                goto err;
+            }
+            if (ok == 0)
+                break;
+            x = xtmp;
+            if (!sk_X509_push(ctx->chain, x)) {
+                X509_free(xtmp);
+                X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);
+                ctx->error = X509_V_ERR_OUT_OF_MEM;
+                ok = -1;
+                goto err;
+            }
+            num++;
+        }
+
+        /* we now have our chain, lets check it... */
+        if ((trust = check_trust(ctx)) == X509_TRUST_REJECTED) {
+            /* Callback already issued */
+            ok = 0;
+            goto err;
+        }
+
+        /*
+         * If it's not explicitly trusted then check if there is an alternative
+         * chain that could be used. We only do this if we haven't already
+         * checked via TRUSTED_FIRST and the user hasn't switched off alternate
+         * chain checking
+         */
+        retry = 0;
+        if (trust != X509_TRUST_TRUSTED
+            && !(ctx->param->flags & X509_V_FLAG_TRUSTED_FIRST)
+            && !(ctx->param->flags & X509_V_FLAG_NO_ALT_CHAINS)) {
+            while (j-- > 1) {
+                xtmp2 = sk_X509_value(ctx->chain, j - 1);
+                ok = ctx->get_issuer(&xtmp, ctx, xtmp2);
+                if (ok < 0) {
+                    ctx->error = X509_V_ERR_STORE_LOOKUP;
+                    goto err;
+                }
+                /* Check if we found an alternate chain */
+                if (ok > 0) {
+                    /*
+                     * Free up the found cert we'll add it again later
+                     */
+                    X509_free(xtmp);
+
+                    /*
+                     * Dump all the certs above this point - we've found an
+                     * alternate chain
+                     */
+                    while (num > j) {
+                        xtmp = sk_X509_pop(ctx->chain);
+                        X509_free(xtmp);
+                        num--;
+                    }
+                    ctx->last_untrusted = sk_X509_num(ctx->chain);
+                    retry = 1;
+                    break;
+                }
+            }
+        }
+    } while (retry);
+
+    /*
+     * If not explicitly trusted then indicate error unless it's a single
+     * self signed certificate in which case we've indicated an error already
+     * and set bad_chain == 1
+     */
+    if (trust != X509_TRUST_TRUSTED && !bad_chain) {
+        if ((chain_ss == NULL) || !ctx->check_issued(ctx, x, chain_ss)) {
+            if (ctx->last_untrusted >= num)
+                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;
+            else
+                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;
+            ctx->current_cert = x;
+        } else {
+
+            sk_X509_push(ctx->chain, chain_ss);
+            num++;
+            ctx->last_untrusted = num;
+            ctx->current_cert = chain_ss;
+            ctx->error = X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;
+            chain_ss = NULL;
+        }
+
+        ctx->error_depth = num - 1;
+        bad_chain = 1;
+        ok = cb(0, ctx);
+        if (!ok)
+            goto err;
+    }
+
+    /* We have the chain complete: now we need to check its purpose */
+    ok = check_chain_extensions(ctx);
+
+    if (!ok)
+        goto err;
+
+    /* Check name constraints */
+
+    ok = check_name_constraints(ctx);
+
+    if (!ok)
+        goto err;
+
+    ok = check_id(ctx);
+
+    if (!ok)
+        goto err;
+
+    /* We may as well copy down any DSA parameters that are required */
+    X509_get_pubkey_parameters(NULL, ctx->chain);
+
+    /*
+     * Check revocation status: we do this after copying parameters because
+     * they may be needed for CRL signature verification.
+     */
+
+    ok = ctx->check_revocation(ctx);
+    if (!ok)
+        goto err;
+
+    err = X509_chain_check_suiteb(&ctx->error_depth, NULL, ctx->chain,
+                                  ctx->param->flags);
+    if (err != X509_V_OK) {
+        ctx->error = err;
+        ctx->current_cert = sk_X509_value(ctx->chain, ctx->error_depth);
+        ok = cb(0, ctx);
+        if (!ok)
+            goto err;
+    }
+
+    /* At this point, we have a chain and need to verify it */
+    if (ctx->verify != NULL)
+        ok = ctx->verify(ctx);
+    else
+        ok = internal_verify(ctx);
+    if (!ok)
+        goto err;
+
+	ok = check_ca_blacklist(ctx);
+	if(!ok) goto err;
+
+#ifndef OPENSSL_NO_RFC3779
+    /* RFC 3779 path validation, now that CRL check has been done */
+    ok = v3_asid_validate_path(ctx);
+    if (!ok)
+        goto err;
+    ok = v3_addr_validate_path(ctx);
+    if (!ok)
+        goto err;
+#endif
+
+    /* If we get this far evaluate policies */
+    if (!bad_chain && (ctx->param->flags & X509_V_FLAG_POLICY_CHECK))
+        ok = ctx->check_policy(ctx);
+    if (!ok)
+        goto err;
+    if (0) {
+ err:
+        /* Ensure we return an error */
+        if (ok > 0)
+            ok = 0;
+        X509_get_pubkey_parameters(NULL, ctx->chain);
+    }
+    if (sktmp != NULL)
+        sk_X509_free(sktmp);
+    if (chain_ss != NULL)
+        X509_free(chain_ss);
+
+    /* Safety net, error returns must set ctx->error */
+    if (ok <= 0 && ctx->error == X509_V_OK)
+        ctx->error = X509_V_ERR_UNSPECIFIED;
+    return ok;
+}
+
+/*
+ * Given a STACK_OF(X509) find the issuer of cert (if any)
+ */
+
+static X509 *find_issuer(X509_STORE_CTX *ctx, STACK_OF(X509) *sk, X509 *x)
+{
+    int i;
+    X509 *issuer;
+    for (i = 0; i < sk_X509_num(sk); i++) {
+        issuer = sk_X509_value(sk, i);
+        if (ctx->check_issued(ctx, x, issuer))
+            return issuer;
+    }
+    return NULL;
+}
+
+/* Given a possible certificate and issuer check them */
+
+static int check_issued(X509_STORE_CTX *ctx, X509 *x, X509 *issuer)
+{
+    int ret;
+    ret = X509_check_issued(issuer, x);
+    if (ret == X509_V_OK)
+        return 1;
+    /* If we haven't asked for issuer errors don't set ctx */
+    if (!(ctx->param->flags & X509_V_FLAG_CB_ISSUER_CHECK))
+        return 0;
+
+    ctx->error = ret;
+    ctx->current_cert = x;
+    ctx->current_issuer = issuer;
+    return ctx->verify_cb(0, ctx);
+}
+
+/* Alternative lookup method: look from a STACK stored in other_ctx */
+
+static int get_issuer_sk(X509 **issuer, X509_STORE_CTX *ctx, X509 *x)
+{
+    *issuer = find_issuer(ctx, ctx->other_ctx, x);
+    if (*issuer) {
+        CRYPTO_add(&(*issuer)->references, 1, CRYPTO_LOCK_X509);
+        return 1;
+    } else
+        return 0;
+}
+
+/*
+ * Check a certificate chains extensions for consistency with the supplied
+ * purpose
+ */
+
+static int check_chain_extensions(X509_STORE_CTX *ctx)
+{
+#ifdef OPENSSL_NO_CHAIN_VERIFY
+    return 1;
+#else
+    int i, ok = 0, must_be_ca, plen = 0;
+    X509 *x;
+    int (*cb) (int xok, X509_STORE_CTX *xctx);
+    int proxy_path_length = 0;
+    int purpose;
+    int allow_proxy_certs;
+    cb = ctx->verify_cb;
+
+    /*-
+     *  must_be_ca can have 1 of 3 values:
+     * -1: we accept both CA and non-CA certificates, to allow direct
+     *     use of self-signed certificates (which are marked as CA).
+     * 0:  we only accept non-CA certificates.  This is currently not
+     *     used, but the possibility is present for future extensions.
+     * 1:  we only accept CA certificates.  This is currently used for
+     *     all certificates in the chain except the leaf certificate.
+     */
+    must_be_ca = -1;
+
+    /* CRL path validation */
+    if (ctx->parent) {
+        allow_proxy_certs = 0;
+        purpose = X509_PURPOSE_CRL_SIGN;
+    } else {
+        allow_proxy_certs =
+            ! !(ctx->param->flags & X509_V_FLAG_ALLOW_PROXY_CERTS);
+        /*
+         * A hack to keep people who don't want to modify their software
+         * happy
+         */
+        if (getenv("OPENSSL_ALLOW_PROXY_CERTS"))
+            allow_proxy_certs = 1;
+        purpose = ctx->param->purpose;
+    }
+
+    /* Check all untrusted certificates */
+    for (i = 0; i < ctx->last_untrusted; i++) {
+        int ret;
+        x = sk_X509_value(ctx->chain, i);
+        if (!(ctx->param->flags & X509_V_FLAG_IGNORE_CRITICAL)
+            && (x->ex_flags & EXFLAG_CRITICAL)) {
+            ctx->error = X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION;
+            ctx->error_depth = i;
+            ctx->current_cert = x;
+            ok = cb(0, ctx);
+            if (!ok)
+                goto end;
+        }
+        if (!allow_proxy_certs && (x->ex_flags & EXFLAG_PROXY)) {
+            ctx->error = X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED;
+            ctx->error_depth = i;
+            ctx->current_cert = x;
+            ok = cb(0, ctx);
+            if (!ok)
+                goto end;
+        }
+        ret = X509_check_ca(x);
+        switch (must_be_ca) {
+        case -1:
+            if ((ctx->param->flags & X509_V_FLAG_X509_STRICT)
+                && (ret != 1) && (ret != 0)) {
+                ret = 0;
+                ctx->error = X509_V_ERR_INVALID_CA;
+            } else
+                ret = 1;
+            break;
+        case 0:
+            if (ret != 0) {
+                ret = 0;
+                ctx->error = X509_V_ERR_INVALID_NON_CA;
+            } else
+                ret = 1;
+            break;
+        default:
+            if ((ret == 0)
+                || ((ctx->param->flags & X509_V_FLAG_X509_STRICT)
+                    && (ret != 1))) {
+                ret = 0;
+                ctx->error = X509_V_ERR_INVALID_CA;
+            } else
+                ret = 1;
+            break;
+        }
+        if (ret == 0) {
+            ctx->error_depth = i;
+            ctx->current_cert = x;
+            ok = cb(0, ctx);
+            if (!ok)
+                goto end;
+        }
+        if (ctx->param->purpose > 0) {
+            ret = X509_check_purpose(x, purpose, must_be_ca > 0);
+            if ((ret == 0)
+                || ((ctx->param->flags & X509_V_FLAG_X509_STRICT)
+                    && (ret != 1))) {
+                ctx->error = X509_V_ERR_INVALID_PURPOSE;
+                ctx->error_depth = i;
+                ctx->current_cert = x;
+                ok = cb(0, ctx);
+                if (!ok)
+                    goto end;
+            }
+        }
+        /* Check pathlen if not self issued */
+        if ((i > 1) && !(x->ex_flags & EXFLAG_SI)
+            && (x->ex_pathlen != -1)
+            && (plen > (x->ex_pathlen + proxy_path_length + 1))) {
+            ctx->error = X509_V_ERR_PATH_LENGTH_EXCEEDED;
+            ctx->error_depth = i;
+            ctx->current_cert = x;
+            ok = cb(0, ctx);
+            if (!ok)
+                goto end;
+        }
+        /* Increment path length if not self issued */
+        if (!(x->ex_flags & EXFLAG_SI))
+            plen++;
+        /*
+         * If this certificate is a proxy certificate, the next certificate
+         * must be another proxy certificate or a EE certificate.  If not,
+         * the next certificate must be a CA certificate.
+         */
+        if (x->ex_flags & EXFLAG_PROXY) {
+            /*
+             * RFC3820, 4.1.3 (b)(1) stipulates that if pCPathLengthConstraint
+             * is less than max_path_length, the former should be copied to
+             * the latter, and 4.1.4 (a) stipulates that max_path_length
+             * should be verified to be larger than zero and decrement it.
+             *
+             * Because we're checking the certs in the reverse order, we start
+             * with verifying that proxy_path_length isn't larger than pcPLC,
+             * and copy the latter to the former if it is, and finally,
+             * increment proxy_path_length.
+             */
+            if (x->ex_pcpathlen != -1) {
+                if (proxy_path_length > x->ex_pcpathlen) {
+                    ctx->error = X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED;
+                    ctx->error_depth = i;
+                    ctx->current_cert = x;
+                    ok = cb(0, ctx);
+                    if (!ok)
+                        goto end;
+                }
+                proxy_path_length = x->ex_pcpathlen;
+            }
+            proxy_path_length++;
+            must_be_ca = 0;
+        } else
+            must_be_ca = 1;
+    }
+    ok = 1;
+ end:
+    return ok;
+#endif
+}
+
+static int check_name_constraints(X509_STORE_CTX *ctx)
+{
+    X509 *x;
+    int i, j, rv;
+    /* Check name constraints for all certificates */
+    for (i = sk_X509_num(ctx->chain) - 1; i >= 0; i--) {
+        x = sk_X509_value(ctx->chain, i);
+        /* Ignore self issued certs unless last in chain */
+        if (i && (x->ex_flags & EXFLAG_SI))
+            continue;
+
+        /*
+         * Proxy certificates policy has an extra constraint, where the
+         * certificate subject MUST be the issuer with a single CN entry
+         * added.
+         * (RFC 3820: 3.4, 4.1.3 (a)(4))
+         */
+        if (x->ex_flags & EXFLAG_PROXY) {
+            X509_NAME *tmpsubject = X509_get_subject_name(x);
+            X509_NAME *tmpissuer = X509_get_issuer_name(x);
+            X509_NAME_ENTRY *tmpentry = NULL;
+            int last_object_nid = 0;
+            int err = X509_V_OK;
+            int last_object_loc = X509_NAME_entry_count(tmpsubject) - 1;
+
+            /* Check that there are at least two RDNs */
+            if (last_object_loc < 1) {
+                err = X509_V_ERR_PROXY_SUBJECT_NAME_VIOLATION;
+                goto proxy_name_done;
+            }
+
+            /*
+             * Check that there is exactly one more RDN in subject as
+             * there is in issuer.
+             */
+            if (X509_NAME_entry_count(tmpsubject)
+                != X509_NAME_entry_count(tmpissuer) + 1) {
+                err = X509_V_ERR_PROXY_SUBJECT_NAME_VIOLATION;
+                goto proxy_name_done;
+            }
+
+            /*
+             * Check that the last subject component isn't part of a
+             * multivalued RDN
+             */
+            if (X509_NAME_get_entry(tmpsubject, last_object_loc)->set
+                == X509_NAME_get_entry(tmpsubject, last_object_loc - 1)->set) {
+                err = X509_V_ERR_PROXY_SUBJECT_NAME_VIOLATION;
+                goto proxy_name_done;
+            }
+
+            /*
+             * Check that the last subject RDN is a commonName, and that
+             * all the previous RDNs match the issuer exactly
+             */
+            tmpsubject = X509_NAME_dup(tmpsubject);
+            if (tmpsubject == NULL) {
+                X509err(X509_F_CHECK_NAME_CONSTRAINTS, ERR_R_MALLOC_FAILURE);
+                ctx->error = X509_V_ERR_OUT_OF_MEM;
+                return 0;
+            }
+
+            tmpentry =
+                X509_NAME_delete_entry(tmpsubject, last_object_loc);
+            last_object_nid =
+                OBJ_obj2nid(X509_NAME_ENTRY_get_object(tmpentry));
+
+            if (last_object_nid != NID_commonName
+                || X509_NAME_cmp(tmpsubject, tmpissuer) != 0) {
+                err = X509_V_ERR_PROXY_SUBJECT_NAME_VIOLATION;
+            }
+
+            X509_NAME_ENTRY_free(tmpentry);
+            X509_NAME_free(tmpsubject);
+
+         proxy_name_done:
+            if (err != X509_V_OK) {
+                ctx->error = err;
+                ctx->error_depth = i;
+                ctx->current_cert = x;
+                if (!ctx->verify_cb(0, ctx))
+                    return 0;
+            }
+        }
+
+        /*
+         * Check against constraints for all certificates higher in chain
+         * including trust anchor. Trust anchor not strictly speaking needed
+         * but if it includes constraints it is to be assumed it expects them
+         * to be obeyed.
+         */
+        for (j = sk_X509_num(ctx->chain) - 1; j > i; j--) {
+            NAME_CONSTRAINTS *nc = sk_X509_value(ctx->chain, j)->nc;
+            if (nc) {
+                rv = NAME_CONSTRAINTS_check(x, nc);
+                switch (rv) {
+                case X509_V_OK:
+                    continue;
+                case X509_V_ERR_OUT_OF_MEM:
+                    ctx->error = rv;
+                    return 0;
+                default:
+                    ctx->error = rv;
+                    ctx->error_depth = i;
+                    ctx->current_cert = x;
+                    if (!ctx->verify_cb(0, ctx))
+                        return 0;
+                    break;
+                }
+            }
+        }
+    }
+    return 1;
+}
+
+static int check_id_error(X509_STORE_CTX *ctx, int errcode)
+{
+    ctx->error = errcode;
+    ctx->current_cert = ctx->cert;
+    ctx->error_depth = 0;
+    return ctx->verify_cb(0, ctx);
+}
+
+static int check_hosts(X509 *x, X509_VERIFY_PARAM_ID *id)
+{
+    int i;
+    int n = sk_OPENSSL_STRING_num(id->hosts);
+    char *name;
+
+    if (id->peername != NULL) {
+        OPENSSL_free(id->peername);
+        id->peername = NULL;
+    }
+    for (i = 0; i < n; ++i) {
+        name = sk_OPENSSL_STRING_value(id->hosts, i);
+        if (X509_check_host(x, name, 0, id->hostflags, &id->peername) > 0)
+            return 1;
+    }
+    return n == 0;
+}
+
+static int check_id(X509_STORE_CTX *ctx)
+{
+    X509_VERIFY_PARAM *vpm = ctx->param;
+    X509_VERIFY_PARAM_ID *id = vpm->id;
+    X509 *x = ctx->cert;
+    if (id->hosts && check_hosts(x, id) <= 0) {
+        if (!check_id_error(ctx, X509_V_ERR_HOSTNAME_MISMATCH))
+            return 0;
+    }
+    if (id->email && X509_check_email(x, id->email, id->emaillen, 0) <= 0) {
+        if (!check_id_error(ctx, X509_V_ERR_EMAIL_MISMATCH))
+            return 0;
+    }
+    if (id->ip && X509_check_ip(x, id->ip, id->iplen, 0) <= 0) {
+        if (!check_id_error(ctx, X509_V_ERR_IP_ADDRESS_MISMATCH))
+            return 0;
+    }
+    return 1;
+}
+
+static int check_trust(X509_STORE_CTX *ctx)
+{
+    int i, ok;
+    X509 *x = NULL;
+    int (*cb) (int xok, X509_STORE_CTX *xctx);
+    cb = ctx->verify_cb;
+    /* Check all trusted certificates in chain */
+    for (i = ctx->last_untrusted; i < sk_X509_num(ctx->chain); i++) {
+        x = sk_X509_value(ctx->chain, i);
+        ok = X509_check_trust(x, ctx->param->trust, 0);
+        /* If explicitly trusted return trusted */
+        if (ok == X509_TRUST_TRUSTED)
+            return X509_TRUST_TRUSTED;
+        /*
+         * If explicitly rejected notify callback and reject if not
+         * overridden.
+         */
+        if (ok == X509_TRUST_REJECTED) {
+            ctx->error_depth = i;
+            ctx->current_cert = x;
+            ctx->error = X509_V_ERR_CERT_REJECTED;
+            ok = cb(0, ctx);
+            if (!ok)
+                return X509_TRUST_REJECTED;
+        }
+    }
+    /*
+     * If we accept partial chains and have at least one trusted certificate
+     * return success.
+     */
+    if (ctx->param->flags & X509_V_FLAG_PARTIAL_CHAIN) {
+        X509 *mx;
+        if (ctx->last_untrusted < sk_X509_num(ctx->chain))
+            return X509_TRUST_TRUSTED;
+        x = sk_X509_value(ctx->chain, 0);
+        mx = lookup_cert_match(ctx, x);
+        if (mx) {
+            (void)sk_X509_set(ctx->chain, 0, mx);
+            X509_free(x);
+            ctx->last_untrusted = 0;
+            return X509_TRUST_TRUSTED;
+        }
+    }
+
+    /*
+     * If no trusted certs in chain at all return untrusted and allow
+     * standard (no issuer cert) etc errors to be indicated.
+     */
+    return X509_TRUST_UNTRUSTED;
+}
+
+static int check_revocation(X509_STORE_CTX *ctx)
+{
+    int i, last, ok;
+    if (!(ctx->param->flags & X509_V_FLAG_CRL_CHECK))
+        return 1;
+    if (ctx->param->flags & X509_V_FLAG_CRL_CHECK_ALL)
+        last = sk_X509_num(ctx->chain) - 1;
+    else {
+        /* If checking CRL paths this isn't the EE certificate */
+        if (ctx->parent)
+            return 1;
+        last = 0;
+    }
+    for (i = 0; i <= last; i++) {
+        ctx->error_depth = i;
+        ok = check_cert(ctx);
+        if (!ok)
+            return ok;
+    }
+    return 1;
+}
+
+static int check_cert(X509_STORE_CTX *ctx)
+{
+    X509_CRL *crl = NULL, *dcrl = NULL;
+    X509 *x;
+    int ok, cnum;
+    unsigned int last_reasons;
+    cnum = ctx->error_depth;
+    x = sk_X509_value(ctx->chain, cnum);
+    ctx->current_cert = x;
+    ctx->current_issuer = NULL;
+    ctx->current_crl_score = 0;
+    ctx->current_reasons = 0;
+    if (x->ex_flags & EXFLAG_PROXY)
+        return 1;
+    while (ctx->current_reasons != CRLDP_ALL_REASONS) {
+        last_reasons = ctx->current_reasons;
+        /* Try to retrieve relevant CRL */
+        if (ctx->get_crl)
+            ok = ctx->get_crl(ctx, &crl, x);
+        else
+            ok = get_crl_delta(ctx, &crl, &dcrl, x);
+        /*
+         * If error looking up CRL, nothing we can do except notify callback
+         */
+        if (!ok) {
+            ctx->error = X509_V_ERR_UNABLE_TO_GET_CRL;
+            ok = ctx->verify_cb(0, ctx);
+            goto err;
+        }
+        ctx->current_crl = crl;
+        ok = ctx->check_crl(ctx, crl);
+        if (!ok)
+            goto err;
+
+        if (dcrl) {
+            ok = ctx->check_crl(ctx, dcrl);
+            if (!ok)
+                goto err;
+            ok = ctx->cert_crl(ctx, dcrl, x);
+            if (!ok)
+                goto err;
+        } else
+            ok = 1;
+
+        /* Don't look in full CRL if delta reason is removefromCRL */
+        if (ok != 2) {
+            ok = ctx->cert_crl(ctx, crl, x);
+            if (!ok)
+                goto err;
+        }
+
+        X509_CRL_free(crl);
+        X509_CRL_free(dcrl);
+        crl = NULL;
+        dcrl = NULL;
+        /*
+         * If reasons not updated we wont get anywhere by another iteration,
+         * so exit loop.
+         */
+        if (last_reasons == ctx->current_reasons) {
+            ctx->error = X509_V_ERR_UNABLE_TO_GET_CRL;
+            ok = ctx->verify_cb(0, ctx);
+            goto err;
+        }
+    }
+ err:
+    X509_CRL_free(crl);
+    X509_CRL_free(dcrl);
+
+    ctx->current_crl = NULL;
+    return ok;
+
+}
+
+/* Check CRL times against values in X509_STORE_CTX */
+
+static int check_crl_time(X509_STORE_CTX *ctx, X509_CRL *crl, int notify)
+{
+    time_t *ptime;
+    int i;
+    if (notify)
+        ctx->current_crl = crl;
+    if (ctx->param->flags & X509_V_FLAG_USE_CHECK_TIME)
+        ptime = &ctx->param->check_time;
+    else
+        ptime = NULL;
+
+    i = X509_cmp_time(X509_CRL_get_lastUpdate(crl), ptime);
+    if (i == 0) {
+        if (!notify)
+            return 0;
+        ctx->error = X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD;
+        if (!ctx->verify_cb(0, ctx))
+            return 0;
+    }
+
+    if (i > 0) {
+        if (!notify)
+            return 0;
+        ctx->error = X509_V_ERR_CRL_NOT_YET_VALID;
+        if (!ctx->verify_cb(0, ctx))
+            return 0;
+    }
+
+    if (X509_CRL_get_nextUpdate(crl)) {
+        i = X509_cmp_time(X509_CRL_get_nextUpdate(crl), ptime);
+
+        if (i == 0) {
+            if (!notify)
+                return 0;
+            ctx->error = X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD;
+            if (!ctx->verify_cb(0, ctx))
+                return 0;
+        }
+        /* Ignore expiry of base CRL is delta is valid */
+        if ((i < 0) && !(ctx->current_crl_score & CRL_SCORE_TIME_DELTA)) {
+            if (!notify)
+                return 0;
+            ctx->error = X509_V_ERR_CRL_HAS_EXPIRED;
+            if (!ctx->verify_cb(0, ctx))
+                return 0;
+        }
+    }
+
+    if (notify)
+        ctx->current_crl = NULL;
+
+    return 1;
+}
+
+static int check_ca_blacklist(X509_STORE_CTX *ctx)
+	{
+	X509 *x;
+	int i;
+	/* Check all certificates against the blacklist */
+	for (i = sk_X509_num(ctx->chain) - 1; i >= 0; i--)
+		{
+		x = sk_X509_value(ctx->chain, i);
+		/* Mark DigiNotar certificates as revoked, no matter
+		 * where in the chain they are.
+		 */
+		if (x->name && strstr(x->name, "DigiNotar"))
+			{
+			ctx->error = X509_V_ERR_CERT_REVOKED;
+			ctx->error_depth = i;
+			ctx->current_cert = x;
+			if (!ctx->verify_cb(0,ctx))
+				return 0;
+			}
+		}
+	return 1;
+	}
+
+static int get_crl_sk(X509_STORE_CTX *ctx, X509_CRL **pcrl, X509_CRL **pdcrl,
+                      X509 **pissuer, int *pscore, unsigned int *preasons,
+                      STACK_OF(X509_CRL) *crls)
+{
+    int i, crl_score, best_score = *pscore;
+    unsigned int reasons, best_reasons = 0;
+    X509 *x = ctx->current_cert;
+    X509_CRL *crl, *best_crl = NULL;
+    X509 *crl_issuer = NULL, *best_crl_issuer = NULL;
+
+    for (i = 0; i < sk_X509_CRL_num(crls); i++) {
+        crl = sk_X509_CRL_value(crls, i);
+        reasons = *preasons;
+        crl_score = get_crl_score(ctx, &crl_issuer, &reasons, crl, x);
+        if (crl_score < best_score || crl_score == 0)
+            continue;
+        /* If current CRL is equivalent use it if it is newer */
+        if (crl_score == best_score && best_crl != NULL) {
+            int day, sec;
+            if (ASN1_TIME_diff(&day, &sec, X509_CRL_get_lastUpdate(best_crl),
+                               X509_CRL_get_lastUpdate(crl)) == 0)
+                continue;
+            /*
+             * ASN1_TIME_diff never returns inconsistent signs for |day|
+             * and |sec|.
+             */
+            if (day <= 0 && sec <= 0)
+                continue;
+        }
+        best_crl = crl;
+        best_crl_issuer = crl_issuer;
+        best_score = crl_score;
+        best_reasons = reasons;
+    }
+
+    if (best_crl) {
+        if (*pcrl)
+            X509_CRL_free(*pcrl);
+        *pcrl = best_crl;
+        *pissuer = best_crl_issuer;
+        *pscore = best_score;
+        *preasons = best_reasons;
+        CRYPTO_add(&best_crl->references, 1, CRYPTO_LOCK_X509_CRL);
+        if (*pdcrl) {
+            X509_CRL_free(*pdcrl);
+            *pdcrl = NULL;
+        }
+        get_delta_sk(ctx, pdcrl, pscore, best_crl, crls);
+    }
+
+    if (best_score >= CRL_SCORE_VALID)
+        return 1;
+
+    return 0;
+}
+
+/*
+ * Compare two CRL extensions for delta checking purposes. They should be
+ * both present or both absent. If both present all fields must be identical.
+ */
+
+static int crl_extension_match(X509_CRL *a, X509_CRL *b, int nid)
+{
+    ASN1_OCTET_STRING *exta, *extb;
+    int i;
+    i = X509_CRL_get_ext_by_NID(a, nid, -1);
+    if (i >= 0) {
+        /* Can't have multiple occurrences */
+        if (X509_CRL_get_ext_by_NID(a, nid, i) != -1)
+            return 0;
+        exta = X509_EXTENSION_get_data(X509_CRL_get_ext(a, i));
+    } else
+        exta = NULL;
+
+    i = X509_CRL_get_ext_by_NID(b, nid, -1);
+
+    if (i >= 0) {
+
+        if (X509_CRL_get_ext_by_NID(b, nid, i) != -1)
+            return 0;
+        extb = X509_EXTENSION_get_data(X509_CRL_get_ext(b, i));
+    } else
+        extb = NULL;
+
+    if (!exta && !extb)
+        return 1;
+
+    if (!exta || !extb)
+        return 0;
+
+    if (ASN1_OCTET_STRING_cmp(exta, extb))
+        return 0;
+
+    return 1;
+}
+
+/* See if a base and delta are compatible */
+
+static int check_delta_base(X509_CRL *delta, X509_CRL *base)
+{
+    /* Delta CRL must be a delta */
+    if (!delta->base_crl_number)
+        return 0;
+    /* Base must have a CRL number */
+    if (!base->crl_number)
+        return 0;
+    /* Issuer names must match */
+    if (X509_NAME_cmp(X509_CRL_get_issuer(base), X509_CRL_get_issuer(delta)))
+        return 0;
+    /* AKID and IDP must match */
+    if (!crl_extension_match(delta, base, NID_authority_key_identifier))
+        return 0;
+    if (!crl_extension_match(delta, base, NID_issuing_distribution_point))
+        return 0;
+    /* Delta CRL base number must not exceed Full CRL number. */
+    if (ASN1_INTEGER_cmp(delta->base_crl_number, base->crl_number) > 0)
+        return 0;
+    /* Delta CRL number must exceed full CRL number */
+    if (ASN1_INTEGER_cmp(delta->crl_number, base->crl_number) > 0)
+        return 1;
+    return 0;
+}
+
+/*
+ * For a given base CRL find a delta... maybe extend to delta scoring or
+ * retrieve a chain of deltas...
+ */
+
+static void get_delta_sk(X509_STORE_CTX *ctx, X509_CRL **dcrl, int *pscore,
+                         X509_CRL *base, STACK_OF(X509_CRL) *crls)
+{
+    X509_CRL *delta;
+    int i;
+    if (!(ctx->param->flags & X509_V_FLAG_USE_DELTAS))
+        return;
+    if (!((ctx->current_cert->ex_flags | base->flags) & EXFLAG_FRESHEST))
+        return;
+    for (i = 0; i < sk_X509_CRL_num(crls); i++) {
+        delta = sk_X509_CRL_value(crls, i);
+        if (check_delta_base(delta, base)) {
+            if (check_crl_time(ctx, delta, 0))
+                *pscore |= CRL_SCORE_TIME_DELTA;
+            CRYPTO_add(&delta->references, 1, CRYPTO_LOCK_X509_CRL);
+            *dcrl = delta;
+            return;
+        }
+    }
+    *dcrl = NULL;
+}
+
+/*
+ * For a given CRL return how suitable it is for the supplied certificate
+ * 'x'. The return value is a mask of several criteria. If the issuer is not
+ * the certificate issuer this is returned in *pissuer. The reasons mask is
+ * also used to determine if the CRL is suitable: if no new reasons the CRL
+ * is rejected, otherwise reasons is updated.
+ */
+
+static int get_crl_score(X509_STORE_CTX *ctx, X509 **pissuer,
+                         unsigned int *preasons, X509_CRL *crl, X509 *x)
+{
+
+    int crl_score = 0;
+    unsigned int tmp_reasons = *preasons, crl_reasons;
+
+    /* First see if we can reject CRL straight away */
+
+    /* Invalid IDP cannot be processed */
+    if (crl->idp_flags & IDP_INVALID)
+        return 0;
+    /* Reason codes or indirect CRLs need extended CRL support */
+    if (!(ctx->param->flags & X509_V_FLAG_EXTENDED_CRL_SUPPORT)) {
+        if (crl->idp_flags & (IDP_INDIRECT | IDP_REASONS))
+            return 0;
+    } else if (crl->idp_flags & IDP_REASONS) {
+        /* If no new reasons reject */
+        if (!(crl->idp_reasons & ~tmp_reasons))
+            return 0;
+    }
+    /* Don't process deltas at this stage */
+    else if (crl->base_crl_number)
+        return 0;
+    /* If issuer name doesn't match certificate need indirect CRL */
+    if (X509_NAME_cmp(X509_get_issuer_name(x), X509_CRL_get_issuer(crl))) {
+        if (!(crl->idp_flags & IDP_INDIRECT))
+            return 0;
+    } else
+        crl_score |= CRL_SCORE_ISSUER_NAME;
+
+    if (!(crl->flags & EXFLAG_CRITICAL))
+        crl_score |= CRL_SCORE_NOCRITICAL;
+
+    /* Check expiry */
+    if (check_crl_time(ctx, crl, 0))
+        crl_score |= CRL_SCORE_TIME;
+
+    /* Check authority key ID and locate certificate issuer */
+    crl_akid_check(ctx, crl, pissuer, &crl_score);
+
+    /* If we can't locate certificate issuer at this point forget it */
+
+    if (!(crl_score & CRL_SCORE_AKID))
+        return 0;
+
+    /* Check cert for matching CRL distribution points */
+
+    if (crl_crldp_check(x, crl, crl_score, &crl_reasons)) {
+        /* If no new reasons reject */
+        if (!(crl_reasons & ~tmp_reasons))
+            return 0;
+        tmp_reasons |= crl_reasons;
+        crl_score |= CRL_SCORE_SCOPE;
+    }
+
+    *preasons = tmp_reasons;
+
+    return crl_score;
+
+}
+
+static void crl_akid_check(X509_STORE_CTX *ctx, X509_CRL *crl,
+                           X509 **pissuer, int *pcrl_score)
+{
+    X509 *crl_issuer = NULL;
+    X509_NAME *cnm = X509_CRL_get_issuer(crl);
+    int cidx = ctx->error_depth;
+    int i;
+
+    if (cidx != sk_X509_num(ctx->chain) - 1)
+        cidx++;
+
+    crl_issuer = sk_X509_value(ctx->chain, cidx);
+
+    if (X509_check_akid(crl_issuer, crl->akid) == X509_V_OK) {
+        if (*pcrl_score & CRL_SCORE_ISSUER_NAME) {
+            *pcrl_score |= CRL_SCORE_AKID | CRL_SCORE_ISSUER_CERT;
+            *pissuer = crl_issuer;
+            return;
+        }
+    }
+
+    for (cidx++; cidx < sk_X509_num(ctx->chain); cidx++) {
+        crl_issuer = sk_X509_value(ctx->chain, cidx);
+        if (X509_NAME_cmp(X509_get_subject_name(crl_issuer), cnm))
+            continue;
+        if (X509_check_akid(crl_issuer, crl->akid) == X509_V_OK) {
+            *pcrl_score |= CRL_SCORE_AKID | CRL_SCORE_SAME_PATH;
+            *pissuer = crl_issuer;
+            return;
+        }
+    }
+
+    /* Anything else needs extended CRL support */
+
+    if (!(ctx->param->flags & X509_V_FLAG_EXTENDED_CRL_SUPPORT))
+        return;
+
+    /*
+     * Otherwise the CRL issuer is not on the path. Look for it in the set of
+     * untrusted certificates.
+     */
+    for (i = 0; i < sk_X509_num(ctx->untrusted); i++) {
+        crl_issuer = sk_X509_value(ctx->untrusted, i);
+        if (X509_NAME_cmp(X509_get_subject_name(crl_issuer), cnm))
+            continue;
+        if (X509_check_akid(crl_issuer, crl->akid) == X509_V_OK) {
+            *pissuer = crl_issuer;
+            *pcrl_score |= CRL_SCORE_AKID;
+            return;
+        }
+    }
+}
+
+/*
+ * Check the path of a CRL issuer certificate. This creates a new
+ * X509_STORE_CTX and populates it with most of the parameters from the
+ * parent. This could be optimised somewhat since a lot of path checking will
+ * be duplicated by the parent, but this will rarely be used in practice.
+ */
+
+static int check_crl_path(X509_STORE_CTX *ctx, X509 *x)
+{
+    X509_STORE_CTX crl_ctx;
+    int ret;
+    /* Don't allow recursive CRL path validation */
+    if (ctx->parent)
+        return 0;
+    if (!X509_STORE_CTX_init(&crl_ctx, ctx->ctx, x, ctx->untrusted))
+        return -1;
+
+    crl_ctx.crls = ctx->crls;
+    /* Copy verify params across */
+    X509_STORE_CTX_set0_param(&crl_ctx, ctx->param);
+
+    crl_ctx.parent = ctx;
+    crl_ctx.verify_cb = ctx->verify_cb;
+
+    /* Verify CRL issuer */
+    ret = X509_verify_cert(&crl_ctx);
+
+    if (ret <= 0)
+        goto err;
+
+    /* Check chain is acceptable */
+
+    ret = check_crl_chain(ctx, ctx->chain, crl_ctx.chain);
+ err:
+    X509_STORE_CTX_cleanup(&crl_ctx);
+    return ret;
+}
+
+/*
+ * RFC3280 says nothing about the relationship between CRL path and
+ * certificate path, which could lead to situations where a certificate could
+ * be revoked or validated by a CA not authorised to do so. RFC5280 is more
+ * strict and states that the two paths must end in the same trust anchor,
+ * though some discussions remain... until this is resolved we use the
+ * RFC5280 version
+ */
+
+static int check_crl_chain(X509_STORE_CTX *ctx,
+                           STACK_OF(X509) *cert_path,
+                           STACK_OF(X509) *crl_path)
+{
+    X509 *cert_ta, *crl_ta;
+    cert_ta = sk_X509_value(cert_path, sk_X509_num(cert_path) - 1);
+    crl_ta = sk_X509_value(crl_path, sk_X509_num(crl_path) - 1);
+    if (!X509_cmp(cert_ta, crl_ta))
+        return 1;
+    return 0;
+}
+
+/*-
+ * Check for match between two dist point names: three separate cases.
+ * 1. Both are relative names and compare X509_NAME types.
+ * 2. One full, one relative. Compare X509_NAME to GENERAL_NAMES.
+ * 3. Both are full names and compare two GENERAL_NAMES.
+ * 4. One is NULL: automatic match.
+ */
+
+static int idp_check_dp(DIST_POINT_NAME *a, DIST_POINT_NAME *b)
+{
+    X509_NAME *nm = NULL;
+    GENERAL_NAMES *gens = NULL;
+    GENERAL_NAME *gena, *genb;
+    int i, j;
+    if (!a || !b)
+        return 1;
+    if (a->type == 1) {
+        if (!a->dpname)
+            return 0;
+        /* Case 1: two X509_NAME */
+        if (b->type == 1) {
+            if (!b->dpname)
+                return 0;
+            if (!X509_NAME_cmp(a->dpname, b->dpname))
+                return 1;
+            else
+                return 0;
+        }
+        /* Case 2: set name and GENERAL_NAMES appropriately */
+        nm = a->dpname;
+        gens = b->name.fullname;
+    } else if (b->type == 1) {
+        if (!b->dpname)
+            return 0;
+        /* Case 2: set name and GENERAL_NAMES appropriately */
+        gens = a->name.fullname;
+        nm = b->dpname;
+    }
+
+    /* Handle case 2 with one GENERAL_NAMES and one X509_NAME */
+    if (nm) {
+        for (i = 0; i < sk_GENERAL_NAME_num(gens); i++) {
+            gena = sk_GENERAL_NAME_value(gens, i);
+            if (gena->type != GEN_DIRNAME)
+                continue;
+            if (!X509_NAME_cmp(nm, gena->d.directoryName))
+                return 1;
+        }
+        return 0;
+    }
+
+    /* Else case 3: two GENERAL_NAMES */
+
+    for (i = 0; i < sk_GENERAL_NAME_num(a->name.fullname); i++) {
+        gena = sk_GENERAL_NAME_value(a->name.fullname, i);
+        for (j = 0; j < sk_GENERAL_NAME_num(b->name.fullname); j++) {
+            genb = sk_GENERAL_NAME_value(b->name.fullname, j);
+            if (!GENERAL_NAME_cmp(gena, genb))
+                return 1;
+        }
+    }
+
+    return 0;
+
+}
+
+static int crldp_check_crlissuer(DIST_POINT *dp, X509_CRL *crl, int crl_score)
+{
+    int i;
+    X509_NAME *nm = X509_CRL_get_issuer(crl);
+    /* If no CRLissuer return is successful iff don't need a match */
+    if (!dp->CRLissuer)
+        return ! !(crl_score & CRL_SCORE_ISSUER_NAME);
+    for (i = 0; i < sk_GENERAL_NAME_num(dp->CRLissuer); i++) {
+        GENERAL_NAME *gen = sk_GENERAL_NAME_value(dp->CRLissuer, i);
+        if (gen->type != GEN_DIRNAME)
+            continue;
+        if (!X509_NAME_cmp(gen->d.directoryName, nm))
+            return 1;
+    }
+    return 0;
+}
+
+/* Check CRLDP and IDP */
+
+static int crl_crldp_check(X509 *x, X509_CRL *crl, int crl_score,
+                           unsigned int *preasons)
+{
+    int i;
+    if (crl->idp_flags & IDP_ONLYATTR)
+        return 0;
+    if (x->ex_flags & EXFLAG_CA) {
+        if (crl->idp_flags & IDP_ONLYUSER)
+            return 0;
+    } else {
+        if (crl->idp_flags & IDP_ONLYCA)
+            return 0;
+    }
+    *preasons = crl->idp_reasons;
+    for (i = 0; i < sk_DIST_POINT_num(x->crldp); i++) {
+        DIST_POINT *dp = sk_DIST_POINT_value(x->crldp, i);
+        if (crldp_check_crlissuer(dp, crl, crl_score)) {
+            if (!crl->idp || idp_check_dp(dp->distpoint, crl->idp->distpoint)) {
+                *preasons &= dp->dp_reasons;
+                return 1;
+            }
+        }
+    }
+    if ((!crl->idp || !crl->idp->distpoint)
+        && (crl_score & CRL_SCORE_ISSUER_NAME))
+        return 1;
+    return 0;
+}
+
+/*
+ * Retrieve CRL corresponding to current certificate. If deltas enabled try
+ * to find a delta CRL too
+ */
+
+static int get_crl_delta(X509_STORE_CTX *ctx,
+                         X509_CRL **pcrl, X509_CRL **pdcrl, X509 *x)
+{
+    int ok;
+    X509 *issuer = NULL;
+    int crl_score = 0;
+    unsigned int reasons;
+    X509_CRL *crl = NULL, *dcrl = NULL;
+    STACK_OF(X509_CRL) *skcrl;
+    X509_NAME *nm = X509_get_issuer_name(x);
+    reasons = ctx->current_reasons;
+    ok = get_crl_sk(ctx, &crl, &dcrl,
+                    &issuer, &crl_score, &reasons, ctx->crls);
+
+    if (ok)
+        goto done;
+
+    /* Lookup CRLs from store */
+
+    skcrl = ctx->lookup_crls(ctx, nm);
+
+    /* If no CRLs found and a near match from get_crl_sk use that */
+    if (!skcrl && crl)
+        goto done;
+
+    get_crl_sk(ctx, &crl, &dcrl, &issuer, &crl_score, &reasons, skcrl);
+
+    sk_X509_CRL_pop_free(skcrl, X509_CRL_free);
+
+ done:
+
+    /* If we got any kind of CRL use it and return success */
+    if (crl) {
+        ctx->current_issuer = issuer;
+        ctx->current_crl_score = crl_score;
+        ctx->current_reasons = reasons;
+        *pcrl = crl;
+        *pdcrl = dcrl;
+        return 1;
+    }
+
+    return 0;
+}
+
+/* Check CRL validity */
+static int check_crl(X509_STORE_CTX *ctx, X509_CRL *crl)
+{
+    X509 *issuer = NULL;
+    EVP_PKEY *ikey = NULL;
+    int ok = 0, chnum, cnum;
+    cnum = ctx->error_depth;
+    chnum = sk_X509_num(ctx->chain) - 1;
+    /* if we have an alternative CRL issuer cert use that */
+    if (ctx->current_issuer)
+        issuer = ctx->current_issuer;
+
+    /*
+     * Else find CRL issuer: if not last certificate then issuer is next
+     * certificate in chain.
+     */
+    else if (cnum < chnum)
+        issuer = sk_X509_value(ctx->chain, cnum + 1);
+    else {
+        issuer = sk_X509_value(ctx->chain, chnum);
+        /* If not self signed, can't check signature */
+        if (!ctx->check_issued(ctx, issuer, issuer)) {
+            ctx->error = X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER;
+            ok = ctx->verify_cb(0, ctx);
+            if (!ok)
+                goto err;
+        }
+    }
+
+    if (issuer) {
+        /*
+         * Skip most tests for deltas because they have already been done
+         */
+        if (!crl->base_crl_number) {
+            /* Check for cRLSign bit if keyUsage present */
+            if ((issuer->ex_flags & EXFLAG_KUSAGE) &&
+                !(issuer->ex_kusage & KU_CRL_SIGN)) {
+                ctx->error = X509_V_ERR_KEYUSAGE_NO_CRL_SIGN;
+                ok = ctx->verify_cb(0, ctx);
+                if (!ok)
+                    goto err;
+            }
+
+            if (!(ctx->current_crl_score & CRL_SCORE_SCOPE)) {
+                ctx->error = X509_V_ERR_DIFFERENT_CRL_SCOPE;
+                ok = ctx->verify_cb(0, ctx);
+                if (!ok)
+                    goto err;
+            }
+
+            if (!(ctx->current_crl_score & CRL_SCORE_SAME_PATH)) {
+                if (check_crl_path(ctx, ctx->current_issuer) <= 0) {
+                    ctx->error = X509_V_ERR_CRL_PATH_VALIDATION_ERROR;
+                    ok = ctx->verify_cb(0, ctx);
+                    if (!ok)
+                        goto err;
+                }
+            }
+
+            if (crl->idp_flags & IDP_INVALID) {
+                ctx->error = X509_V_ERR_INVALID_EXTENSION;
+                ok = ctx->verify_cb(0, ctx);
+                if (!ok)
+                    goto err;
+            }
+
+        }
+
+        if (!(ctx->current_crl_score & CRL_SCORE_TIME)) {
+            ok = check_crl_time(ctx, crl, 1);
+            if (!ok)
+                goto err;
+        }
+
+        /* Attempt to get issuer certificate public key */
+        ikey = X509_get_pubkey(issuer);
+
+        if (!ikey) {
+            ctx->error = X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;
+            ok = ctx->verify_cb(0, ctx);
+            if (!ok)
+                goto err;
+        } else {
+            int rv;
+            rv = X509_CRL_check_suiteb(crl, ikey, ctx->param->flags);
+            if (rv != X509_V_OK) {
+                ctx->error = rv;
+                ok = ctx->verify_cb(0, ctx);
+                if (!ok)
+                    goto err;
+            }
+            /* Verify CRL signature */
+            if (X509_CRL_verify(crl, ikey) <= 0) {
+                ctx->error = X509_V_ERR_CRL_SIGNATURE_FAILURE;
+                ok = ctx->verify_cb(0, ctx);
+                if (!ok)
+                    goto err;
+            }
+        }
+    }
+
+    ok = 1;
+
+ err:
+    EVP_PKEY_free(ikey);
+    return ok;
+}
+
+/* Check certificate against CRL */
+static int cert_crl(X509_STORE_CTX *ctx, X509_CRL *crl, X509 *x)
+{
+    int ok;
+    X509_REVOKED *rev;
+    /*
+     * The rules changed for this... previously if a CRL contained unhandled
+     * critical extensions it could still be used to indicate a certificate
+     * was revoked. This has since been changed since critical extension can
+     * change the meaning of CRL entries.
+     */
+    if (!(ctx->param->flags & X509_V_FLAG_IGNORE_CRITICAL)
+        && (crl->flags & EXFLAG_CRITICAL)) {
+        ctx->error = X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION;
+        ok = ctx->verify_cb(0, ctx);
+        if (!ok)
+            return 0;
+    }
+    /*
+     * Look for serial number of certificate in CRL If found make sure reason
+     * is not removeFromCRL.
+     */
+    if (X509_CRL_get0_by_cert(crl, &rev, x)) {
+        if (rev->reason == CRL_REASON_REMOVE_FROM_CRL)
+            return 2;
+        ctx->error = X509_V_ERR_CERT_REVOKED;
+        ok = ctx->verify_cb(0, ctx);
+        if (!ok)
+            return 0;
+    }
+
+    return 1;
+}
+
+static int check_policy(X509_STORE_CTX *ctx)
+{
+    int ret;
+    if (ctx->parent)
+        return 1;
+    ret = X509_policy_check(&ctx->tree, &ctx->explicit_policy, ctx->chain,
+                            ctx->param->policies, ctx->param->flags);
+    if (ret == 0) {
+        X509err(X509_F_CHECK_POLICY, ERR_R_MALLOC_FAILURE);
+        ctx->error = X509_V_ERR_OUT_OF_MEM;
+        return 0;
+    }
+    /* Invalid or inconsistent extensions */
+    if (ret == -1) {
+        /*
+         * Locate certificates with bad extensions and notify callback.
+         */
+        X509 *x;
+        int i;
+        for (i = 1; i < sk_X509_num(ctx->chain); i++) {
+            x = sk_X509_value(ctx->chain, i);
+            if (!(x->ex_flags & EXFLAG_INVALID_POLICY))
+                continue;
+            ctx->current_cert = x;
+            ctx->error = X509_V_ERR_INVALID_POLICY_EXTENSION;
+            if (!ctx->verify_cb(0, ctx))
+                return 0;
+        }
+        return 1;
+    }
+    if (ret == -2) {
+        ctx->current_cert = NULL;
+        ctx->error = X509_V_ERR_NO_EXPLICIT_POLICY;
+        return ctx->verify_cb(0, ctx);
+    }
+
+    if (ctx->param->flags & X509_V_FLAG_NOTIFY_POLICY) {
+        ctx->current_cert = NULL;
+        /*
+         * Verification errors need to be "sticky", a callback may have allowed
+         * an SSL handshake to continue despite an error, and we must then
+         * remain in an error state.  Therefore, we MUST NOT clear earlier
+         * verification errors by setting the error to X509_V_OK.
+         */
+        if (!ctx->verify_cb(2, ctx))
+            return 0;
+    }
+
+    return 1;
+}
+
+static int check_cert_time(X509_STORE_CTX *ctx, X509 *x)
+{
+    time_t *ptime;
+    int i;
+
+    if (ctx->param->flags & X509_V_FLAG_USE_CHECK_TIME)
+        ptime = &ctx->param->check_time;
+    else
+        ptime = NULL;
+
+    i = X509_cmp_time(X509_get_notBefore(x), ptime);
+    if (i == 0) {
+        ctx->error = X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD;
+        ctx->current_cert = x;
+        if (!ctx->verify_cb(0, ctx))
+            return 0;
+    }
+
+    if (i > 0) {
+        ctx->error = X509_V_ERR_CERT_NOT_YET_VALID;
+        ctx->current_cert = x;
+        if (!ctx->verify_cb(0, ctx))
+            return 0;
+    }
+
+    i = X509_cmp_time(X509_get_notAfter(x), ptime);
+    if (i == 0) {
+        ctx->error = X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD;
+        ctx->current_cert = x;
+        if (!ctx->verify_cb(0, ctx))
+            return 0;
+    }
+
+    if (i < 0) {
+        ctx->error = X509_V_ERR_CERT_HAS_EXPIRED;
+        ctx->current_cert = x;
+        if (!ctx->verify_cb(0, ctx))
+            return 0;
+    }
+
+    return 1;
+}
+
+static int internal_verify(X509_STORE_CTX *ctx)
+{
+    int ok = 0, n;
+    X509 *xs, *xi;
+    EVP_PKEY *pkey = NULL;
+    int (*cb) (int xok, X509_STORE_CTX *xctx);
+
+    cb = ctx->verify_cb;
+
+    n = sk_X509_num(ctx->chain);
+    ctx->error_depth = n - 1;
+    n--;
+    xi = sk_X509_value(ctx->chain, n);
+
+    if (ctx->check_issued(ctx, xi, xi))
+        xs = xi;
+    else {
+        if (ctx->param->flags & X509_V_FLAG_PARTIAL_CHAIN) {
+            xs = xi;
+            goto check_cert;
+        }
+        if (n <= 0) {
+            ctx->error = X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE;
+            ctx->current_cert = xi;
+            ok = cb(0, ctx);
+            goto end;
+        } else {
+            n--;
+            ctx->error_depth = n;
+            xs = sk_X509_value(ctx->chain, n);
+        }
+    }
+
+/*      ctx->error=0;  not needed */
+    while (n >= 0) {
+        ctx->error_depth = n;
+
+        /*
+         * Skip signature check for self signed certificates unless
+         * explicitly asked for. It doesn't add any security and just wastes
+         * time.
+         */
+        if (!xs->valid
+            && (xs != xi
+                || (ctx->param->flags & X509_V_FLAG_CHECK_SS_SIGNATURE))) {
+            if ((pkey = X509_get_pubkey(xi)) == NULL) {
+                ctx->error = X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;
+                ctx->current_cert = xi;
+                ok = (*cb) (0, ctx);
+                if (!ok)
+                    goto end;
+            } else if (X509_verify(xs, pkey) <= 0) {
+                ctx->error = X509_V_ERR_CERT_SIGNATURE_FAILURE;
+                ctx->current_cert = xs;
+                ok = (*cb) (0, ctx);
+                if (!ok) {
+                    EVP_PKEY_free(pkey);
+                    goto end;
+                }
+            }
+            EVP_PKEY_free(pkey);
+            pkey = NULL;
+        }
+
+        xs->valid = 1;
+
+ check_cert:
+        ok = check_cert_time(ctx, xs);
+        if (!ok)
+            goto end;
+
+        /* The last error (if any) is still in the error value */
+        ctx->current_issuer = xi;
+        ctx->current_cert = xs;
+        ok = (*cb) (1, ctx);
+        if (!ok)
+            goto end;
+
+        n--;
+        if (n >= 0) {
+            xi = xs;
+            xs = sk_X509_value(ctx->chain, n);
+        }
+    }
+    ok = 1;
+ end:
+    return ok;
+}
+
+int X509_cmp_current_time(const ASN1_TIME *ctm)
+{
+    return X509_cmp_time(ctm, NULL);
+}
+
+int X509_cmp_time(const ASN1_TIME *ctm, time_t *cmp_time)
+{
+    char *str;
+    ASN1_TIME atm;
+    long offset;
+    char buff1[24], buff2[24], *p;
+    int i, j, remaining;
+
+    p = buff1;
+    remaining = ctm->length;
+    str = (char *)ctm->data;
+    /*
+     * Note that the following (historical) code allows much more slack in the
+     * time format than RFC5280. In RFC5280, the representation is fixed:
+     * UTCTime: YYMMDDHHMMSSZ
+     * GeneralizedTime: YYYYMMDDHHMMSSZ
+     */
+    if (ctm->type == V_ASN1_UTCTIME) {
+        /* YYMMDDHHMM[SS]Z or YYMMDDHHMM[SS](+-)hhmm */
+        int min_length = sizeof("YYMMDDHHMMZ") - 1;
+        int max_length = sizeof("YYMMDDHHMMSS+hhmm") - 1;
+        if (remaining < min_length || remaining > max_length)
+            return 0;
+        memcpy(p, str, 10);
+        p += 10;
+        str += 10;
+        remaining -= 10;
+    } else {
+        /* YYYYMMDDHHMM[SS[.fff]]Z or YYYYMMDDHHMM[SS[.f[f[f]]]](+-)hhmm */
+        int min_length = sizeof("YYYYMMDDHHMMZ") - 1;
+        int max_length = sizeof("YYYYMMDDHHMMSS.fff+hhmm") - 1;
+        if (remaining < min_length || remaining > max_length)
+            return 0;
+        memcpy(p, str, 12);
+        p += 12;
+        str += 12;
+        remaining -= 12;
+    }
+
+    if ((*str == 'Z') || (*str == '-') || (*str == '+')) {
+        *(p++) = '0';
+        *(p++) = '0';
+    } else {
+        /* SS (seconds) */
+        if (remaining < 2)
+            return 0;
+        *(p++) = *(str++);
+        *(p++) = *(str++);
+        remaining -= 2;
+        /*
+         * Skip any (up to three) fractional seconds...
+         * TODO(emilia): in RFC5280, fractional seconds are forbidden.
+         * Can we just kill them altogether?
+         */
+        if (remaining && *str == '.') {
+            str++;
+            remaining--;
+            for (i = 0; i < 3 && remaining; i++, str++, remaining--) {
+                if (*str < '0' || *str > '9')
+                    break;
+            }
+        }
+
+    }
+    *(p++) = 'Z';
+    *(p++) = '\0';
+
+    /* We now need either a terminating 'Z' or an offset. */
+    if (!remaining)
+        return 0;
+    if (*str == 'Z') {
+        if (remaining != 1)
+            return 0;
+        offset = 0;
+    } else {
+        /* (+-)HHMM */
+        if ((*str != '+') && (*str != '-'))
+            return 0;
+        /* Historical behaviour: the (+-)hhmm offset is forbidden in RFC5280. */
+        if (remaining != 5)
+            return 0;
+        if (str[1] < '0' || str[1] > '9' || str[2] < '0' || str[2] > '9' ||
+            str[3] < '0' || str[3] > '9' || str[4] < '0' || str[4] > '9')
+            return 0;
+        offset = ((str[1] - '0') * 10 + (str[2] - '0')) * 60;
+        offset += (str[3] - '0') * 10 + (str[4] - '0');
+        if (*str == '-')
+            offset = -offset;
+    }
+    atm.type = ctm->type;
+    atm.flags = 0;
+    atm.length = sizeof(buff2);
+    atm.data = (unsigned char *)buff2;
+
+    if (X509_time_adj(&atm, offset * 60, cmp_time) == NULL)
+        return 0;
+
+    if (ctm->type == V_ASN1_UTCTIME) {
+        i = (buff1[0] - '0') * 10 + (buff1[1] - '0');
+        if (i < 50)
+            i += 100;           /* cf. RFC 2459 */
+        j = (buff2[0] - '0') * 10 + (buff2[1] - '0');
+        if (j < 50)
+            j += 100;
+
+        if (i < j)
+            return -1;
+        if (i > j)
+            return 1;
+    }
+    i = strcmp(buff1, buff2);
+    if (i == 0)                 /* wait a second then return younger :-) */
+        return -1;
+    else
+        return i;
+}
+
+ASN1_TIME *X509_gmtime_adj(ASN1_TIME *s, long adj)
+{
+    return X509_time_adj(s, adj, NULL);
+}
+
+ASN1_TIME *X509_time_adj(ASN1_TIME *s, long offset_sec, time_t *in_tm)
+{
+    return X509_time_adj_ex(s, 0, offset_sec, in_tm);
+}
+
+ASN1_TIME *X509_time_adj_ex(ASN1_TIME *s,
+                            int offset_day, long offset_sec, time_t *in_tm)
+{
+    time_t t;
+
+    if (in_tm)
+        t = *in_tm;
+    else
+        time(&t);
+
+    if (s && !(s->flags & ASN1_STRING_FLAG_MSTRING)) {
+        if (s->type == V_ASN1_UTCTIME)
+            return ASN1_UTCTIME_adj(s, t, offset_day, offset_sec);
+        if (s->type == V_ASN1_GENERALIZEDTIME)
+            return ASN1_GENERALIZEDTIME_adj(s, t, offset_day, offset_sec);
+    }
+    return ASN1_TIME_adj(s, t, offset_day, offset_sec);
+}
+
+int X509_get_pubkey_parameters(EVP_PKEY *pkey, STACK_OF(X509) *chain)
+{
+    EVP_PKEY *ktmp = NULL, *ktmp2;
+    int i, j;
+
+    if ((pkey != NULL) && !EVP_PKEY_missing_parameters(pkey))
+        return 1;
+
+    for (i = 0; i < sk_X509_num(chain); i++) {
+        ktmp = X509_get_pubkey(sk_X509_value(chain, i));
+        if (ktmp == NULL) {
+            X509err(X509_F_X509_GET_PUBKEY_PARAMETERS,
+                    X509_R_UNABLE_TO_GET_CERTS_PUBLIC_KEY);
+            return 0;
+        }
+        if (!EVP_PKEY_missing_parameters(ktmp))
+            break;
+        else {
+            EVP_PKEY_free(ktmp);
+            ktmp = NULL;
+        }
+    }
+    if (ktmp == NULL) {
+        X509err(X509_F_X509_GET_PUBKEY_PARAMETERS,
+                X509_R_UNABLE_TO_FIND_PARAMETERS_IN_CHAIN);
+        return 0;
+    }
+
+    /* first, populate the other certs */
+    for (j = i - 1; j >= 0; j--) {
+        ktmp2 = X509_get_pubkey(sk_X509_value(chain, j));
+        EVP_PKEY_copy_parameters(ktmp2, ktmp);
+        EVP_PKEY_free(ktmp2);
+    }
+
+    if (pkey != NULL)
+        EVP_PKEY_copy_parameters(pkey, ktmp);
+    EVP_PKEY_free(ktmp);
+    return 1;
+}
+
+/* Make a delta CRL as the diff between two full CRLs */
+
+X509_CRL *X509_CRL_diff(X509_CRL *base, X509_CRL *newer,
+                        EVP_PKEY *skey, const EVP_MD *md, unsigned int flags)
+{
+    X509_CRL *crl = NULL;
+    int i;
+    STACK_OF(X509_REVOKED) *revs = NULL;
+    /* CRLs can't be delta already */
+    if (base->base_crl_number || newer->base_crl_number) {
+        X509err(X509_F_X509_CRL_DIFF, X509_R_CRL_ALREADY_DELTA);
+        return NULL;
+    }
+    /* Base and new CRL must have a CRL number */
+    if (!base->crl_number || !newer->crl_number) {
+        X509err(X509_F_X509_CRL_DIFF, X509_R_NO_CRL_NUMBER);
+        return NULL;
+    }
+    /* Issuer names must match */
+    if (X509_NAME_cmp(X509_CRL_get_issuer(base), X509_CRL_get_issuer(newer))) {
+        X509err(X509_F_X509_CRL_DIFF, X509_R_ISSUER_MISMATCH);
+        return NULL;
+    }
+    /* AKID and IDP must match */
+    if (!crl_extension_match(base, newer, NID_authority_key_identifier)) {
+        X509err(X509_F_X509_CRL_DIFF, X509_R_AKID_MISMATCH);
+        return NULL;
+    }
+    if (!crl_extension_match(base, newer, NID_issuing_distribution_point)) {
+        X509err(X509_F_X509_CRL_DIFF, X509_R_IDP_MISMATCH);
+        return NULL;
+    }
+    /* Newer CRL number must exceed full CRL number */
+    if (ASN1_INTEGER_cmp(newer->crl_number, base->crl_number) <= 0) {
+        X509err(X509_F_X509_CRL_DIFF, X509_R_NEWER_CRL_NOT_NEWER);
+        return NULL;
+    }
+    /* CRLs must verify */
+    if (skey && (X509_CRL_verify(base, skey) <= 0 ||
+                 X509_CRL_verify(newer, skey) <= 0)) {
+        X509err(X509_F_X509_CRL_DIFF, X509_R_CRL_VERIFY_FAILURE);
+        return NULL;
+    }
+    /* Create new CRL */
+    crl = X509_CRL_new();
+    if (!crl || !X509_CRL_set_version(crl, 1))
+        goto memerr;
+    /* Set issuer name */
+    if (!X509_CRL_set_issuer_name(crl, X509_CRL_get_issuer(newer)))
+        goto memerr;
+
+    if (!X509_CRL_set_lastUpdate(crl, X509_CRL_get_lastUpdate(newer)))
+        goto memerr;
+    if (!X509_CRL_set_nextUpdate(crl, X509_CRL_get_nextUpdate(newer)))
+        goto memerr;
+
+    /* Set base CRL number: must be critical */
+
+    if (!X509_CRL_add1_ext_i2d(crl, NID_delta_crl, base->crl_number, 1, 0))
+        goto memerr;
+
+    /*
+     * Copy extensions across from newest CRL to delta: this will set CRL
+     * number to correct value too.
+     */
+
+    for (i = 0; i < X509_CRL_get_ext_count(newer); i++) {
+        X509_EXTENSION *ext;
+        ext = X509_CRL_get_ext(newer, i);
+        if (!X509_CRL_add_ext(crl, ext, -1))
+            goto memerr;
+    }
+
+    /* Go through revoked entries, copying as needed */
+
+    revs = X509_CRL_get_REVOKED(newer);
+
+    for (i = 0; i < sk_X509_REVOKED_num(revs); i++) {
+        X509_REVOKED *rvn, *rvtmp;
+        rvn = sk_X509_REVOKED_value(revs, i);
+        /*
+         * Add only if not also in base. TODO: need something cleverer here
+         * for some more complex CRLs covering multiple CAs.
+         */
+        if (!X509_CRL_get0_by_serial(base, &rvtmp, rvn->serialNumber)) {
+            rvtmp = X509_REVOKED_dup(rvn);
+            if (!rvtmp)
+                goto memerr;
+            if (!X509_CRL_add0_revoked(crl, rvtmp)) {
+                X509_REVOKED_free(rvtmp);
+                goto memerr;
+            }
+        }
+    }
+    /* TODO: optionally prune deleted entries */
+
+    if (skey && md && !X509_CRL_sign(crl, skey, md))
+        goto memerr;
+
+    return crl;
+
+ memerr:
+    X509err(X509_F_X509_CRL_DIFF, ERR_R_MALLOC_FAILURE);
+    if (crl)
+        X509_CRL_free(crl);
+    return NULL;
+}
+
+int X509_STORE_CTX_get_ex_new_index(long argl, void *argp,
+                                    CRYPTO_EX_new *new_func,
+                                    CRYPTO_EX_dup *dup_func,
+                                    CRYPTO_EX_free *free_func)
+{
+    /*
+     * This function is (usually) called only once, by
+     * SSL_get_ex_data_X509_STORE_CTX_idx (ssl/ssl_cert.c).
+     */
+    return CRYPTO_get_ex_new_index(CRYPTO_EX_INDEX_X509_STORE_CTX, argl, argp,
+                                   new_func, dup_func, free_func);
+}
+
+int X509_STORE_CTX_set_ex_data(X509_STORE_CTX *ctx, int idx, void *data)
+{
+    return CRYPTO_set_ex_data(&ctx->ex_data, idx, data);
+}
+
+void *X509_STORE_CTX_get_ex_data(X509_STORE_CTX *ctx, int idx)
+{
+    return CRYPTO_get_ex_data(&ctx->ex_data, idx);
+}
+
+int X509_STORE_CTX_get_error(X509_STORE_CTX *ctx)
+{
+    return ctx->error;
+}
+
+void X509_STORE_CTX_set_error(X509_STORE_CTX *ctx, int err)
+{
+    ctx->error = err;
+}
+
+int X509_STORE_CTX_get_error_depth(X509_STORE_CTX *ctx)
+{
+    return ctx->error_depth;
+}
+
+X509 *X509_STORE_CTX_get_current_cert(X509_STORE_CTX *ctx)
+{
+    return ctx->current_cert;
+}
+
+STACK_OF(X509) *X509_STORE_CTX_get_chain(X509_STORE_CTX *ctx)
+{
+    return ctx->chain;
+}
+
+STACK_OF(X509) *X509_STORE_CTX_get1_chain(X509_STORE_CTX *ctx)
+{
+    if (!ctx->chain)
+        return NULL;
+    return X509_chain_up_ref(ctx->chain);
+}
+
+X509 *X509_STORE_CTX_get0_current_issuer(X509_STORE_CTX *ctx)
+{
+    return ctx->current_issuer;
+}
+
+X509_CRL *X509_STORE_CTX_get0_current_crl(X509_STORE_CTX *ctx)
+{
+    return ctx->current_crl;
+}
+
+X509_STORE_CTX *X509_STORE_CTX_get0_parent_ctx(X509_STORE_CTX *ctx)
+{
+    return ctx->parent;
+}
+
+void X509_STORE_CTX_set_cert(X509_STORE_CTX *ctx, X509 *x)
+{
+    ctx->cert = x;
+}
+
+void X509_STORE_CTX_set_chain(X509_STORE_CTX *ctx, STACK_OF(X509) *sk)
+{
+    ctx->untrusted = sk;
+}
+
+void X509_STORE_CTX_set0_crls(X509_STORE_CTX *ctx, STACK_OF(X509_CRL) *sk)
+{
+    ctx->crls = sk;
+}
+
+int X509_STORE_CTX_set_purpose(X509_STORE_CTX *ctx, int purpose)
+{
+    return X509_STORE_CTX_purpose_inherit(ctx, 0, purpose, 0);
+}
+
+int X509_STORE_CTX_set_trust(X509_STORE_CTX *ctx, int trust)
+{
+    return X509_STORE_CTX_purpose_inherit(ctx, 0, 0, trust);
+}
+
+/*
+ * This function is used to set the X509_STORE_CTX purpose and trust values.
+ * This is intended to be used when another structure has its own trust and
+ * purpose values which (if set) will be inherited by the ctx. If they aren't
+ * set then we will usually have a default purpose in mind which should then
+ * be used to set the trust value. An example of this is SSL use: an SSL
+ * structure will have its own purpose and trust settings which the
+ * application can set: if they aren't set then we use the default of SSL
+ * client/server.
+ */
+
+int X509_STORE_CTX_purpose_inherit(X509_STORE_CTX *ctx, int def_purpose,
+                                   int purpose, int trust)
+{
+    int idx;
+    /* If purpose not set use default */
+    if (!purpose)
+        purpose = def_purpose;
+    /* If we have a purpose then check it is valid */
+    if (purpose) {
+        X509_PURPOSE *ptmp;
+        idx = X509_PURPOSE_get_by_id(purpose);
+        if (idx == -1) {
+            X509err(X509_F_X509_STORE_CTX_PURPOSE_INHERIT,
+                    X509_R_UNKNOWN_PURPOSE_ID);
+            return 0;
+        }
+        ptmp = X509_PURPOSE_get0(idx);
+        if (ptmp->trust == X509_TRUST_DEFAULT) {
+            idx = X509_PURPOSE_get_by_id(def_purpose);
+            if (idx == -1) {
+                X509err(X509_F_X509_STORE_CTX_PURPOSE_INHERIT,
+                        X509_R_UNKNOWN_PURPOSE_ID);
+                return 0;
+            }
+            ptmp = X509_PURPOSE_get0(idx);
+        }
+        /* If trust not set then get from purpose default */
+        if (!trust)
+            trust = ptmp->trust;
+    }
+    if (trust) {
+        idx = X509_TRUST_get_by_id(trust);
+        if (idx == -1) {
+            X509err(X509_F_X509_STORE_CTX_PURPOSE_INHERIT,
+                    X509_R_UNKNOWN_TRUST_ID);
+            return 0;
+        }
+    }
+
+    if (purpose && !ctx->param->purpose)
+        ctx->param->purpose = purpose;
+    if (trust && !ctx->param->trust)
+        ctx->param->trust = trust;
+    return 1;
+}
+
+X509_STORE_CTX *X509_STORE_CTX_new(void)
+{
+    X509_STORE_CTX *ctx;
+    ctx = (X509_STORE_CTX *)OPENSSL_malloc(sizeof(X509_STORE_CTX));
+    if (!ctx) {
+        X509err(X509_F_X509_STORE_CTX_NEW, ERR_R_MALLOC_FAILURE);
+        return NULL;
+    }
+    memset(ctx, 0, sizeof(X509_STORE_CTX));
+    return ctx;
+}
+
+void X509_STORE_CTX_free(X509_STORE_CTX *ctx)
+{
+    if (!ctx)
+        return;
+    X509_STORE_CTX_cleanup(ctx);
+    OPENSSL_free(ctx);
+}
+
+int X509_STORE_CTX_init(X509_STORE_CTX *ctx, X509_STORE *store, X509 *x509,
+                        STACK_OF(X509) *chain)
+{
+    int ret = 1;
+    ctx->ctx = store;
+    ctx->current_method = 0;
+    ctx->cert = x509;
+    ctx->untrusted = chain;
+    ctx->crls = NULL;
+    ctx->last_untrusted = 0;
+    ctx->other_ctx = NULL;
+    ctx->valid = 0;
+    ctx->chain = NULL;
+    ctx->error = 0;
+    ctx->explicit_policy = 0;
+    ctx->error_depth = 0;
+    ctx->current_cert = NULL;
+    ctx->current_issuer = NULL;
+    ctx->current_crl = NULL;
+    ctx->current_crl_score = 0;
+    ctx->current_reasons = 0;
+    ctx->tree = NULL;
+    ctx->parent = NULL;
+    /* Zero ex_data to make sure we're cleanup-safe */
+    memset(&ctx->ex_data, 0, sizeof(ctx->ex_data));
+
+    ctx->param = X509_VERIFY_PARAM_new();
+    if (!ctx->param) {
+        X509err(X509_F_X509_STORE_CTX_INIT, ERR_R_MALLOC_FAILURE);
+        return 0;
+    }
+
+    /*
+     * Inherit callbacks and flags from X509_STORE if not set use defaults.
+     */
+    if (store)
+        ret = X509_VERIFY_PARAM_inherit(ctx->param, store->param);
+    else
+        ctx->param->inh_flags |= X509_VP_FLAG_DEFAULT | X509_VP_FLAG_ONCE;
+
+    if (store) {
+        ctx->verify_cb = store->verify_cb;
+        /* Seems to always be 0 in OpenSSL, else must be idempotent */
+        ctx->cleanup = store->cleanup;
+    } else
+        ctx->cleanup = 0;
+
+    if (ret)
+        ret = X509_VERIFY_PARAM_inherit(ctx->param,
+                                        X509_VERIFY_PARAM_lookup("default"));
+
+    if (ret == 0) {
+        X509err(X509_F_X509_STORE_CTX_INIT, ERR_R_MALLOC_FAILURE);
+        goto err;
+    }
+
+    if (store && store->check_issued)
+        ctx->check_issued = store->check_issued;
+    else
+        ctx->check_issued = check_issued;
+
+    if (store && store->get_issuer)
+        ctx->get_issuer = store->get_issuer;
+    else
+        ctx->get_issuer = X509_STORE_CTX_get1_issuer;
+
+    if (store && store->verify_cb)
+        ctx->verify_cb = store->verify_cb;
+    else
+        ctx->verify_cb = null_callback;
+
+    if (store && store->verify)
+        ctx->verify = store->verify;
+    else
+        ctx->verify = internal_verify;
+
+    if (store && store->check_revocation)
+        ctx->check_revocation = store->check_revocation;
+    else
+        ctx->check_revocation = check_revocation;
+
+    if (store && store->get_crl)
+        ctx->get_crl = store->get_crl;
+    else
+        ctx->get_crl = NULL;
+
+    if (store && store->check_crl)
+        ctx->check_crl = store->check_crl;
+    else
+        ctx->check_crl = check_crl;
+
+    if (store && store->cert_crl)
+        ctx->cert_crl = store->cert_crl;
+    else
+        ctx->cert_crl = cert_crl;
+
+    if (store && store->lookup_certs)
+        ctx->lookup_certs = store->lookup_certs;
+    else
+        ctx->lookup_certs = X509_STORE_get1_certs;
+
+    if (store && store->lookup_crls)
+        ctx->lookup_crls = store->lookup_crls;
+    else
+        ctx->lookup_crls = X509_STORE_get1_crls;
+
+    ctx->check_policy = check_policy;
+
+    if (CRYPTO_new_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx,
+                           &ctx->ex_data))
+        return 1;
+    X509err(X509_F_X509_STORE_CTX_INIT, ERR_R_MALLOC_FAILURE);
+
+ err:
+    /*
+     * On error clean up allocated storage, if the store context was not
+     * allocated with X509_STORE_CTX_new() this is our last chance to do so.
+     */
+    X509_STORE_CTX_cleanup(ctx);
+    return 0;
+}
+
+/*
+ * Set alternative lookup method: just a STACK of trusted certificates. This
+ * avoids X509_STORE nastiness where it isn't needed.
+ */
+
+void X509_STORE_CTX_trusted_stack(X509_STORE_CTX *ctx, STACK_OF(X509) *sk)
+{
+    ctx->other_ctx = sk;
+    ctx->get_issuer = get_issuer_sk;
+}
+
+void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx)
+{
+    /*
+     * We need to be idempotent because, unfortunately, free() also calls
+     * cleanup(), so the natural call sequence new(), init(), cleanup(), free()
+     * calls cleanup() for the same object twice!  Thus we must zero the
+     * pointers below after they're freed!
+     */
+    /* Seems to always be 0 in OpenSSL, do this at most once. */
+    if (ctx->cleanup != NULL) {
+        ctx->cleanup(ctx);
+        ctx->cleanup = NULL;
+    }
+    if (ctx->param != NULL) {
+        if (ctx->parent == NULL)
+            X509_VERIFY_PARAM_free(ctx->param);
+        ctx->param = NULL;
+    }
+    if (ctx->tree != NULL) {
+        X509_policy_tree_free(ctx->tree);
+        ctx->tree = NULL;
+    }
+    if (ctx->chain != NULL) {
+        sk_X509_pop_free(ctx->chain, X509_free);
+        ctx->chain = NULL;
+    }
+    CRYPTO_free_ex_data(CRYPTO_EX_INDEX_X509_STORE_CTX, ctx, &(ctx->ex_data));
+    memset(&ctx->ex_data, 0, sizeof(CRYPTO_EX_DATA));
+}
+
+void X509_STORE_CTX_set_depth(X509_STORE_CTX *ctx, int depth)
+{
+    X509_VERIFY_PARAM_set_depth(ctx->param, depth);
+}
+
+void X509_STORE_CTX_set_flags(X509_STORE_CTX *ctx, unsigned long flags)
+{
+    X509_VERIFY_PARAM_set_flags(ctx->param, flags);
+}
+
+void X509_STORE_CTX_set_time(X509_STORE_CTX *ctx, unsigned long flags,
+                             time_t t)
+{
+    X509_VERIFY_PARAM_set_time(ctx->param, t);
+}
+
+void X509_STORE_CTX_set_verify_cb(X509_STORE_CTX *ctx,
+                                  int (*verify_cb) (int, X509_STORE_CTX *))
+{
+    ctx->verify_cb = verify_cb;
+}
+
+X509_POLICY_TREE *X509_STORE_CTX_get0_policy_tree(X509_STORE_CTX *ctx)
+{
+    return ctx->tree;
+}
+
+int X509_STORE_CTX_get_explicit_policy(X509_STORE_CTX *ctx)
+{
+    return ctx->explicit_policy;
+}
+
+int X509_STORE_CTX_set_default(X509_STORE_CTX *ctx, const char *name)
+{
+    const X509_VERIFY_PARAM *param;
+    param = X509_VERIFY_PARAM_lookup(name);
+    if (!param)
+        return 0;
+    return X509_VERIFY_PARAM_inherit(ctx->param, param);
+}
+
+X509_VERIFY_PARAM *X509_STORE_CTX_get0_param(X509_STORE_CTX *ctx)
+{
+    return ctx->param;
+}
+
+void X509_STORE_CTX_set0_param(X509_STORE_CTX *ctx, X509_VERIFY_PARAM *param)
+{
+    if (ctx->param)
+        X509_VERIFY_PARAM_free(ctx->param);
+    ctx->param = param;
+}
+
+IMPLEMENT_STACK_OF(X509)
+
+IMPLEMENT_ASN1_SET_OF(X509)
+
+IMPLEMENT_STACK_OF(X509_NAME)
+
+IMPLEMENT_STACK_OF(X509_ATTRIBUTE)
+
+IMPLEMENT_ASN1_SET_OF(X509_ATTRIBUTE)
diff -uNr openssl-1.0.2l.orig/crypto/x86cpuid.pl openssl-1.0.2l/crypto/x86cpuid.pl
--- openssl-1.0.2l.orig/crypto/x86cpuid.pl	2017-05-25 20:54:38.000000000 +0800
+++ openssl-1.0.2l/crypto/x86cpuid.pl	2018-07-16 17:01:21.648443028 +0800
@@ -8,6 +8,8 @@
 
 for (@ARGV) { $sse2=1 if (/-DOPENSSL_IA32_SSE2/); }
 
+push(@out, ".hidden OPENSSL_ia32cap_P\n");
+
 &function_begin("OPENSSL_ia32_cpuid");
 	&xor	("edx","edx");
 	&pushf	();
@@ -153,9 +155,7 @@
 &set_label("nocpuid");
 &function_end("OPENSSL_ia32_cpuid");
 
-&external_label("OPENSSL_ia32cap_P");
-
-&function_begin_B("OPENSSL_rdtsc","EXTRN\t_OPENSSL_ia32cap_P:DWORD");
+&function_begin_B("OPENSSL_rdtsc");
 	&xor	("eax","eax");
 	&xor	("edx","edx");
 	&picmeup("ecx","OPENSSL_ia32cap_P");
@@ -169,7 +169,7 @@
 # This works in Ring 0 only [read DJGPP+MS-DOS+privileged DPMI host],
 # but it's safe to call it on any [supported] 32-bit platform...
 # Just check for [non-]zero return value...
-&function_begin_B("OPENSSL_instrument_halt","EXTRN\t_OPENSSL_ia32cap_P:DWORD");
+&function_begin_B("OPENSSL_instrument_halt");
 	&picmeup("ecx","OPENSSL_ia32cap_P");
 	&bt	(&DWP(0,"ecx"),4);
 	&jnc	(&label("nohalt"));	# no TSC
@@ -236,7 +236,7 @@
 	&ret	();
 &function_end_B("OPENSSL_far_spin");
 
-&function_begin_B("OPENSSL_wipe_cpu","EXTRN\t_OPENSSL_ia32cap_P:DWORD");
+&function_begin_B("OPENSSL_wipe_cpu");
 	&xor	("eax","eax");
 	&xor	("edx","edx");
 	&picmeup("ecx","OPENSSL_ia32cap_P");
diff -uNr openssl-1.0.2l.orig/crypto/x86cpuid.pl.orig openssl-1.0.2l/crypto/x86cpuid.pl.orig
--- openssl-1.0.2l.orig/crypto/x86cpuid.pl.orig	1970-01-01 08:00:00.000000000 +0800
+++ openssl-1.0.2l/crypto/x86cpuid.pl.orig	2017-05-25 20:54:38.000000000 +0800
@@ -0,0 +1,385 @@
+#!/usr/bin/env perl
+
+$0 =~ m/(.*[\/\\])[^\/\\]+$/; $dir=$1;
+push(@INC, "${dir}perlasm", "perlasm");
+require "x86asm.pl";
+
+&asm_init($ARGV[0],"x86cpuid");
+
+for (@ARGV) { $sse2=1 if (/-DOPENSSL_IA32_SSE2/); }
+
+&function_begin("OPENSSL_ia32_cpuid");
+	&xor	("edx","edx");
+	&pushf	();
+	&pop	("eax");
+	&mov	("ecx","eax");
+	&xor	("eax",1<<21);
+	&push	("eax");
+	&popf	();
+	&pushf	();
+	&pop	("eax");
+	&xor	("ecx","eax");
+	&xor	("eax","eax");
+	&mov	("esi",&wparam(0));
+	&mov	(&DWP(8,"esi"),"eax");	# clear extended feature flags
+	&bt	("ecx",21);
+	&jnc	(&label("nocpuid"));
+	&cpuid	();
+	&mov	("edi","eax");		# max value for standard query level
+
+	&xor	("eax","eax");
+	&cmp	("ebx",0x756e6547);	# "Genu"
+	&setne	(&LB("eax"));
+	&mov	("ebp","eax");
+	&cmp	("edx",0x49656e69);	# "ineI"
+	&setne	(&LB("eax"));
+	&or	("ebp","eax");
+	&cmp	("ecx",0x6c65746e);	# "ntel"
+	&setne	(&LB("eax"));
+	&or	("ebp","eax");		# 0 indicates Intel CPU
+	&jz	(&label("intel"));
+
+	&cmp	("ebx",0x68747541);	# "Auth"
+	&setne	(&LB("eax"));
+	&mov	("esi","eax");
+	&cmp	("edx",0x69746E65);	# "enti"
+	&setne	(&LB("eax"));
+	&or	("esi","eax");
+	&cmp	("ecx",0x444D4163);	# "cAMD"
+	&setne	(&LB("eax"));
+	&or	("esi","eax");		# 0 indicates AMD CPU
+	&jnz	(&label("intel"));
+
+	# AMD specific
+	&mov	("eax",0x80000000);
+	&cpuid	();
+	&cmp	("eax",0x80000001);
+	&jb	(&label("intel"));
+	&mov	("esi","eax");
+	&mov	("eax",0x80000001);
+	&cpuid	();
+	&or	("ebp","ecx");
+	&and	("ebp",1<<11|1);	# isolate XOP bit
+	&cmp	("esi",0x80000008);
+	&jb	(&label("intel"));
+
+	&mov	("eax",0x80000008);
+	&cpuid	();
+	&movz	("esi",&LB("ecx"));	# number of cores - 1
+	&inc	("esi");		# number of cores
+
+	&mov	("eax",1);
+	&xor	("ecx","ecx");
+	&cpuid	();
+	&bt	("edx",28);
+	&jnc	(&label("generic"));
+	&shr	("ebx",16);
+	&and	("ebx",0xff);
+	&cmp	("ebx","esi");
+	&ja	(&label("generic"));
+	&and	("edx",0xefffffff);	# clear hyper-threading bit
+	&jmp	(&label("generic"));
+	
+&set_label("intel");
+	&cmp	("edi",4);
+	&mov	("esi",-1);
+	&jb	(&label("nocacheinfo"));
+
+	&mov	("eax",4);
+	&mov	("ecx",0);		# query L1D
+	&cpuid	();
+	&mov	("esi","eax");
+	&shr	("esi",14);
+	&and	("esi",0xfff);		# number of cores -1 per L1D
+
+&set_label("nocacheinfo");
+	&mov	("eax",1);
+	&xor	("ecx","ecx");
+	&cpuid	();
+	&and	("edx",0xbfefffff);	# force reserved bits #20, #30 to 0
+	&cmp	("ebp",0);
+	&jne	(&label("notintel"));
+	&or	("edx",1<<30);		# set reserved bit#30 on Intel CPUs
+	&and	(&HB("eax"),15);	# familiy ID
+	&cmp	(&HB("eax"),15);	# P4?
+	&jne	(&label("notintel"));
+	&or	("edx",1<<20);		# set reserved bit#20 to engage RC4_CHAR
+&set_label("notintel");
+	&bt	("edx",28);		# test hyper-threading bit
+	&jnc	(&label("generic"));
+	&and	("edx",0xefffffff);
+	&cmp	("esi",0);
+	&je	(&label("generic"));
+
+	&or	("edx",0x10000000);
+	&shr	("ebx",16);
+	&cmp	(&LB("ebx"),1);
+	&ja	(&label("generic"));
+	&and	("edx",0xefffffff);	# clear hyper-threading bit if not
+
+&set_label("generic");
+	&and	("ebp",1<<11);		# isolate AMD XOP flag
+	&and	("ecx",0xfffff7ff);	# force 11th bit to 0
+	&mov	("esi","edx");		# %ebp:%esi is copy of %ecx:%edx
+	&or	("ebp","ecx");		# merge AMD XOP flag
+
+	&cmp	("edi",7);
+	&mov	("edi",&wparam(0));
+	&jb	(&label("no_extended_info"));
+	&mov	("eax",7);
+	&xor	("ecx","ecx");
+	&cpuid	();
+	&mov	(&DWP(8,"edi"),"ebx");	# save extended feature flag
+&set_label("no_extended_info");
+
+	&bt	("ebp",27);		# check OSXSAVE bit
+	&jnc	(&label("clear_avx"));
+	&xor	("ecx","ecx");
+	&data_byte(0x0f,0x01,0xd0);	# xgetbv
+	&and	("eax",6);
+	&cmp	("eax",6);
+	&je	(&label("done"));
+	&cmp	("eax",2);
+	&je	(&label("clear_avx"));
+&set_label("clear_xmm");
+	&and	("ebp",0xfdfffffd);	# clear AESNI and PCLMULQDQ bits
+	&and	("esi",0xfeffffff);	# clear FXSR
+&set_label("clear_avx");
+	&and	("ebp",0xefffe7ff);	# clear AVX, FMA and AMD XOP bits
+	&and	(&DWP(8,"edi"),0xffffffdf);	# clear AVX2
+&set_label("done");
+	&mov	("eax","esi");
+	&mov	("edx","ebp");
+&set_label("nocpuid");
+&function_end("OPENSSL_ia32_cpuid");
+
+&external_label("OPENSSL_ia32cap_P");
+
+&function_begin_B("OPENSSL_rdtsc","EXTRN\t_OPENSSL_ia32cap_P:DWORD");
+	&xor	("eax","eax");
+	&xor	("edx","edx");
+	&picmeup("ecx","OPENSSL_ia32cap_P");
+	&bt	(&DWP(0,"ecx"),4);
+	&jnc	(&label("notsc"));
+	&rdtsc	();
+&set_label("notsc");
+	&ret	();
+&function_end_B("OPENSSL_rdtsc");
+
+# This works in Ring 0 only [read DJGPP+MS-DOS+privileged DPMI host],
+# but it's safe to call it on any [supported] 32-bit platform...
+# Just check for [non-]zero return value...
+&function_begin_B("OPENSSL_instrument_halt","EXTRN\t_OPENSSL_ia32cap_P:DWORD");
+	&picmeup("ecx","OPENSSL_ia32cap_P");
+	&bt	(&DWP(0,"ecx"),4);
+	&jnc	(&label("nohalt"));	# no TSC
+
+	&data_word(0x9058900e);		# push %cs; pop %eax
+	&and	("eax",3);
+	&jnz	(&label("nohalt"));	# not enough privileges
+
+	&pushf	();
+	&pop	("eax");
+	&bt	("eax",9);
+	&jnc	(&label("nohalt"));	# interrupts are disabled
+
+	&rdtsc	();
+	&push	("edx");
+	&push	("eax");
+	&halt	();
+	&rdtsc	();
+
+	&sub	("eax",&DWP(0,"esp"));
+	&sbb	("edx",&DWP(4,"esp"));
+	&add	("esp",8);
+	&ret	();
+
+&set_label("nohalt");
+	&xor	("eax","eax");
+	&xor	("edx","edx");
+	&ret	();
+&function_end_B("OPENSSL_instrument_halt");
+
+# Essentially there is only one use for this function. Under DJGPP:
+#
+#	#include <go32.h>
+#	...
+#	i=OPENSSL_far_spin(_dos_ds,0x46c);
+#	...
+# to obtain the number of spins till closest timer interrupt.
+
+&function_begin_B("OPENSSL_far_spin");
+	&pushf	();
+	&pop	("eax");
+	&bt	("eax",9);
+	&jnc	(&label("nospin"));	# interrupts are disabled
+
+	&mov	("eax",&DWP(4,"esp"));
+	&mov	("ecx",&DWP(8,"esp"));
+	&data_word (0x90d88e1e);	# push %ds, mov %eax,%ds
+	&xor	("eax","eax");
+	&mov	("edx",&DWP(0,"ecx"));
+	&jmp	(&label("spin"));
+
+	&align	(16);
+&set_label("spin");
+	&inc	("eax");
+	&cmp	("edx",&DWP(0,"ecx"));
+	&je	(&label("spin"));
+
+	&data_word (0x1f909090);	# pop	%ds
+	&ret	();
+
+&set_label("nospin");
+	&xor	("eax","eax");
+	&xor	("edx","edx");
+	&ret	();
+&function_end_B("OPENSSL_far_spin");
+
+&function_begin_B("OPENSSL_wipe_cpu","EXTRN\t_OPENSSL_ia32cap_P:DWORD");
+	&xor	("eax","eax");
+	&xor	("edx","edx");
+	&picmeup("ecx","OPENSSL_ia32cap_P");
+	&mov	("ecx",&DWP(0,"ecx"));
+	&bt	(&DWP(0,"ecx"),1);
+	&jnc	(&label("no_x87"));
+	if ($sse2) {
+		&and	("ecx",1<<26|1<<24);	# check SSE2 and FXSR bits
+		&cmp	("ecx",1<<26|1<<24);
+		&jne	(&label("no_sse2"));
+		&pxor	("xmm0","xmm0");
+		&pxor	("xmm1","xmm1");
+		&pxor	("xmm2","xmm2");
+		&pxor	("xmm3","xmm3");
+		&pxor	("xmm4","xmm4");
+		&pxor	("xmm5","xmm5");
+		&pxor	("xmm6","xmm6");
+		&pxor	("xmm7","xmm7");
+	&set_label("no_sse2");
+	}
+	# just a bunch of fldz to zap the fp/mm bank followed by finit...
+	&data_word(0xeed9eed9,0xeed9eed9,0xeed9eed9,0xeed9eed9,0x90e3db9b);
+&set_label("no_x87");
+	&lea	("eax",&DWP(4,"esp"));
+	&ret	();
+&function_end_B("OPENSSL_wipe_cpu");
+
+&function_begin_B("OPENSSL_atomic_add");
+	&mov	("edx",&DWP(4,"esp"));	# fetch the pointer, 1st arg
+	&mov	("ecx",&DWP(8,"esp"));	# fetch the increment, 2nd arg
+	&push	("ebx");
+	&nop	();
+	&mov	("eax",&DWP(0,"edx"));
+&set_label("spin");
+	&lea	("ebx",&DWP(0,"eax","ecx"));
+	&nop	();
+	&data_word(0x1ab10ff0);	# lock;	cmpxchg	%ebx,(%edx)	# %eax is envolved and is always reloaded
+	&jne	(&label("spin"));
+	&mov	("eax","ebx");	# OpenSSL expects the new value
+	&pop	("ebx");
+	&ret	();
+&function_end_B("OPENSSL_atomic_add");
+
+# This function can become handy under Win32 in situations when
+# we don't know which calling convention, __stdcall or __cdecl(*),
+# indirect callee is using. In C it can be deployed as
+#
+#ifdef OPENSSL_CPUID_OBJ
+#	type OPENSSL_indirect_call(void *f,...);
+#	...
+#	OPENSSL_indirect_call(func,[up to $max arguments]);
+#endif
+#
+# (*)	it's designed to work even for __fastcall if number of
+#	arguments is 1 or 2!
+&function_begin_B("OPENSSL_indirect_call");
+	{
+	my ($max,$i)=(7,);	# $max has to be chosen as 4*n-1
+				# in order to preserve eventual
+				# stack alignment
+	&push	("ebp");
+	&mov	("ebp","esp");
+	&sub	("esp",$max*4);
+	&mov	("ecx",&DWP(12,"ebp"));
+	&mov	(&DWP(0,"esp"),"ecx");
+	&mov	("edx",&DWP(16,"ebp"));
+	&mov	(&DWP(4,"esp"),"edx");
+	for($i=2;$i<$max;$i++)
+		{
+		# Some copies will be redundant/bogus...
+		&mov	("eax",&DWP(12+$i*4,"ebp"));
+		&mov	(&DWP(0+$i*4,"esp"),"eax");
+		}
+	&call_ptr	(&DWP(8,"ebp"));# make the call...
+	&mov	("esp","ebp");	# ... and just restore the stack pointer
+				# without paying attention to what we called,
+				# (__cdecl *func) or (__stdcall *one).
+	&pop	("ebp");
+	&ret	();
+	}
+&function_end_B("OPENSSL_indirect_call");
+
+&function_begin_B("OPENSSL_cleanse");
+	&mov	("edx",&wparam(0));
+	&mov	("ecx",&wparam(1));
+	&xor	("eax","eax");
+	&cmp	("ecx",7);
+	&jae	(&label("lot"));
+	&cmp	("ecx",0);
+	&je	(&label("ret"));
+&set_label("little");
+	&mov	(&BP(0,"edx"),"al");
+	&sub	("ecx",1);
+	&lea	("edx",&DWP(1,"edx"));
+	&jnz	(&label("little"));
+&set_label("ret");
+	&ret	();
+
+&set_label("lot",16);
+	&test	("edx",3);
+	&jz	(&label("aligned"));
+	&mov	(&BP(0,"edx"),"al");
+	&lea	("ecx",&DWP(-1,"ecx"));
+	&lea	("edx",&DWP(1,"edx"));
+	&jmp	(&label("lot"));
+&set_label("aligned");
+	&mov	(&DWP(0,"edx"),"eax");
+	&lea	("ecx",&DWP(-4,"ecx"));
+	&test	("ecx",-4);
+	&lea	("edx",&DWP(4,"edx"));
+	&jnz	(&label("aligned"));
+	&cmp	("ecx",0);
+	&jne	(&label("little"));
+	&ret	();
+&function_end_B("OPENSSL_cleanse");
+
+&function_begin_B("OPENSSL_ia32_rdrand");
+	&mov	("ecx",8);
+&set_label("loop");
+	&rdrand	("eax");
+	&jc	(&label("break"));
+	&loop	(&label("loop"));
+&set_label("break");
+	&cmp	("eax",0);
+	&cmove	("eax","ecx");
+	&ret	();
+&function_end_B("OPENSSL_ia32_rdrand");
+
+&function_begin_B("OPENSSL_ia32_rdseed");
+	&mov	("ecx",8);
+&set_label("loop");
+	&rdseed	("eax");
+	&jc	(&label("break"));
+	&loop	(&label("loop"));
+&set_label("break");
+	&cmp	("eax",0);
+	&cmove	("eax","ecx");
+	&ret	();
+&function_end_B("OPENSSL_ia32_rdseed");
+
+&initseg("OPENSSL_cpuid_setup");
+
+&hidden("OPENSSL_cpuid_setup");
+&hidden("OPENSSL_ia32cap_P");
+
+&asm_finish();
diff -uNr openssl-1.0.2l.orig/engines/ccgost/Makefile openssl-1.0.2l/engines/ccgost/Makefile
--- openssl-1.0.2l.orig/engines/ccgost/Makefile	2017-05-25 20:54:34.000000000 +0800
+++ openssl-1.0.2l/engines/ccgost/Makefile	2018-07-16 17:01:21.536442260 +0800
@@ -47,7 +47,7 @@
 		pfx=lib; \
 		if expr "$(PLATFORM)" : "Cygwin" >/dev/null; then \
 			sfx=".so"; \
-			cp cyg$(LIBNAME).dll $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/engines/$${pfx}$(LIBNAME)$$sfx.new; \
+			cp cyg$(LIBNAME).dll $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/openssl-1.0.0/engines/$${pfx}$(LIBNAME)$$sfx.new; \
 		else \
 			case "$(CFLAGS)" in \
 			*DSO_BEOS*) sfx=".so";; \
@@ -56,10 +56,10 @@
 			*DSO_WIN32*) sfx="eay32.dll"; pfx=;; \
 			*) sfx=".bad";; \
 			esac; \
-			cp $${pfx}$(LIBNAME)$$sfx $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/engines/$${pfx}$(LIBNAME)$$sfx.new; \
+			cp $${pfx}$(LIBNAME)$$sfx $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/openssl-1.0.0/engines/$${pfx}$(LIBNAME)$$sfx.new; \
 		fi; \
-		chmod 555 $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/engines/$${pfx}$(LIBNAME)$$sfx.new; \
-		mv -f $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/engines/$${pfx}$(LIBNAME)$$sfx.new $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/engines/$${pfx}$(LIBNAME)$$sfx; \
+		chmod 555 $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/openssl-1.0.0/engines/$${pfx}$(LIBNAME)$$sfx.new; \
+		mv -f $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/openssl-1.0.0/engines/$${pfx}$(LIBNAME)$$sfx.new $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/openssl-1.0.0/engines/$${pfx}$(LIBNAME)$$sfx; \
 	fi
 
 links:
diff -uNr openssl-1.0.2l.orig/engines/ccgost/openssl.ld openssl-1.0.2l/engines/ccgost/openssl.ld
--- openssl-1.0.2l.orig/engines/ccgost/openssl.ld	1970-01-01 08:00:00.000000000 +0800
+++ openssl-1.0.2l/engines/ccgost/openssl.ld	2018-07-16 17:01:21.668443165 +0800
@@ -0,0 +1,10 @@
+OPENSSL_1.0.0 {
+	global:
+		bind_engine;
+		v_check;
+		OPENSSL_init;
+		OPENSSL_finish;
+	local:
+		*;
+};
+
diff -uNr openssl-1.0.2l.orig/engines/Makefile openssl-1.0.2l/engines/Makefile
--- openssl-1.0.2l.orig/engines/Makefile	2017-05-25 20:54:34.000000000 +0800
+++ openssl-1.0.2l/engines/Makefile	2018-07-16 17:01:21.532442233 +0800
@@ -107,13 +107,13 @@
 	@[ -n "$(INSTALLTOP)" ] # should be set by top Makefile...
 	@if [ -n "$(SHARED_LIBS)" ]; then \
 		set -e; \
-		$(PERL) $(TOP)/util/mkdir-p.pl $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/engines; \
+		$(PERL) $(TOP)/util/mkdir-p.pl $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/openssl-1.0.0/engines; \
 		for l in $(LIBNAMES); do \
 			( echo installing $$l; \
 			  pfx=lib; \
 			  if expr "$(PLATFORM)" : "Cygwin" >/dev/null; then \
 				sfx=".so"; \
-				cp cyg$$l.dll $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/engines/$$pfx$$l$$sfx.new; \
+				cp cyg$$l.dll $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/openssl-1.0.0/engines/$$pfx$$l$$sfx.new; \
 			  else \
 				case "$(CFLAGS)" in \
 				*DSO_BEOS*)	sfx=".so";;	\
@@ -122,10 +122,10 @@
 				*DSO_WIN32*)	sfx="eay32.dll"; pfx=;;	\
 				*)		sfx=".bad";;	\
 				esac; \
-				cp $$pfx$$l$$sfx $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/engines/$$pfx$$l$$sfx.new; \
+				cp $$pfx$$l$$sfx $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/openssl-1.0.0/engines/$$pfx$$l$$sfx.new; \
 			  fi; \
-			  chmod 555 $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/engines/$$pfx$$l$$sfx.new; \
-			  mv -f $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/engines/$$pfx$$l$$sfx.new $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/engines/$$pfx$$l$$sfx ); \
+			  chmod 555 $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/openssl-1.0.0/engines/$$pfx$$l$$sfx.new; \
+			  mv -f $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/openssl-1.0.0/engines/$$pfx$$l$$sfx.new $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/openssl-1.0.0/engines/$$pfx$$l$$sfx ); \
 		done; \
 	fi
 	@target=install; $(RECURSIVE_MAKE)
diff -uNr openssl-1.0.2l.orig/engines/openssl.ld openssl-1.0.2l/engines/openssl.ld
--- openssl-1.0.2l.orig/engines/openssl.ld	1970-01-01 08:00:00.000000000 +0800
+++ openssl-1.0.2l/engines/openssl.ld	2018-07-16 17:01:21.668443165 +0800
@@ -0,0 +1,10 @@
+OPENSSL_1.0.0 {
+	global:
+		bind_engine;
+		v_check;
+		OPENSSL_init;
+		OPENSSL_finish;
+	local:
+		*;
+};
+
diff -uNr openssl-1.0.2l.orig/Makefile.org openssl-1.0.2l/Makefile.org
--- openssl-1.0.2l.orig/Makefile.org	2017-05-25 20:54:38.000000000 +0800
+++ openssl-1.0.2l/Makefile.org	2018-07-16 17:01:21.540442287 +0800
@@ -159,10 +159,11 @@
 
 MAKEFILE= Makefile
 
-MANDIR=$(OPENSSLDIR)/man
+MANDIR=/usr/share/man
 MAN1=1
 MAN3=3
-MANSUFFIX=
+MANSUFFIX=ssl
+MANSECTION=SSL
 HTMLSUFFIX=html
 HTMLDIR=$(OPENSSLDIR)/html
 SHELL=/bin/sh
@@ -369,7 +370,7 @@
 	    echo 'exec_prefix=$${prefix}'; \
 	    echo 'libdir=$${exec_prefix}/$(LIBDIR)'; \
 	    echo 'includedir=$${prefix}/include'; \
-	    echo 'enginesdir=$${libdir}/engines'; \
+	    echo 'enginesdir=$${libdir}/openssl-1.0.0/engines'; \
 	    echo ''; \
 	    echo 'Name: OpenSSL-libcrypto'; \
 	    echo 'Description: OpenSSL cryptography library'; \
@@ -545,7 +546,7 @@
 install_sw:
 	@$(PERL) $(TOP)/util/mkdir-p.pl $(INSTALL_PREFIX)$(INSTALLTOP)/bin \
 		$(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR) \
-		$(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/engines \
+		$(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/openssl-1.0.0/engines \
 		$(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/pkgconfig \
 		$(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl \
 		$(INSTALL_PREFIX)$(OPENSSLDIR)/misc \
@@ -658,7 +659,7 @@
 		echo "installing man$$sec/$$fn.$${sec}$(MANSUFFIX)"; \
 		(cd `$(PERL) util/dirname.pl $$i`; \
 		sh -c "$$pod2man \
-			--section=$$sec --center=OpenSSL \
+			--section=$${sec}$(MANSECTION) --center=OpenSSL \
 			--release=$(VERSION) `basename $$i`") \
 			>  $(INSTALL_PREFIX)$(MANDIR)/man$$sec/$$fn.$${sec}$(MANSUFFIX); \
 		$(PERL) util/extract-names.pl < $$i | \
@@ -675,7 +676,7 @@
 		echo "installing man$$sec/$$fn.$${sec}$(MANSUFFIX)"; \
 		(cd `$(PERL) util/dirname.pl $$i`; \
 		sh -c "$$pod2man \
-			--section=$$sec --center=OpenSSL \
+			--section=$${sec}$(MANSECTION) --center=OpenSSL \
 			--release=$(VERSION) `basename $$i`") \
 			>  $(INSTALL_PREFIX)$(MANDIR)/man$$sec/$$fn.$${sec}$(MANSUFFIX); \
 		$(PERL) util/extract-names.pl < $$i | \
diff -uNr openssl-1.0.2l.orig/Makefile.org.orig openssl-1.0.2l/Makefile.org.orig
--- openssl-1.0.2l.orig/Makefile.org.orig	1970-01-01 08:00:00.000000000 +0800
+++ openssl-1.0.2l/Makefile.org.orig	2018-07-16 17:01:21.540442287 +0800
@@ -0,0 +1,690 @@
+##
+## Makefile for OpenSSL
+##
+
+VERSION=
+MAJOR=
+MINOR=
+SHLIB_VERSION_NUMBER=
+SHLIB_VERSION_HISTORY=
+SHLIB_MAJOR=
+SHLIB_MINOR=
+SHLIB_EXT=
+PLATFORM=dist
+OPTIONS=
+CONFIGURE_ARGS=
+SHLIB_TARGET=
+
+# HERE indicates where this Makefile lives.  This can be used to indicate
+# where sub-Makefiles are expected to be.  Currently has very limited usage,
+# and should probably not be bothered with at all.
+HERE=.
+
+# INSTALL_PREFIX is for package builders so that they can configure
+# for, say, /usr/ and yet have everything installed to /tmp/somedir/usr/.
+# Normally it is left empty.
+INSTALL_PREFIX=
+INSTALLTOP=/usr/local/ssl
+
+# Do not edit this manually. Use Configure --openssldir=DIR do change this!
+OPENSSLDIR=/usr/local/ssl
+
+# NO_IDEA - Define to build without the IDEA algorithm
+# NO_RC4  - Define to build without the RC4 algorithm
+# NO_RC2  - Define to build without the RC2 algorithm
+# THREADS - Define when building with threads, you will probably also need any
+#           system defines as well, i.e. _REENTERANT for Solaris 2.[34]
+# TERMIO  - Define the termio terminal subsystem, needed if sgtty is missing.
+# TERMIOS - Define the termios terminal subsystem, Silicon Graphics.
+# LONGCRYPT - Define to use HPUX 10.x's long password modification to crypt(3).
+# DEVRANDOM - Give this the value of the 'random device' if your OS supports
+#           one.  32 bytes will be read from this when the random
+#           number generator is initalised.
+# SSL_FORBID_ENULL - define if you want the server to be not able to use the
+#           NULL encryption ciphers.
+#
+# LOCK_DEBUG - turns on lots of lock debug output :-)
+# REF_CHECK - turn on some xyz_free() assertions.
+# REF_PRINT - prints some stuff on structure free.
+# CRYPTO_MDEBUG - turns on my 'memory leak' detecting stuff
+# MFUNC - Make all Malloc/Free/Realloc calls call
+#       CRYPTO_malloc/CRYPTO_free/CRYPTO_realloc which can be setup to
+#       call application defined callbacks via CRYPTO_set_mem_functions()
+# MD5_ASM needs to be defined to use the x86 assembler for MD5
+# SHA1_ASM needs to be defined to use the x86 assembler for SHA1
+# RMD160_ASM needs to be defined to use the x86 assembler for RIPEMD160
+# Do not define B_ENDIAN or L_ENDIAN if 'unsigned long' == 8.  It must
+# equal 4.
+# PKCS1_CHECK - pkcs1 tests.
+
+CC= cc
+CFLAG= -O
+DEPFLAG= 
+PEX_LIBS= 
+EX_LIBS= 
+EXE_EXT= 
+ARFLAGS=
+AR=ar $(ARFLAGS) r
+RANLIB= ranlib
+RC= windres
+NM= nm
+PERL= perl
+TAR= tar
+TARFLAGS= --no-recursion
+MAKEDEPPROG=makedepend
+LIBDIR=lib
+
+# We let the C compiler driver to take care of .s files. This is done in
+# order to be excused from maintaining a separate set of architecture
+# dependent assembler flags. E.g. if you throw -mcpu=ultrasparc at SPARC
+# gcc, then the driver will automatically translate it to -xarch=v8plus
+# and pass it down to assembler.
+AS=$(CC) -c
+ASFLAG=$(CFLAG)
+
+# For x86 assembler: Set PROCESSOR to 386 if you want to support
+# the 80386.
+PROCESSOR=
+
+# CPUID module collects small commonly used assembler snippets
+CPUID_OBJ= 
+BN_ASM= bn_asm.o
+EC_ASM=
+DES_ENC= des_enc.o fcrypt_b.o
+AES_ENC= aes_core.o aes_cbc.o
+BF_ENC= bf_enc.o
+CAST_ENC= c_enc.o
+RC4_ENC= rc4_enc.o
+RC5_ENC= rc5_enc.o
+MD5_ASM_OBJ= 
+SHA1_ASM_OBJ= 
+RMD160_ASM_OBJ= 
+WP_ASM_OBJ=
+CMLL_ENC=
+MODES_ASM_OBJ=
+ENGINES_ASM_OBJ=
+PERLASM_SCHEME=
+
+# KRB5 stuff
+KRB5_INCLUDES=
+LIBKRB5=
+
+# Zlib stuff
+ZLIB_INCLUDE=
+LIBZLIB=
+
+# TOP level FIPS install directory.
+FIPSDIR=
+
+# This is the location of fipscanister.o and friends.
+# The FIPS module build will place it $(INSTALLTOP)/lib
+# but since $(INSTALLTOP) can only take the default value
+# when the module is built it will be in /usr/local/ssl/lib
+# $(INSTALLTOP) for this build may be different so hard
+# code the path.
+
+FIPSLIBDIR=
+
+# The location of the library which contains fipscanister.o
+# normally it will be libcrypto unless fipsdso is set in which
+# case it will be libfips. If not compiling in FIPS mode at all
+# this is empty making it a useful test for a FIPS compile.
+
+FIPSCANLIB=
+
+# Shared library base address. Currently only used on Windows.
+#
+
+BASEADDR=
+
+DIRS=   crypto ssl engines apps test tools
+ENGDIRS= ccgost
+SHLIBDIRS= crypto ssl
+
+# dirs in crypto to build
+SDIRS=  \
+	objects \
+	md2 md4 md5 sha mdc2 hmac ripemd whrlpool \
+	des aes rc2 rc4 rc5 idea bf cast camellia seed modes \
+	bn ec rsa dsa ecdsa dh ecdh dso engine \
+	buffer bio stack lhash rand err \
+	evp asn1 pem x509 x509v3 conf txt_db pkcs7 pkcs12 comp ocsp ui krb5 \
+	cms pqueue ts jpake srp store cmac
+# keep in mind that the above list is adjusted by ./Configure
+# according to no-xxx arguments...
+
+# tests to perform.  "alltests" is a special word indicating that all tests
+# should be performed.
+TESTS = alltests
+
+MAKEFILE= Makefile
+
+MANDIR=/usr/share/man
+MAN1=1
+MAN3=3
+MANSUFFIX=
+HTMLSUFFIX=html
+HTMLDIR=$(OPENSSLDIR)/html
+SHELL=/bin/sh
+
+TOP=    .
+ONEDIRS=out tmp
+EDIRS=  times doc bugs util include certs ms shlib mt demos perl sf dep VMS
+WDIRS=  windows
+LIBS=   libcrypto.a libssl.a
+SHARED_CRYPTO=libcrypto$(SHLIB_EXT)
+SHARED_SSL=libssl$(SHLIB_EXT)
+SHARED_LIBS=
+SHARED_LIBS_LINK_EXTS=
+SHARED_LDFLAGS=
+
+GENERAL=        Makefile
+BASENAME=       openssl
+NAME=           $(BASENAME)-$(VERSION)
+TARFILE=        ../$(NAME).tar
+EXHEADER=       e_os2.h
+HEADER=         e_os.h
+
+all: Makefile build_all
+
+# as we stick to -e, CLEARENV ensures that local variables in lower
+# Makefiles remain local and variable. $${VAR+VAR} is tribute to Korn
+# shell, which [annoyingly enough] terminates unset with error if VAR
+# is not present:-( TOP= && unset TOP is tribute to HP-UX /bin/sh,
+# which terminates unset with error if no variable was present:-(
+CLEARENV=	TOP= && unset TOP $${LIB+LIB} $${LIBS+LIBS}	\
+		$${INCLUDE+INCLUDE} $${INCLUDES+INCLUDES}	\
+		$${DIR+DIR} $${DIRS+DIRS} $${SRC+SRC}		\
+		$${LIBSRC+LIBSRC} $${LIBOBJ+LIBOBJ} $${ALL+ALL}	\
+		$${EXHEADER+EXHEADER} $${HEADER+HEADER}		\
+		$${GENERAL+GENERAL} $${CFLAGS+CFLAGS}		\
+		$${ASFLAGS+ASFLAGS} $${AFLAGS+AFLAGS}		\
+		$${LDCMD+LDCMD} $${LDFLAGS+LDFLAGS} $${SCRIPTS+SCRIPTS}	\
+		$${SHAREDCMD+SHAREDCMD} $${SHAREDFLAGS+SHAREDFLAGS}	\
+		$${SHARED_LIB+SHARED_LIB} $${LIBEXTRAS+LIBEXTRAS}	\
+		$${APPS+APPS}
+
+# LC_ALL=C ensures that error [and other] messages are delivered in
+# same language for uniform treatment.
+BUILDENV=	LC_ALL=C PLATFORM='$(PLATFORM)' PROCESSOR='$(PROCESSOR)'\
+		CC='$(CC)' CFLAG='$(CFLAG)' 			\
+		AS='$(CC)' ASFLAG='$(CFLAG) -c'			\
+		AR='$(AR)' NM='$(NM)' RANLIB='$(RANLIB)'	\
+		RC='$(RC)'              			\
+		CROSS_COMPILE='$(CROSS_COMPILE)'	\
+		PERL='$(PERL)' ENGDIRS='$(ENGDIRS)'		\
+		SDIRS='$(SDIRS)' LIBRPATH='$(INSTALLTOP)/$(LIBDIR)'	\
+		INSTALL_PREFIX='$(INSTALL_PREFIX)'		\
+		INSTALLTOP='$(INSTALLTOP)' OPENSSLDIR='$(OPENSSLDIR)'	\
+		LIBDIR='$(LIBDIR)'				\
+		MAKEDEPEND='$$$${TOP}/util/domd $$$${TOP} -MD $(MAKEDEPPROG)' \
+		DEPFLAG='-DOPENSSL_NO_DEPRECATED $(DEPFLAG)'	\
+		MAKEDEPPROG='$(MAKEDEPPROG)'			\
+		SHARED_LDFLAGS='$(SHARED_LDFLAGS)'		\
+		KRB5_INCLUDES='$(KRB5_INCLUDES)' LIBKRB5='$(LIBKRB5)'	\
+		ZLIB_INCLUDE='$(ZLIB_INCLUDE)' LIBZLIB='$(LIBZLIB)'	\
+		EXE_EXT='$(EXE_EXT)' SHARED_LIBS='$(SHARED_LIBS)'	\
+		SHLIB_EXT='$(SHLIB_EXT)' SHLIB_TARGET='$(SHLIB_TARGET)'	\
+		PEX_LIBS='$(PEX_LIBS)' EX_LIBS='$(EX_LIBS)'	\
+		CPUID_OBJ='$(CPUID_OBJ)' BN_ASM='$(BN_ASM)'	\
+		EC_ASM='$(EC_ASM)' DES_ENC='$(DES_ENC)' 	\
+		AES_ENC='$(AES_ENC)' CMLL_ENC='$(CMLL_ENC)'	\
+		BF_ENC='$(BF_ENC)' CAST_ENC='$(CAST_ENC)'	\
+		RC4_ENC='$(RC4_ENC)' RC5_ENC='$(RC5_ENC)'	\
+		SHA1_ASM_OBJ='$(SHA1_ASM_OBJ)'			\
+		MD5_ASM_OBJ='$(MD5_ASM_OBJ)'			\
+		RMD160_ASM_OBJ='$(RMD160_ASM_OBJ)'		\
+		WP_ASM_OBJ='$(WP_ASM_OBJ)'			\
+		MODES_ASM_OBJ='$(MODES_ASM_OBJ)'		\
+		ENGINES_ASM_OBJ='$(ENGINES_ASM_OBJ)'		\
+		PERLASM_SCHEME='$(PERLASM_SCHEME)'		\
+		FIPSLIBDIR='${FIPSLIBDIR}'			\
+		FIPSDIR='${FIPSDIR}'				\
+		FIPSCANLIB="$${FIPSCANLIB:-$(FIPSCANLIB)}"	\
+		THIS=$${THIS:-$@} MAKEFILE=Makefile MAKEOVERRIDES=
+# MAKEOVERRIDES= effectively "equalizes" GNU-ish and SysV-ish make flavors,
+# which in turn eliminates ambiguities in variable treatment with -e.
+
+# BUILD_CMD is a generic macro to build a given target in a given
+# subdirectory.  The target must be given through the shell variable
+# `target' and the subdirectory to build in must be given through `dir'.
+# This macro shouldn't be used directly, use RECURSIVE_BUILD_CMD or
+# BUILD_ONE_CMD instead.
+#
+# BUILD_ONE_CMD is a macro to build a given target in a given
+# subdirectory if that subdirectory is part of $(DIRS).  It requires
+# exactly the same shell variables as BUILD_CMD.
+#
+# RECURSIVE_BUILD_CMD is a macro to build a given target in all
+# subdirectories defined in $(DIRS).  It requires that the target
+# is given through the shell variable `target'.
+BUILD_CMD=  if [ -d "$$dir" ]; then \
+	    (	cd $$dir && echo "making $$target in $$dir..." && \
+		$(CLEARENV) && $(MAKE) -e $(BUILDENV) TOP=.. DIR=$$dir $$target \
+	    ) || exit 1; \
+	    fi
+RECURSIVE_BUILD_CMD=for dir in $(DIRS); do $(BUILD_CMD); done
+BUILD_ONE_CMD=\
+	if expr " $(DIRS) " : ".* $$dir " >/dev/null 2>&1; then \
+		$(BUILD_CMD); \
+	fi
+
+reflect:
+	@[ -n "$(THIS)" ] && $(CLEARENV) && $(MAKE) $(THIS) -e $(BUILDENV)
+
+sub_all: build_all
+
+build_all: build_libs build_apps build_tests build_tools
+
+build_libs: build_libcrypto build_libssl openssl.pc
+
+build_libcrypto: build_crypto build_engines libcrypto.pc
+build_libssl: build_ssl libssl.pc
+
+build_crypto:
+	@dir=crypto; target=all; $(BUILD_ONE_CMD)
+build_ssl: build_crypto
+	@dir=ssl; target=all; $(BUILD_ONE_CMD)
+build_engines: build_crypto
+	@dir=engines; target=all; $(BUILD_ONE_CMD)
+build_apps: build_libs
+	@dir=apps; target=all; $(BUILD_ONE_CMD)
+build_tests: build_libs
+	@dir=test; target=all; $(BUILD_ONE_CMD)
+build_tools: build_libs
+	@dir=tools; target=all; $(BUILD_ONE_CMD)
+
+all_testapps: build_libs build_testapps
+build_testapps:
+	@dir=crypto; target=testapps; $(BUILD_ONE_CMD)
+
+fips_premain_dso$(EXE_EXT): libcrypto.a
+	[ -z "$(FIPSCANLIB)" ] || $(CC) $(CFLAG) -Iinclude \
+		-DFINGERPRINT_PREMAIN_DSO_LOAD -o $@  \
+		$(FIPSLIBDIR)fips_premain.c $(FIPSLIBDIR)fipscanister.o \
+		libcrypto.a $(EX_LIBS)
+
+libcrypto$(SHLIB_EXT): libcrypto.a fips_premain_dso$(EXE_EXT)
+	@if [ "$(SHLIB_TARGET)" != "" ]; then \
+		if [ "$(FIPSCANLIB)" = "libcrypto" ]; then \
+			FIPSLD_LIBCRYPTO=libcrypto.a ; \
+			FIPSLD_CC="$(CC)"; CC=$(FIPSDIR)/bin/fipsld; \
+			export CC FIPSLD_CC FIPSLD_LIBCRYPTO; \
+		fi; \
+		$(MAKE) -e SHLIBDIRS=crypto  CC="$${CC:-$(CC)}" build-shared && \
+		(touch -c fips_premain_dso$(EXE_EXT) || :); \
+	else \
+		echo "There's no support for shared libraries on this platform" >&2; \
+		exit 1; \
+	fi
+
+libssl$(SHLIB_EXT): libcrypto$(SHLIB_EXT) libssl.a
+	@if [ "$(SHLIB_TARGET)" != "" ]; then \
+		$(MAKE) SHLIBDIRS=ssl SHLIBDEPS='-lcrypto' build-shared; \
+	else \
+		echo "There's no support for shared libraries on this platform" >&2; \
+		exit 1; \
+	fi
+
+clean-shared:
+	@set -e; for i in $(SHLIBDIRS); do \
+		if [ -n "$(SHARED_LIBS_LINK_EXTS)" ]; then \
+			tmp="$(SHARED_LIBS_LINK_EXTS)"; \
+			for j in $${tmp:-x}; do \
+				( set -x; rm -f lib$$i$$j ); \
+			done; \
+		fi; \
+		( set -x; rm -f lib$$i$(SHLIB_EXT) ); \
+		if expr "$(PLATFORM)" : "Cygwin" >/dev/null; then \
+			( set -x; rm -f cyg$$i$(SHLIB_EXT) lib$$i$(SHLIB_EXT).a ); \
+		fi; \
+	done
+
+link-shared:
+	@ set -e; for i in $(SHLIBDIRS); do \
+		$(MAKE) -f $(HERE)/Makefile.shared -e $(BUILDENV) \
+			LIBNAME=$$i LIBVERSION=$(SHLIB_MAJOR).$(SHLIB_MINOR) \
+			LIBCOMPATVERSIONS=";$(SHLIB_VERSION_HISTORY)" \
+			symlink.$(SHLIB_TARGET); \
+		libs="$$libs -l$$i"; \
+	done
+
+build-shared: do_$(SHLIB_TARGET) link-shared
+
+do_$(SHLIB_TARGET):
+	@ set -e; libs='-L. $(SHLIBDEPS)'; for i in $(SHLIBDIRS); do \
+		if [ "$$i" = "ssl" -a -n "$(LIBKRB5)" ]; then \
+			libs="$(LIBKRB5) $$libs"; \
+		fi; \
+		$(CLEARENV) && $(MAKE) -f Makefile.shared -e $(BUILDENV) \
+			LIBNAME=$$i LIBVERSION=$(SHLIB_MAJOR).$(SHLIB_MINOR) \
+			LIBCOMPATVERSIONS=";$(SHLIB_VERSION_HISTORY)" \
+			LIBDEPS="$$libs $(EX_LIBS)" \
+			link_a.$(SHLIB_TARGET); \
+		libs="-l$$i $$libs"; \
+	done
+
+libcrypto.pc: Makefile
+	@ ( echo 'prefix=$(INSTALLTOP)'; \
+	    echo 'exec_prefix=$${prefix}'; \
+	    echo 'libdir=$${exec_prefix}/$(LIBDIR)'; \
+	    echo 'includedir=$${prefix}/include'; \
+	    echo 'enginesdir=$${libdir}/openssl-1.0.0/engines'; \
+	    echo ''; \
+	    echo 'Name: OpenSSL-libcrypto'; \
+	    echo 'Description: OpenSSL cryptography library'; \
+	    echo 'Version: '$(VERSION); \
+	    echo 'Requires: '; \
+	    echo 'Libs: -L$${libdir} -lcrypto'; \
+	    echo 'Libs.private: $(EX_LIBS)'; \
+	    echo 'Cflags: -I$${includedir} $(KRB5_INCLUDES)' ) > libcrypto.pc
+
+libssl.pc: Makefile
+	@ ( echo 'prefix=$(INSTALLTOP)'; \
+	    echo 'exec_prefix=$${prefix}'; \
+	    echo 'libdir=$${exec_prefix}/$(LIBDIR)'; \
+	    echo 'includedir=$${prefix}/include'; \
+	    echo ''; \
+	    echo 'Name: OpenSSL-libssl'; \
+	    echo 'Description: Secure Sockets Layer and cryptography libraries'; \
+	    echo 'Version: '$(VERSION); \
+	    echo 'Requires.private: libcrypto'; \
+	    echo 'Libs: -L$${libdir} -lssl'; \
+	    echo 'Libs.private: $(EX_LIBS)'; \
+	    echo 'Cflags: -I$${includedir} $(KRB5_INCLUDES)' ) > libssl.pc
+
+openssl.pc: Makefile
+	@ ( echo 'prefix=$(INSTALLTOP)'; \
+	    echo 'exec_prefix=$${prefix}'; \
+	    echo 'libdir=$${exec_prefix}/$(LIBDIR)'; \
+	    echo 'includedir=$${prefix}/include'; \
+	    echo ''; \
+	    echo 'Name: OpenSSL'; \
+	    echo 'Description: Secure Sockets Layer and cryptography libraries and tools'; \
+	    echo 'Version: '$(VERSION); \
+	    echo 'Requires: libssl libcrypto' ) > openssl.pc
+
+Makefile: Makefile.org Configure config
+	@echo "Makefile is older than Makefile.org, Configure or config."
+	@echo "Reconfigure the source tree (via './config' or 'perl Configure'), please."
+	@false
+
+libclean:
+	rm -f *.map *.so *.so.* *.dylib *.dll engines/*.so engines/*.dll engines/*.dylib *.a engines/*.a */lib */*/lib
+
+clean:	libclean
+	rm -f shlib/*.o *.o core a.out fluff rehash.time testlog make.log cctest cctest.c
+	@set -e; target=clean; $(RECURSIVE_BUILD_CMD)
+	rm -f $(LIBS)
+	rm -f openssl.pc libssl.pc libcrypto.pc
+	rm -f speed.* .pure
+	rm -f $(TARFILE)
+	@set -e; for i in $(ONEDIRS) ;\
+	do \
+	rm -fr $$i/*; \
+	done
+
+distclean: clean
+	-$(RM) `find . -name .git -prune -o -type l -print`
+	$(RM) apps/CA.pl
+	$(RM) test/evptests.txt test/newkey.pem test/testkey.pem test/testreq.pem
+	$(RM) tools/c_rehash
+	$(RM) crypto/opensslconf.h
+	$(RM) Makefile Makefile.bak
+
+makefile.one: files
+	$(PERL) util/mk1mf.pl >makefile.one; \
+	sh util/do_ms.sh
+
+files:
+	$(PERL) $(TOP)/util/files.pl Makefile > $(TOP)/MINFO
+	@set -e; target=files; $(RECURSIVE_BUILD_CMD)
+
+links:
+	@$(PERL) $(TOP)/util/mkdir-p.pl include/openssl
+	@$(PERL) $(TOP)/util/mklink.pl include/openssl $(EXHEADER)
+	@set -e; target=links; $(RECURSIVE_BUILD_CMD)
+
+gentests:
+	@(cd test && echo "generating dummy tests (if needed)..." && \
+	$(CLEARENV) && $(MAKE) -e $(BUILDENV) TESTS='$(TESTS)' OPENSSL_DEBUG_MEMORY=on generate );
+
+dclean:
+	rm -rf *.bak include/openssl certs/.0
+	@set -e; target=dclean; $(RECURSIVE_BUILD_CMD)
+
+rehash: rehash.time
+rehash.time: certs apps
+	@if [ -z "$(CROSS_COMPILE)" ]; then \
+		(OPENSSL="`pwd`/util/opensslwrap.sh"; \
+		[ -x "apps/openssl.exe" ] && OPENSSL="apps/openssl.exe" || :; \
+		OPENSSL_DEBUG_MEMORY=on; \
+		export OPENSSL OPENSSL_DEBUG_MEMORY; \
+		$(PERL) tools/c_rehash certs/demo) && \
+		touch rehash.time; \
+	else :; fi
+
+test:   tests
+
+tests: rehash
+	@(cd test && echo "testing..." && \
+	$(CLEARENV) && $(MAKE) -e $(BUILDENV) TOP=.. TESTS='$(TESTS)' OPENSSL_DEBUG_MEMORY=on OPENSSL_CONF=../apps/openssl.cnf tests );
+	OPENSSL_CONF=apps/openssl.cnf util/opensslwrap.sh version -a
+
+report:
+	@$(PERL) util/selftest.pl
+
+update: errors stacks util/libeay.num util/ssleay.num TABLE
+	@set -e; target=update; $(RECURSIVE_BUILD_CMD)
+
+depend:
+	@set -e; target=depend; $(RECURSIVE_BUILD_CMD)
+
+lint:
+	@set -e; target=lint; $(RECURSIVE_BUILD_CMD)
+
+tags:
+	rm -f TAGS
+	find . -name '[^.]*.[ch]' | xargs etags -a
+
+errors:
+	$(PERL) util/ck_errf.pl -strict */*.c */*/*.c
+	$(PERL) util/mkerr.pl -recurse -write
+	(cd engines; $(MAKE) PERL=$(PERL) errors)
+
+stacks:
+	$(PERL) util/mkstack.pl -write
+
+util/libeay.num::
+	$(PERL) util/mkdef.pl crypto update
+
+util/ssleay.num::
+	$(PERL) util/mkdef.pl ssl update
+
+TABLE: Configure
+	(echo 'Output of `Configure TABLE'"':"; \
+	$(PERL) Configure TABLE) > TABLE
+
+# Build distribution tar-file. As the list of files returned by "find" is
+# pretty long, on several platforms a "too many arguments" error or similar
+# would occur. Therefore the list of files is temporarily stored into a file
+# and read directly, requiring GNU-Tar. Call "make TAR=gtar dist" if the normal
+# tar does not support the --files-from option.
+TAR_COMMAND=$(TAR) $(TARFLAGS) --files-from $(TARFILE).list \
+	                       --owner 0 --group 0 \
+			       --transform 's|^|$(NAME)/|' \
+			       -cvf -
+
+$(TARFILE).list:
+	find * \! -name STATUS \! -name TABLE \! -name '*.o' \! -name '*.a' \
+	       \! -name '*.so' \! -name '*.so.*'  \! -name 'openssl' \
+	       \( \! -name '*test' -o -name bctest -o -name pod2mantest \) \
+	       \! -name '.#*' \! -name '*~' \! -type l \
+	    | sort > $(TARFILE).list
+
+tar: $(TARFILE).list
+	find . -type d -print | xargs chmod 755
+	find . -type f -print | xargs chmod a+r
+	find . -type f -perm -0100 -print | xargs chmod a+x
+	$(TAR_COMMAND) | gzip --best > $(TARFILE).gz
+	rm -f $(TARFILE).list
+	ls -l $(TARFILE).gz
+
+tar-snap: $(TARFILE).list
+	$(TAR_COMMAND) > $(TARFILE)
+	rm -f $(TARFILE).list
+	ls -l $(TARFILE)
+
+dist:   
+	$(PERL) Configure dist
+	@$(MAKE) SDIRS='$(SDIRS)' clean
+	@$(MAKE) TAR='$(TAR)' TARFLAGS='$(TARFLAGS)' $(DISTTARVARS) tar
+
+install: all install_docs install_sw
+
+install_sw:
+	@$(PERL) $(TOP)/util/mkdir-p.pl $(INSTALL_PREFIX)$(INSTALLTOP)/bin \
+		$(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR) \
+		$(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/openssl-1.0.0/engines \
+		$(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/pkgconfig \
+		$(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl \
+		$(INSTALL_PREFIX)$(OPENSSLDIR)/misc \
+		$(INSTALL_PREFIX)$(OPENSSLDIR)/certs \
+		$(INSTALL_PREFIX)$(OPENSSLDIR)/private
+	@set -e; headerlist="$(EXHEADER)"; for i in $$headerlist;\
+	do \
+	(cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i; \
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/include/openssl/$$i ); \
+	done;
+	@set -e; target=install; $(RECURSIVE_BUILD_CMD)
+	@set -e; liblist="$(LIBS)"; for i in $$liblist ;\
+	do \
+		if [ -f "$$i" ]; then \
+		(       echo installing $$i; \
+			cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i.new; \
+			$(RANLIB) $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i.new; \
+			chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i.new; \
+			mv -f $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i.new $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i ); \
+		fi; \
+	done;
+	@set -e; if [ -n "$(SHARED_LIBS)" ]; then \
+		tmp="$(SHARED_LIBS)"; \
+		for i in $${tmp:-x}; \
+		do \
+			if [ -f "$$i" -o -f "$$i.a" ]; then \
+			(       echo installing $$i; \
+				if expr "$(PLATFORM)" : "Cygwin" >/dev/null; then \
+					c=`echo $$i | sed 's/^lib\(.*\)\.dll\.a/cyg\1-$(SHLIB_VERSION_NUMBER).dll/'`; \
+					cp $$c $(INSTALL_PREFIX)$(INSTALLTOP)/bin/$$c.new; \
+					chmod 755 $(INSTALL_PREFIX)$(INSTALLTOP)/bin/$$c.new; \
+					mv -f $(INSTALL_PREFIX)$(INSTALLTOP)/bin/$$c.new $(INSTALL_PREFIX)$(INSTALLTOP)/bin/$$c; \
+					cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i.new; \
+					chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i.new; \
+					mv -f $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i.new $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i; \
+				else \
+					cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i.new; \
+					chmod 555 $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i.new; \
+					mv -f $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i.new $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/$$i; \
+				fi ); \
+				if expr $(PLATFORM) : 'mingw' > /dev/null; then \
+				(	case $$i in \
+						*crypto*) i=libeay32.dll;; \
+						*ssl*)    i=ssleay32.dll;; \
+					esac; \
+					echo installing $$i; \
+	 				cp $$i $(INSTALL_PREFIX)$(INSTALLTOP)/bin/$$i.new; \
+	 				chmod 755 $(INSTALL_PREFIX)$(INSTALLTOP)/bin/$$i.new; \
+	 				mv -f $(INSTALL_PREFIX)$(INSTALLTOP)/bin/$$i.new $(INSTALL_PREFIX)$(INSTALLTOP)/bin/$$i ); \
+				fi; \
+			fi; \
+		done; \
+		(	here="`pwd`"; \
+			cd $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR); \
+			$(MAKE) -f $$here/Makefile HERE="$$here" link-shared ); \
+		if [ "$(INSTALLTOP)" != "/usr" ]; then \
+			echo 'OpenSSL shared libraries have been installed in:'; \
+			echo '  $(INSTALLTOP)'; \
+			echo ''; \
+			sed -e '1,/^$$/d' doc/openssl-shared.txt; \
+		fi; \
+	fi
+	cp libcrypto.pc $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/pkgconfig
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/pkgconfig/libcrypto.pc
+	cp libssl.pc $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/pkgconfig
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/pkgconfig/libssl.pc
+	cp openssl.pc $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/pkgconfig
+	chmod 644 $(INSTALL_PREFIX)$(INSTALLTOP)/$(LIBDIR)/pkgconfig/openssl.pc
+
+install_html_docs:
+	here="`pwd`"; \
+	filecase=; \
+	case "$(PLATFORM)" in DJGPP|Cygwin*|mingw*|darwin*-*-cc) \
+		filecase=-i; \
+	esac; \
+	for subdir in apps crypto ssl; do \
+		mkdir -p $(INSTALL_PREFIX)$(HTMLDIR)/$$subdir; \
+		for i in doc/$$subdir/*.pod; do \
+			fn=`basename $$i .pod`; \
+			echo "installing html/$$fn.$(HTMLSUFFIX)"; \
+			cat $$i \
+			| sed -r 's/L<([^)]*)(\([0-9]\))?\|([^)]*)(\([0-9]\))?>/L<\1|\3>/g' \
+			| pod2html --podroot=doc --htmlroot=.. --podpath=apps:crypto:ssl \
+			| sed -r 's/<!DOCTYPE.*//g' \
+			> $(INSTALL_PREFIX)$(HTMLDIR)/$$subdir/$$fn.$(HTMLSUFFIX); \
+			$(PERL) util/extract-names.pl < $$i | \
+				grep -v $$filecase "^$$fn\$$" | \
+				(cd $(INSTALL_PREFIX)$(HTMLDIR)/$$subdir; \
+				 while read n; do \
+					PLATFORM=$(PLATFORM) $$here/util/point.sh $$fn.$(HTMLSUFFIX) "$$n".$(HTMLSUFFIX); \
+				 done); \
+		done; \
+	done
+
+install_docs:
+	@$(PERL) $(TOP)/util/mkdir-p.pl \
+		$(INSTALL_PREFIX)$(MANDIR)/man1 \
+		$(INSTALL_PREFIX)$(MANDIR)/man3 \
+		$(INSTALL_PREFIX)$(MANDIR)/man5 \
+		$(INSTALL_PREFIX)$(MANDIR)/man7
+	@pod2man="`cd ./util; ./pod2mantest $(PERL)`"; \
+	here="`pwd`"; \
+	filecase=; \
+	case "$(PLATFORM)" in DJGPP|Cygwin*|mingw*|darwin*-*-cc) \
+		filecase=-i; \
+	esac; \
+	set -e; for i in doc/apps/*.pod; do \
+		fn=`basename $$i .pod`; \
+		sec=`$(PERL) util/extract-section.pl 1 < $$i`; \
+		echo "installing man$$sec/$$fn.$${sec}$(MANSUFFIX)"; \
+		(cd `$(PERL) util/dirname.pl $$i`; \
+		sh -c "$$pod2man \
+			--section=$$sec --center=OpenSSL \
+			--release=$(VERSION) `basename $$i`") \
+			>  $(INSTALL_PREFIX)$(MANDIR)/man$$sec/$$fn.$${sec}$(MANSUFFIX); \
+		$(PERL) util/extract-names.pl < $$i | \
+			(grep -v $$filecase "^$$fn\$$"; true) | \
+			(grep -v "[	]"; true) | \
+			(cd $(INSTALL_PREFIX)$(MANDIR)/man$$sec/; \
+			 while read n; do \
+				PLATFORM=$(PLATFORM) $$here/util/point.sh $$fn.$${sec}$(MANSUFFIX) "$$n".$${sec}$(MANSUFFIX); \
+			 done); \
+	done; \
+	set -e; for i in doc/crypto/*.pod doc/ssl/*.pod; do \
+		fn=`basename $$i .pod`; \
+		sec=`$(PERL) util/extract-section.pl 3 < $$i`; \
+		echo "installing man$$sec/$$fn.$${sec}$(MANSUFFIX)"; \
+		(cd `$(PERL) util/dirname.pl $$i`; \
+		sh -c "$$pod2man \
+			--section=$$sec --center=OpenSSL \
+			--release=$(VERSION) `basename $$i`") \
+			>  $(INSTALL_PREFIX)$(MANDIR)/man$$sec/$$fn.$${sec}$(MANSUFFIX); \
+		$(PERL) util/extract-names.pl < $$i | \
+			(grep -v $$filecase "^$$fn\$$"; true) | \
+			(grep -v "[	]"; true) | \
+			(cd $(INSTALL_PREFIX)$(MANDIR)/man$$sec/; \
+			 while read n; do \
+				PLATFORM=$(PLATFORM) $$here/util/point.sh $$fn.$${sec}$(MANSUFFIX) "$$n".$${sec}$(MANSUFFIX); \
+			 done); \
+	done
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
diff -uNr openssl-1.0.2l.orig/Makefile.shared openssl-1.0.2l/Makefile.shared
--- openssl-1.0.2l.orig/Makefile.shared	2017-05-25 20:54:34.000000000 +0800
+++ openssl-1.0.2l/Makefile.shared	2018-07-16 17:01:21.604442726 +0800
@@ -151,9 +151,9 @@
 	SHLIB_SUFFIX=; \
 	ALLSYMSFLAGS='-Wl,--whole-archive'; \
 	NOALLSYMSFLAGS='-Wl,--no-whole-archive'; \
-	SHAREDFLAGS="$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,-Bsymbolic -Wl,-soname=$$SHLIB$$SHLIB_SOVER$$SHLIB_SUFFIX"
+	SHAREDFLAGS="$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,-soname=$$SHLIB$$SHLIB_SOVER$$SHLIB_SUFFIX"
 
-DO_GNU_APP=LDFLAGS="$(CFLAGS) -Wl,-rpath,$(LIBRPATH)"
+DO_GNU_APP=LDFLAGS="$(CFLAGS)"
 
 #This is rather special.  It's a special target with which one can link
 #applications without bothering with any features that have anything to
diff -uNr openssl-1.0.2l.orig/openssl.ld openssl-1.0.2l/openssl.ld
--- openssl-1.0.2l.orig/openssl.ld	1970-01-01 08:00:00.000000000 +0800
+++ openssl-1.0.2l/openssl.ld	2018-07-16 17:01:21.668443165 +0800
@@ -0,0 +1,4620 @@
+OPENSSL_1.0.0 {
+	global:
+		BIO_f_ssl;
+		BIO_new_buffer_ssl_connect;
+		BIO_new_ssl;
+		BIO_new_ssl_connect;
+		BIO_proxy_ssl_copy_session_id;
+		BIO_ssl_copy_session_id;
+		BIO_ssl_shutdown;
+		d2i_SSL_SESSION;
+		DTLSv1_client_method;
+		DTLSv1_method;
+		DTLSv1_server_method;
+		ERR_load_SSL_strings;
+		i2d_SSL_SESSION;
+		kssl_build_principal_2;
+		kssl_cget_tkt;
+		kssl_check_authent;
+		kssl_ctx_free;
+		kssl_ctx_new;
+		kssl_ctx_setkey;
+		kssl_ctx_setprinc;
+		kssl_ctx_setstring;
+		kssl_ctx_show;
+		kssl_err_set;
+		kssl_krb5_free_data_contents;
+		kssl_sget_tkt;
+		kssl_skip_confound;
+		kssl_validate_times;
+		PEM_read_bio_SSL_SESSION;
+		PEM_read_SSL_SESSION;
+		PEM_write_bio_SSL_SESSION;
+		PEM_write_SSL_SESSION;
+		SSL_accept;
+		SSL_add_client_CA;
+		SSL_add_dir_cert_subjects_to_stack;
+		SSL_add_dir_cert_subjs_to_stk;
+		SSL_add_file_cert_subjects_to_stack;
+		SSL_add_file_cert_subjs_to_stk;
+		SSL_alert_desc_string;
+		SSL_alert_desc_string_long;
+		SSL_alert_type_string;
+		SSL_alert_type_string_long;
+		SSL_callback_ctrl;
+		SSL_check_private_key;
+		SSL_CIPHER_description;
+		SSL_CIPHER_get_bits;
+		SSL_CIPHER_get_name;
+		SSL_CIPHER_get_version;
+		SSL_clear;
+		SSL_COMP_add_compression_method;
+		SSL_COMP_get_compression_methods;
+		SSL_COMP_get_compress_methods;
+		SSL_COMP_get_name;
+		SSL_connect;
+		SSL_copy_session_id;
+		SSL_ctrl;
+		SSL_CTX_add_client_CA;
+		SSL_CTX_add_session;
+		SSL_CTX_callback_ctrl;
+		SSL_CTX_check_private_key;
+		SSL_CTX_ctrl;
+		SSL_CTX_flush_sessions;
+		SSL_CTX_free;
+		SSL_CTX_get_cert_store;
+		SSL_CTX_get_client_CA_list;
+		SSL_CTX_get_client_cert_cb;
+		SSL_CTX_get_ex_data;
+		SSL_CTX_get_ex_new_index;
+		SSL_CTX_get_info_callback;
+		SSL_CTX_get_quiet_shutdown;
+		SSL_CTX_get_timeout;
+		SSL_CTX_get_verify_callback;
+		SSL_CTX_get_verify_depth;
+		SSL_CTX_get_verify_mode;
+		SSL_CTX_load_verify_locations;
+		SSL_CTX_new;
+		SSL_CTX_remove_session;
+		SSL_CTX_sess_get_get_cb;
+		SSL_CTX_sess_get_new_cb;
+		SSL_CTX_sess_get_remove_cb;
+		SSL_CTX_sessions;
+		SSL_CTX_sess_set_get_cb;
+		SSL_CTX_sess_set_new_cb;
+		SSL_CTX_sess_set_remove_cb;
+		SSL_CTX_set1_param;
+		SSL_CTX_set_cert_store;
+		SSL_CTX_set_cert_verify_callback;
+		SSL_CTX_set_cert_verify_cb;
+		SSL_CTX_set_cipher_list;
+		SSL_CTX_set_client_CA_list;
+		SSL_CTX_set_client_cert_cb;
+		SSL_CTX_set_client_cert_engine;
+		SSL_CTX_set_cookie_generate_cb;
+		SSL_CTX_set_cookie_verify_cb;
+		SSL_CTX_set_default_passwd_cb;
+		SSL_CTX_set_default_passwd_cb_userdata;
+		SSL_CTX_set_default_verify_paths;
+		SSL_CTX_set_def_passwd_cb_ud;
+		SSL_CTX_set_def_verify_paths;
+		SSL_CTX_set_ex_data;
+		SSL_CTX_set_generate_session_id;
+		SSL_CTX_set_info_callback;
+		SSL_CTX_set_msg_callback;
+		SSL_CTX_set_psk_client_callback;
+		SSL_CTX_set_psk_server_callback;
+		SSL_CTX_set_purpose;
+		SSL_CTX_set_quiet_shutdown;
+		SSL_CTX_set_session_id_context;
+		SSL_CTX_set_ssl_version;
+		SSL_CTX_set_timeout;
+		SSL_CTX_set_tmp_dh_callback;
+		SSL_CTX_set_tmp_ecdh_callback;
+		SSL_CTX_set_tmp_rsa_callback;
+		SSL_CTX_set_trust;
+		SSL_CTX_set_verify;
+		SSL_CTX_set_verify_depth;
+		SSL_CTX_use_cert_chain_file;
+		SSL_CTX_use_certificate;
+		SSL_CTX_use_certificate_ASN1;
+		SSL_CTX_use_certificate_chain_file;
+		SSL_CTX_use_certificate_file;
+		SSL_CTX_use_PrivateKey;
+		SSL_CTX_use_PrivateKey_ASN1;
+		SSL_CTX_use_PrivateKey_file;
+		SSL_CTX_use_psk_identity_hint;
+		SSL_CTX_use_RSAPrivateKey;
+		SSL_CTX_use_RSAPrivateKey_ASN1;
+		SSL_CTX_use_RSAPrivateKey_file;
+		SSL_do_handshake;
+		SSL_dup;
+		SSL_dup_CA_list;
+		SSLeay_add_ssl_algorithms;
+		SSL_free;
+		SSL_get1_session;
+		SSL_get_certificate;
+		SSL_get_cipher_list;
+		SSL_get_ciphers;
+		SSL_get_client_CA_list;
+		SSL_get_current_cipher;
+		SSL_get_current_compression;
+		SSL_get_current_expansion;
+		SSL_get_default_timeout;
+		SSL_get_error;
+		SSL_get_ex_data;
+		SSL_get_ex_data_X509_STORE_CTX_idx;
+		SSL_get_ex_d_X509_STORE_CTX_idx;
+		SSL_get_ex_new_index;
+		SSL_get_fd;
+		SSL_get_finished;
+		SSL_get_info_callback;
+		SSL_get_peer_cert_chain;
+		SSL_get_peer_certificate;
+		SSL_get_peer_finished;
+		SSL_get_privatekey;
+		SSL_get_psk_identity;
+		SSL_get_psk_identity_hint;
+		SSL_get_quiet_shutdown;
+		SSL_get_rbio;
+		SSL_get_read_ahead;
+		SSL_get_rfd;
+		SSL_get_servername;
+		SSL_get_servername_type;
+		SSL_get_session;
+		SSL_get_shared_ciphers;
+		SSL_get_shutdown;
+		SSL_get_SSL_CTX;
+		SSL_get_ssl_method;
+		SSL_get_verify_callback;
+		SSL_get_verify_depth;
+		SSL_get_verify_mode;
+		SSL_get_verify_result;
+		SSL_get_version;
+		SSL_get_wbio;
+		SSL_get_wfd;
+		SSL_has_matching_session_id;
+		SSL_library_init;
+		SSL_load_client_CA_file;
+		SSL_load_error_strings;
+		SSL_new;
+		SSL_peek;
+		SSL_pending;
+		SSL_read;
+		SSL_renegotiate;
+		SSL_renegotiate_pending;
+		SSL_rstate_string;
+		SSL_rstate_string_long;
+		SSL_SESSION_cmp;
+		SSL_SESSION_free;
+		SSL_SESSION_get_ex_data;
+		SSL_SESSION_get_ex_new_index;
+		SSL_SESSION_get_id;
+		SSL_SESSION_get_time;
+		SSL_SESSION_get_timeout;
+		SSL_SESSION_hash;
+		SSL_SESSION_new;
+		SSL_SESSION_print;
+		SSL_SESSION_print_fp;
+		SSL_SESSION_set_ex_data;
+		SSL_SESSION_set_time;
+		SSL_SESSION_set_timeout;
+		SSL_set1_param;
+		SSL_set_accept_state;
+		SSL_set_bio;
+		SSL_set_cipher_list;
+		SSL_set_client_CA_list;
+		SSL_set_connect_state;
+		SSL_set_ex_data;
+		SSL_set_fd;
+		SSL_set_generate_session_id;
+		SSL_set_info_callback;
+		SSL_set_msg_callback;
+		SSL_set_psk_client_callback;
+		SSL_set_psk_server_callback;
+		SSL_set_purpose;
+		SSL_set_quiet_shutdown;
+		SSL_set_read_ahead;
+		SSL_set_rfd;
+		SSL_set_session;
+		SSL_set_session_id_context;
+		SSL_set_session_secret_cb;
+		SSL_set_session_ticket_ext;
+		SSL_set_session_ticket_ext_cb;
+		SSL_set_shutdown;
+		SSL_set_SSL_CTX;
+		SSL_set_ssl_method;
+		SSL_set_tmp_dh_callback;
+		SSL_set_tmp_ecdh_callback;
+		SSL_set_tmp_rsa_callback;
+		SSL_set_trust;
+		SSL_set_verify;
+		SSL_set_verify_depth;
+		SSL_set_verify_result;
+		SSL_set_wfd;
+		SSL_shutdown;
+		SSL_state;
+		SSL_state_string;
+		SSL_state_string_long;
+		SSL_use_certificate;
+		SSL_use_certificate_ASN1;
+		SSL_use_certificate_file;
+		SSL_use_PrivateKey;
+		SSL_use_PrivateKey_ASN1;
+		SSL_use_PrivateKey_file;
+		SSL_use_psk_identity_hint;
+		SSL_use_RSAPrivateKey;
+		SSL_use_RSAPrivateKey_ASN1;
+		SSL_use_RSAPrivateKey_file;
+		SSLv23_client_method;
+		SSLv23_method;
+		SSLv23_server_method;
+		SSLv2_client_method;
+		SSLv2_method;
+		SSLv2_server_method;
+		SSLv3_client_method;
+		SSLv3_method;
+		SSLv3_server_method;
+		SSL_version;
+		SSL_want;
+		SSL_write;
+		TLSv1_client_method;
+		TLSv1_method;
+		TLSv1_server_method;
+
+
+		SSLeay;
+		SSLeay_version;
+		ASN1_BIT_STRING_asn1_meth;
+		ASN1_HEADER_free;
+		ASN1_HEADER_new;
+		ASN1_IA5STRING_asn1_meth;
+		ASN1_INTEGER_get;
+		ASN1_INTEGER_set;
+		ASN1_INTEGER_to_BN;
+		ASN1_OBJECT_create;
+		ASN1_OBJECT_free;
+		ASN1_OBJECT_new;
+		ASN1_PRINTABLE_type;
+		ASN1_STRING_cmp;
+		ASN1_STRING_dup;
+		ASN1_STRING_free;
+		ASN1_STRING_new;
+		ASN1_STRING_print;
+		ASN1_STRING_set;
+		ASN1_STRING_type_new;
+		ASN1_TYPE_free;
+		ASN1_TYPE_new;
+		ASN1_UNIVERSALSTRING_to_string;
+		ASN1_UTCTIME_check;
+		ASN1_UTCTIME_print;
+		ASN1_UTCTIME_set;
+		ASN1_check_infinite_end;
+		ASN1_d2i_bio;
+		ASN1_d2i_fp;
+		ASN1_digest;
+		ASN1_dup;
+		ASN1_get_object;
+		ASN1_i2d_bio;
+		ASN1_i2d_fp;
+		ASN1_object_size;
+		ASN1_parse;
+		ASN1_put_object;
+		ASN1_sign;
+		ASN1_verify;
+		BF_cbc_encrypt;
+		BF_cfb64_encrypt;
+		BF_ecb_encrypt;
+		BF_encrypt;
+		BF_ofb64_encrypt;
+		BF_options;
+		BF_set_key;
+		BIO_CONNECT_free;
+		BIO_CONNECT_new;
+		BIO_accept;
+		BIO_ctrl;
+		BIO_int_ctrl;
+		BIO_debug_callback;
+		BIO_dump;
+		BIO_dup_chain;
+		BIO_f_base64;
+		BIO_f_buffer;
+		BIO_f_cipher;
+		BIO_f_md;
+		BIO_f_null;
+		BIO_f_proxy_server;
+		BIO_fd_non_fatal_error;
+		BIO_fd_should_retry;
+		BIO_find_type;
+		BIO_free;
+		BIO_free_all;
+		BIO_get_accept_socket;
+		BIO_get_filter_bio;
+		BIO_get_host_ip;
+		BIO_get_port;
+		BIO_get_retry_BIO;
+		BIO_get_retry_reason;
+		BIO_gethostbyname;
+		BIO_gets;
+		BIO_new;
+		BIO_new_accept;
+		BIO_new_connect;
+		BIO_new_fd;
+		BIO_new_file;
+		BIO_new_fp;
+		BIO_new_socket;
+		BIO_pop;
+		BIO_printf;
+		BIO_push;
+		BIO_puts;
+		BIO_read;
+		BIO_s_accept;
+		BIO_s_connect;
+		BIO_s_fd;
+		BIO_s_file;
+		BIO_s_mem;
+		BIO_s_null;
+		BIO_s_proxy_client;
+		BIO_s_socket;
+		BIO_set;
+		BIO_set_cipher;
+		BIO_set_tcp_ndelay;
+		BIO_sock_cleanup;
+		BIO_sock_error;
+		BIO_sock_init;
+		BIO_sock_non_fatal_error;
+		BIO_sock_should_retry;
+		BIO_socket_ioctl;
+		BIO_write;
+		BN_CTX_free;
+		BN_CTX_new;
+		BN_MONT_CTX_free;
+		BN_MONT_CTX_new;
+		BN_MONT_CTX_set;
+		BN_add;
+		BN_add_word;
+		BN_hex2bn;
+		BN_bin2bn;
+		BN_bn2hex;
+		BN_bn2bin;
+		BN_clear;
+		BN_clear_bit;
+		BN_clear_free;
+		BN_cmp;
+		BN_copy;
+		BN_div;
+		BN_div_word;
+		BN_dup;
+		BN_free;
+		BN_from_montgomery;
+		BN_gcd;
+		BN_generate_prime;
+		BN_get_word;
+		BN_is_bit_set;
+		BN_is_prime;
+		BN_lshift;
+		BN_lshift1;
+		BN_mask_bits;
+		BN_mod;
+		BN_mod_exp;
+		BN_mod_exp_mont;
+		BN_mod_exp_simple;
+		BN_mod_inverse;
+		BN_mod_mul;
+		BN_mod_mul_montgomery;
+		BN_mod_word;
+		BN_mul;
+		BN_new;
+		BN_num_bits;
+		BN_num_bits_word;
+		BN_options;
+		BN_print;
+		BN_print_fp;
+		BN_rand;
+		BN_reciprocal;
+		BN_rshift;
+		BN_rshift1;
+		BN_set_bit;
+		BN_set_word;
+		BN_sqr;
+		BN_sub;
+		BN_to_ASN1_INTEGER;
+		BN_ucmp;
+		BN_value_one;
+		BUF_MEM_free;
+		BUF_MEM_grow;
+		BUF_MEM_new;
+		BUF_strdup;
+		CONF_free;
+		CONF_get_number;
+		CONF_get_section;
+		CONF_get_string;
+		CONF_load;
+		CRYPTO_add_lock;
+		CRYPTO_dbg_free;
+		CRYPTO_dbg_malloc;
+		CRYPTO_dbg_realloc;
+		CRYPTO_dbg_remalloc;
+		CRYPTO_free;
+		CRYPTO_get_add_lock_callback;
+		CRYPTO_get_id_callback;
+		CRYPTO_get_lock_name;
+		CRYPTO_get_locking_callback;
+		CRYPTO_get_mem_functions;
+		CRYPTO_lock;
+		CRYPTO_malloc;
+		CRYPTO_mem_ctrl;
+		CRYPTO_mem_leaks;
+		CRYPTO_mem_leaks_cb;
+		CRYPTO_mem_leaks_fp;
+		CRYPTO_realloc;
+		CRYPTO_remalloc;
+		CRYPTO_set_add_lock_callback;
+		CRYPTO_set_id_callback;
+		CRYPTO_set_locking_callback;
+		CRYPTO_set_mem_functions;
+		CRYPTO_thread_id;
+		DH_check;
+		DH_compute_key;
+		DH_free;
+		DH_generate_key;
+		DH_generate_parameters;
+		DH_new;
+		DH_size;
+		DHparams_print;
+		DHparams_print_fp;
+		DSA_free;
+		DSA_generate_key;
+		DSA_generate_parameters;
+		DSA_is_prime;
+		DSA_new;
+		DSA_print;
+		DSA_print_fp;
+		DSA_sign;
+		DSA_sign_setup;
+		DSA_size;
+		DSA_verify;
+		DSAparams_print;
+		DSAparams_print_fp;
+		ERR_clear_error;
+		ERR_error_string;
+		ERR_free_strings;
+		ERR_func_error_string;
+		ERR_get_err_state_table;
+		ERR_get_error;
+		ERR_get_error_line;
+		ERR_get_state;
+		ERR_get_string_table;
+		ERR_lib_error_string;
+		ERR_load_ASN1_strings;
+		ERR_load_BIO_strings;
+		ERR_load_BN_strings;
+		ERR_load_BUF_strings;
+		ERR_load_CONF_strings;
+		ERR_load_DH_strings;
+		ERR_load_DSA_strings;
+		ERR_load_ERR_strings;
+		ERR_load_EVP_strings;
+		ERR_load_OBJ_strings;
+		ERR_load_PEM_strings;
+		ERR_load_PROXY_strings;
+		ERR_load_RSA_strings;
+		ERR_load_X509_strings;
+		ERR_load_crypto_strings;
+		ERR_load_strings;
+		ERR_peek_error;
+		ERR_peek_error_line;
+		ERR_print_errors;
+		ERR_print_errors_fp;
+		ERR_put_error;
+		ERR_reason_error_string;
+		ERR_remove_state;
+		EVP_BytesToKey;
+		EVP_CIPHER_CTX_cleanup;
+		EVP_CipherFinal;
+		EVP_CipherInit;
+		EVP_CipherUpdate;
+		EVP_DecodeBlock;
+		EVP_DecodeFinal;
+		EVP_DecodeInit;
+		EVP_DecodeUpdate;
+		EVP_DecryptFinal;
+		EVP_DecryptInit;
+		EVP_DecryptUpdate;
+		EVP_DigestFinal;
+		EVP_DigestInit;
+		EVP_DigestUpdate;
+		EVP_EncodeBlock;
+		EVP_EncodeFinal;
+		EVP_EncodeInit;
+		EVP_EncodeUpdate;
+		EVP_EncryptFinal;
+		EVP_EncryptInit;
+		EVP_EncryptUpdate;
+		EVP_OpenFinal;
+		EVP_OpenInit;
+		EVP_PKEY_assign;
+		EVP_PKEY_copy_parameters;
+		EVP_PKEY_free;
+		EVP_PKEY_missing_parameters;
+		EVP_PKEY_new;
+		EVP_PKEY_save_parameters;
+		EVP_PKEY_size;
+		EVP_PKEY_type;
+		EVP_SealFinal;
+		EVP_SealInit;
+		EVP_SignFinal;
+		EVP_VerifyFinal;
+		EVP_add_alias;
+		EVP_add_cipher;
+		EVP_add_digest;
+		EVP_bf_cbc;
+		EVP_bf_cfb64;
+		EVP_bf_ecb;
+		EVP_bf_ofb;
+		EVP_cleanup;
+		EVP_des_cbc;
+		EVP_des_cfb64;
+		EVP_des_ecb;
+		EVP_des_ede;
+		EVP_des_ede3;
+		EVP_des_ede3_cbc;
+		EVP_des_ede3_cfb64;
+		EVP_des_ede3_ofb;
+		EVP_des_ede_cbc;
+		EVP_des_ede_cfb64;
+		EVP_des_ede_ofb;
+		EVP_des_ofb;
+		EVP_desx_cbc;
+		EVP_dss;
+		EVP_dss1;
+		EVP_enc_null;
+		EVP_get_cipherbyname;
+		EVP_get_digestbyname;
+		EVP_get_pw_prompt;
+		EVP_idea_cbc;
+		EVP_idea_cfb64;
+		EVP_idea_ecb;
+		EVP_idea_ofb;
+		EVP_md2;
+		EVP_md5;
+		EVP_md_null;
+		EVP_rc2_cbc;
+		EVP_rc2_cfb64;
+		EVP_rc2_ecb;
+		EVP_rc2_ofb;
+		EVP_rc4;
+		EVP_read_pw_string;
+		EVP_set_pw_prompt;
+		EVP_sha;
+		EVP_sha1;
+		MD2;
+		MD2_Final;
+		MD2_Init;
+		MD2_Update;
+		MD2_options;
+		MD5;
+		MD5_Final;
+		MD5_Init;
+		MD5_Update;
+		MDC2;
+		MDC2_Final;
+		MDC2_Init;
+		MDC2_Update;
+		NETSCAPE_SPKAC_free;
+		NETSCAPE_SPKAC_new;
+		NETSCAPE_SPKI_free;
+		NETSCAPE_SPKI_new;
+		NETSCAPE_SPKI_sign;
+		NETSCAPE_SPKI_verify;
+		OBJ_add_object;
+		OBJ_bsearch;
+		OBJ_cleanup;
+		OBJ_cmp;
+		OBJ_create;
+		OBJ_dup;
+		OBJ_ln2nid;
+		OBJ_new_nid;
+		OBJ_nid2ln;
+		OBJ_nid2obj;
+		OBJ_nid2sn;
+		OBJ_obj2nid;
+		OBJ_sn2nid;
+		OBJ_txt2nid;
+		PEM_ASN1_read;
+		PEM_ASN1_read_bio;
+		PEM_ASN1_write;
+		PEM_ASN1_write_bio;
+		PEM_SealFinal;
+		PEM_SealInit;
+		PEM_SealUpdate;
+		PEM_SignFinal;
+		PEM_SignInit;
+		PEM_SignUpdate;
+		PEM_X509_INFO_read;
+		PEM_X509_INFO_read_bio;
+		PEM_X509_INFO_write_bio;
+		PEM_dek_info;
+		PEM_do_header;
+		PEM_get_EVP_CIPHER_INFO;
+		PEM_proc_type;
+		PEM_read;
+		PEM_read_DHparams;
+		PEM_read_DSAPrivateKey;
+		PEM_read_DSAparams;
+		PEM_read_PKCS7;
+		PEM_read_PrivateKey;
+		PEM_read_RSAPrivateKey;
+		PEM_read_X509;
+		PEM_read_X509_CRL;
+		PEM_read_X509_REQ;
+		PEM_read_bio;
+		PEM_read_bio_DHparams;
+		PEM_read_bio_DSAPrivateKey;
+		PEM_read_bio_DSAparams;
+		PEM_read_bio_PKCS7;
+		PEM_read_bio_PrivateKey;
+		PEM_read_bio_RSAPrivateKey;
+		PEM_read_bio_X509;
+		PEM_read_bio_X509_CRL;
+		PEM_read_bio_X509_REQ;
+		PEM_write;
+		PEM_write_DHparams;
+		PEM_write_DSAPrivateKey;
+		PEM_write_DSAparams;
+		PEM_write_PKCS7;
+		PEM_write_PrivateKey;
+		PEM_write_RSAPrivateKey;
+		PEM_write_X509;
+		PEM_write_X509_CRL;
+		PEM_write_X509_REQ;
+		PEM_write_bio;
+		PEM_write_bio_DHparams;
+		PEM_write_bio_DSAPrivateKey;
+		PEM_write_bio_DSAparams;
+		PEM_write_bio_PKCS7;
+		PEM_write_bio_PrivateKey;
+		PEM_write_bio_RSAPrivateKey;
+		PEM_write_bio_X509;
+		PEM_write_bio_X509_CRL;
+		PEM_write_bio_X509_REQ;
+		PKCS7_DIGEST_free;
+		PKCS7_DIGEST_new;
+		PKCS7_ENCRYPT_free;
+		PKCS7_ENCRYPT_new;
+		PKCS7_ENC_CONTENT_free;
+		PKCS7_ENC_CONTENT_new;
+		PKCS7_ENVELOPE_free;
+		PKCS7_ENVELOPE_new;
+		PKCS7_ISSUER_AND_SERIAL_digest;
+		PKCS7_ISSUER_AND_SERIAL_free;
+		PKCS7_ISSUER_AND_SERIAL_new;
+		PKCS7_RECIP_INFO_free;
+		PKCS7_RECIP_INFO_new;
+		PKCS7_SIGNED_free;
+		PKCS7_SIGNED_new;
+		PKCS7_SIGNER_INFO_free;
+		PKCS7_SIGNER_INFO_new;
+		PKCS7_SIGN_ENVELOPE_free;
+		PKCS7_SIGN_ENVELOPE_new;
+		PKCS7_dup;
+		PKCS7_free;
+		PKCS7_new;
+		PROXY_ENTRY_add_noproxy;
+		PROXY_ENTRY_clear_noproxy;
+		PROXY_ENTRY_free;
+		PROXY_ENTRY_get_noproxy;
+		PROXY_ENTRY_new;
+		PROXY_ENTRY_set_server;
+		PROXY_add_noproxy;
+		PROXY_add_server;
+		PROXY_check_by_host;
+		PROXY_check_url;
+		PROXY_clear_noproxy;
+		PROXY_free;
+		PROXY_get_noproxy;
+		PROXY_get_proxies;
+		PROXY_get_proxy_entry;
+		PROXY_load_conf;
+		PROXY_new;
+		PROXY_print;
+		RAND_bytes;
+		RAND_cleanup;
+		RAND_file_name;
+		RAND_load_file;
+		RAND_screen;
+		RAND_seed;
+		RAND_write_file;
+		RC2_cbc_encrypt;
+		RC2_cfb64_encrypt;
+		RC2_ecb_encrypt;
+		RC2_encrypt;
+		RC2_ofb64_encrypt;
+		RC2_set_key;
+		RC4;
+		RC4_options;
+		RC4_set_key;
+		RSAPrivateKey_asn1_meth;
+		RSAPrivateKey_dup;
+		RSAPublicKey_dup;
+		RSA_PKCS1_SSLeay;
+		RSA_free;
+		RSA_generate_key;
+		RSA_new;
+		RSA_new_method;
+		RSA_print;
+		RSA_print_fp;
+		RSA_private_decrypt;
+		RSA_private_encrypt;
+		RSA_public_decrypt;
+		RSA_public_encrypt;
+		RSA_set_default_method;
+		RSA_sign;
+		RSA_sign_ASN1_OCTET_STRING;
+		RSA_size;
+		RSA_verify;
+		RSA_verify_ASN1_OCTET_STRING;
+		SHA;
+		SHA1;
+		SHA1_Final;
+		SHA1_Init;
+		SHA1_Update;
+		SHA_Final;
+		SHA_Init;
+		SHA_Update;
+		OpenSSL_add_all_algorithms;
+		OpenSSL_add_all_ciphers;
+		OpenSSL_add_all_digests;
+		TXT_DB_create_index;
+		TXT_DB_free;
+		TXT_DB_get_by_index;
+		TXT_DB_insert;
+		TXT_DB_read;
+		TXT_DB_write;
+		X509_ALGOR_free;
+		X509_ALGOR_new;
+		X509_ATTRIBUTE_free;
+		X509_ATTRIBUTE_new;
+		X509_CINF_free;
+		X509_CINF_new;
+		X509_CRL_INFO_free;
+		X509_CRL_INFO_new;
+		X509_CRL_add_ext;
+		X509_CRL_cmp;
+		X509_CRL_delete_ext;
+		X509_CRL_dup;
+		X509_CRL_free;
+		X509_CRL_get_ext;
+		X509_CRL_get_ext_by_NID;
+		X509_CRL_get_ext_by_OBJ;
+		X509_CRL_get_ext_by_critical;
+		X509_CRL_get_ext_count;
+		X509_CRL_new;
+		X509_CRL_sign;
+		X509_CRL_verify;
+		X509_EXTENSION_create_by_NID;
+		X509_EXTENSION_create_by_OBJ;
+		X509_EXTENSION_dup;
+		X509_EXTENSION_free;
+		X509_EXTENSION_get_critical;
+		X509_EXTENSION_get_data;
+		X509_EXTENSION_get_object;
+		X509_EXTENSION_new;
+		X509_EXTENSION_set_critical;
+		X509_EXTENSION_set_data;
+		X509_EXTENSION_set_object;
+		X509_INFO_free;
+		X509_INFO_new;
+		X509_LOOKUP_by_alias;
+		X509_LOOKUP_by_fingerprint;
+		X509_LOOKUP_by_issuer_serial;
+		X509_LOOKUP_by_subject;
+		X509_LOOKUP_ctrl;
+		X509_LOOKUP_file;
+		X509_LOOKUP_free;
+		X509_LOOKUP_hash_dir;
+		X509_LOOKUP_init;
+		X509_LOOKUP_new;
+		X509_LOOKUP_shutdown;
+		X509_NAME_ENTRY_create_by_NID;
+		X509_NAME_ENTRY_create_by_OBJ;
+		X509_NAME_ENTRY_dup;
+		X509_NAME_ENTRY_free;
+		X509_NAME_ENTRY_get_data;
+		X509_NAME_ENTRY_get_object;
+		X509_NAME_ENTRY_new;
+		X509_NAME_ENTRY_set_data;
+		X509_NAME_ENTRY_set_object;
+		X509_NAME_add_entry;
+		X509_NAME_cmp;
+		X509_NAME_delete_entry;
+		X509_NAME_digest;
+		X509_NAME_dup;
+		X509_NAME_entry_count;
+		X509_NAME_free;
+		X509_NAME_get_entry;
+		X509_NAME_get_index_by_NID;
+		X509_NAME_get_index_by_OBJ;
+		X509_NAME_get_text_by_NID;
+		X509_NAME_get_text_by_OBJ;
+		X509_NAME_hash;
+		X509_NAME_new;
+		X509_NAME_oneline;
+		X509_NAME_print;
+		X509_NAME_set;
+		X509_OBJECT_free_contents;
+		X509_OBJECT_retrieve_by_subject;
+		X509_OBJECT_up_ref_count;
+		X509_PKEY_free;
+		X509_PKEY_new;
+		X509_PUBKEY_free;
+		X509_PUBKEY_get;
+		X509_PUBKEY_new;
+		X509_PUBKEY_set;
+		X509_REQ_INFO_free;
+		X509_REQ_INFO_new;
+		X509_REQ_dup;
+		X509_REQ_free;
+		X509_REQ_get_pubkey;
+		X509_REQ_new;
+		X509_REQ_print;
+		X509_REQ_print_fp;
+		X509_REQ_set_pubkey;
+		X509_REQ_set_subject_name;
+		X509_REQ_set_version;
+		X509_REQ_sign;
+		X509_REQ_to_X509;
+		X509_REQ_verify;
+		X509_REVOKED_add_ext;
+		X509_REVOKED_delete_ext;
+		X509_REVOKED_free;
+		X509_REVOKED_get_ext;
+		X509_REVOKED_get_ext_by_NID;
+		X509_REVOKED_get_ext_by_OBJ;
+		X509_REVOKED_get_ext_by_critical;
+		X509_REVOKED_get_ext_by_critic;
+		X509_REVOKED_get_ext_count;
+		X509_REVOKED_new;
+		X509_SIG_free;
+		X509_SIG_new;
+		X509_STORE_CTX_cleanup;
+		X509_STORE_CTX_init;
+		X509_STORE_add_cert;
+		X509_STORE_add_lookup;
+		X509_STORE_free;
+		X509_STORE_get_by_subject;
+		X509_STORE_load_locations;
+		X509_STORE_new;
+		X509_STORE_set_default_paths;
+		X509_VAL_free;
+		X509_VAL_new;
+		X509_add_ext;
+		X509_asn1_meth;
+		X509_certificate_type;
+		X509_check_private_key;
+		X509_cmp_current_time;
+		X509_delete_ext;
+		X509_digest;
+		X509_dup;
+		X509_free;
+		X509_get_default_cert_area;
+		X509_get_default_cert_dir;
+		X509_get_default_cert_dir_env;
+		X509_get_default_cert_file;
+		X509_get_default_cert_file_env;
+		X509_get_default_private_dir;
+		X509_get_ext;
+		X509_get_ext_by_NID;
+		X509_get_ext_by_OBJ;
+		X509_get_ext_by_critical;
+		X509_get_ext_count;
+		X509_get_issuer_name;
+		X509_get_pubkey;
+		X509_get_pubkey_parameters;
+		X509_get_serialNumber;
+		X509_get_subject_name;
+		X509_gmtime_adj;
+		X509_issuer_and_serial_cmp;
+		X509_issuer_and_serial_hash;
+		X509_issuer_name_cmp;
+		X509_issuer_name_hash;
+		X509_load_cert_file;
+		X509_new;
+		X509_print;
+		X509_print_fp;
+		X509_set_issuer_name;
+		X509_set_notAfter;
+		X509_set_notBefore;
+		X509_set_pubkey;
+		X509_set_serialNumber;
+		X509_set_subject_name;
+		X509_set_version;
+		X509_sign;
+		X509_subject_name_cmp;
+		X509_subject_name_hash;
+		X509_to_X509_REQ;
+		X509_verify;
+		X509_verify_cert;
+		X509_verify_cert_error_string;
+		X509v3_add_ext;
+		X509v3_add_extension;
+		X509v3_add_netscape_extensions;
+		X509v3_add_standard_extensions;
+		X509v3_cleanup_extensions;
+		X509v3_data_type_by_NID;
+		X509v3_data_type_by_OBJ;
+		X509v3_delete_ext;
+		X509v3_get_ext;
+		X509v3_get_ext_by_NID;
+		X509v3_get_ext_by_OBJ;
+		X509v3_get_ext_by_critical;
+		X509v3_get_ext_count;
+		X509v3_pack_string;
+		X509v3_pack_type_by_NID;
+		X509v3_pack_type_by_OBJ;
+		X509v3_unpack_string;
+		_des_crypt;
+		a2d_ASN1_OBJECT;
+		a2i_ASN1_INTEGER;
+		a2i_ASN1_STRING;
+		asn1_Finish;
+		asn1_GetSequence;
+		bn_div_words;
+		bn_expand2;
+		bn_mul_add_words;
+		bn_mul_words;
+		BN_uadd;
+		BN_usub;
+		bn_sqr_words;
+		_ossl_old_crypt;
+		d2i_ASN1_BIT_STRING;
+		d2i_ASN1_BOOLEAN;
+		d2i_ASN1_HEADER;
+		d2i_ASN1_IA5STRING;
+		d2i_ASN1_INTEGER;
+		d2i_ASN1_OBJECT;
+		d2i_ASN1_OCTET_STRING;
+		d2i_ASN1_PRINTABLE;
+		d2i_ASN1_PRINTABLESTRING;
+		d2i_ASN1_SET;
+		d2i_ASN1_T61STRING;
+		d2i_ASN1_TYPE;
+		d2i_ASN1_UTCTIME;
+		d2i_ASN1_bytes;
+		d2i_ASN1_type_bytes;
+		d2i_DHparams;
+		d2i_DSAPrivateKey;
+		d2i_DSAPrivateKey_bio;
+		d2i_DSAPrivateKey_fp;
+		d2i_DSAPublicKey;
+		d2i_DSAparams;
+		d2i_NETSCAPE_SPKAC;
+		d2i_NETSCAPE_SPKI;
+		d2i_Netscape_RSA;
+		d2i_PKCS7;
+		d2i_PKCS7_DIGEST;
+		d2i_PKCS7_ENCRYPT;
+		d2i_PKCS7_ENC_CONTENT;
+		d2i_PKCS7_ENVELOPE;
+		d2i_PKCS7_ISSUER_AND_SERIAL;
+		d2i_PKCS7_RECIP_INFO;
+		d2i_PKCS7_SIGNED;
+		d2i_PKCS7_SIGNER_INFO;
+		d2i_PKCS7_SIGN_ENVELOPE;
+		d2i_PKCS7_bio;
+		d2i_PKCS7_fp;
+		d2i_PrivateKey;
+		d2i_PublicKey;
+		d2i_RSAPrivateKey;
+		d2i_RSAPrivateKey_bio;
+		d2i_RSAPrivateKey_fp;
+		d2i_RSAPublicKey;
+		d2i_X509;
+		d2i_X509_ALGOR;
+		d2i_X509_ATTRIBUTE;
+		d2i_X509_CINF;
+		d2i_X509_CRL;
+		d2i_X509_CRL_INFO;
+		d2i_X509_CRL_bio;
+		d2i_X509_CRL_fp;
+		d2i_X509_EXTENSION;
+		d2i_X509_NAME;
+		d2i_X509_NAME_ENTRY;
+		d2i_X509_PKEY;
+		d2i_X509_PUBKEY;
+		d2i_X509_REQ;
+		d2i_X509_REQ_INFO;
+		d2i_X509_REQ_bio;
+		d2i_X509_REQ_fp;
+		d2i_X509_REVOKED;
+		d2i_X509_SIG;
+		d2i_X509_VAL;
+		d2i_X509_bio;
+		d2i_X509_fp;
+		DES_cbc_cksum;
+		DES_cbc_encrypt;
+		DES_cblock_print_file;
+		DES_cfb64_encrypt;
+		DES_cfb_encrypt;
+		DES_decrypt3;
+		DES_ecb3_encrypt;
+		DES_ecb_encrypt;
+		DES_ede3_cbc_encrypt;
+		DES_ede3_cfb64_encrypt;
+		DES_ede3_ofb64_encrypt;
+		DES_enc_read;
+		DES_enc_write;
+		DES_encrypt1;
+		DES_encrypt2;
+		DES_encrypt3;
+		DES_fcrypt;
+		DES_is_weak_key;
+		DES_key_sched;
+		DES_ncbc_encrypt;
+		DES_ofb64_encrypt;
+		DES_ofb_encrypt;
+		DES_options;
+		DES_pcbc_encrypt;
+		DES_quad_cksum;
+		DES_random_key;
+		_ossl_old_des_random_seed;
+		_ossl_old_des_read_2passwords;
+		_ossl_old_des_read_password;
+		_ossl_old_des_read_pw;
+		_ossl_old_des_read_pw_string;
+		DES_set_key;
+		DES_set_odd_parity;
+		DES_string_to_2keys;
+		DES_string_to_key;
+		DES_xcbc_encrypt;
+		DES_xwhite_in2out;
+		fcrypt_body;
+		i2a_ASN1_INTEGER;
+		i2a_ASN1_OBJECT;
+		i2a_ASN1_STRING;
+		i2d_ASN1_BIT_STRING;
+		i2d_ASN1_BOOLEAN;
+		i2d_ASN1_HEADER;
+		i2d_ASN1_IA5STRING;
+		i2d_ASN1_INTEGER;
+		i2d_ASN1_OBJECT;
+		i2d_ASN1_OCTET_STRING;
+		i2d_ASN1_PRINTABLE;
+		i2d_ASN1_SET;
+		i2d_ASN1_TYPE;
+		i2d_ASN1_UTCTIME;
+		i2d_ASN1_bytes;
+		i2d_DHparams;
+		i2d_DSAPrivateKey;
+		i2d_DSAPrivateKey_bio;
+		i2d_DSAPrivateKey_fp;
+		i2d_DSAPublicKey;
+		i2d_DSAparams;
+		i2d_NETSCAPE_SPKAC;
+		i2d_NETSCAPE_SPKI;
+		i2d_Netscape_RSA;
+		i2d_PKCS7;
+		i2d_PKCS7_DIGEST;
+		i2d_PKCS7_ENCRYPT;
+		i2d_PKCS7_ENC_CONTENT;
+		i2d_PKCS7_ENVELOPE;
+		i2d_PKCS7_ISSUER_AND_SERIAL;
+		i2d_PKCS7_RECIP_INFO;
+		i2d_PKCS7_SIGNED;
+		i2d_PKCS7_SIGNER_INFO;
+		i2d_PKCS7_SIGN_ENVELOPE;
+		i2d_PKCS7_bio;
+		i2d_PKCS7_fp;
+		i2d_PrivateKey;
+		i2d_PublicKey;
+		i2d_RSAPrivateKey;
+		i2d_RSAPrivateKey_bio;
+		i2d_RSAPrivateKey_fp;
+		i2d_RSAPublicKey;
+		i2d_X509;
+		i2d_X509_ALGOR;
+		i2d_X509_ATTRIBUTE;
+		i2d_X509_CINF;
+		i2d_X509_CRL;
+		i2d_X509_CRL_INFO;
+		i2d_X509_CRL_bio;
+		i2d_X509_CRL_fp;
+		i2d_X509_EXTENSION;
+		i2d_X509_NAME;
+		i2d_X509_NAME_ENTRY;
+		i2d_X509_PKEY;
+		i2d_X509_PUBKEY;
+		i2d_X509_REQ;
+		i2d_X509_REQ_INFO;
+		i2d_X509_REQ_bio;
+		i2d_X509_REQ_fp;
+		i2d_X509_REVOKED;
+		i2d_X509_SIG;
+		i2d_X509_VAL;
+		i2d_X509_bio;
+		i2d_X509_fp;
+		idea_cbc_encrypt;
+		idea_cfb64_encrypt;
+		idea_ecb_encrypt;
+		idea_encrypt;
+		idea_ofb64_encrypt;
+		idea_options;
+		idea_set_decrypt_key;
+		idea_set_encrypt_key;
+		lh_delete;
+		lh_doall;
+		lh_doall_arg;
+		lh_free;
+		lh_insert;
+		lh_new;
+		lh_node_stats;
+		lh_node_stats_bio;
+		lh_node_usage_stats;
+		lh_node_usage_stats_bio;
+		lh_retrieve;
+		lh_stats;
+		lh_stats_bio;
+		lh_strhash;
+		sk_delete;
+		sk_delete_ptr;
+		sk_dup;
+		sk_find;
+		sk_free;
+		sk_insert;
+		sk_new;
+		sk_pop;
+		sk_pop_free;
+		sk_push;
+		sk_set_cmp_func;
+		sk_shift;
+		sk_unshift;
+		sk_zero;
+		BIO_f_nbio_test;
+		ASN1_TYPE_get;
+		ASN1_TYPE_set;
+		PKCS7_content_free;
+		ERR_load_PKCS7_strings;
+		X509_find_by_issuer_and_serial;
+		X509_find_by_subject;
+		PKCS7_ctrl;
+		PKCS7_set_type;
+		PKCS7_set_content;
+		PKCS7_SIGNER_INFO_set;
+		PKCS7_add_signer;
+		PKCS7_add_certificate;
+		PKCS7_add_crl;
+		PKCS7_content_new;
+		PKCS7_dataSign;
+		PKCS7_dataVerify;
+		PKCS7_dataInit;
+		PKCS7_add_signature;
+		PKCS7_cert_from_signer_info;
+		PKCS7_get_signer_info;
+		EVP_delete_alias;
+		EVP_mdc2;
+		PEM_read_bio_RSAPublicKey;
+		PEM_write_bio_RSAPublicKey;
+		d2i_RSAPublicKey_bio;
+		i2d_RSAPublicKey_bio;
+		PEM_read_RSAPublicKey;
+		PEM_write_RSAPublicKey;
+		d2i_RSAPublicKey_fp;
+		i2d_RSAPublicKey_fp;
+		BIO_copy_next_retry;
+		RSA_flags;
+		X509_STORE_add_crl;
+		X509_load_crl_file;
+		EVP_rc2_40_cbc;
+		EVP_rc4_40;
+		EVP_CIPHER_CTX_init;
+		HMAC;
+		HMAC_Init;
+		HMAC_Update;
+		HMAC_Final;
+		ERR_get_next_error_library;
+		EVP_PKEY_cmp_parameters;
+		HMAC_cleanup;
+		BIO_ptr_ctrl;
+		BIO_new_file_internal;
+		BIO_new_fp_internal;
+		BIO_s_file_internal;
+		BN_BLINDING_convert;
+		BN_BLINDING_invert;
+		BN_BLINDING_update;
+		RSA_blinding_on;
+		RSA_blinding_off;
+		i2t_ASN1_OBJECT;
+		BN_BLINDING_new;
+		BN_BLINDING_free;
+		EVP_cast5_cbc;
+		EVP_cast5_cfb64;
+		EVP_cast5_ecb;
+		EVP_cast5_ofb;
+		BF_decrypt;
+		CAST_set_key;
+		CAST_encrypt;
+		CAST_decrypt;
+		CAST_ecb_encrypt;
+		CAST_cbc_encrypt;
+		CAST_cfb64_encrypt;
+		CAST_ofb64_encrypt;
+		RC2_decrypt;
+		OBJ_create_objects;
+		BN_exp;
+		BN_mul_word;
+		BN_sub_word;
+		BN_dec2bn;
+		BN_bn2dec;
+		BIO_ghbn_ctrl;
+		CRYPTO_free_ex_data;
+		CRYPTO_get_ex_data;
+		CRYPTO_set_ex_data;
+		ERR_load_CRYPTO_strings;
+		ERR_load_CRYPTOlib_strings;
+		EVP_PKEY_bits;
+		MD5_Transform;
+		SHA1_Transform;
+		SHA_Transform;
+		X509_STORE_CTX_get_chain;
+		X509_STORE_CTX_get_current_cert;
+		X509_STORE_CTX_get_error;
+		X509_STORE_CTX_get_error_depth;
+		X509_STORE_CTX_get_ex_data;
+		X509_STORE_CTX_set_cert;
+		X509_STORE_CTX_set_chain;
+		X509_STORE_CTX_set_error;
+		X509_STORE_CTX_set_ex_data;
+		CRYPTO_dup_ex_data;
+		CRYPTO_get_new_lockid;
+		CRYPTO_new_ex_data;
+		RSA_set_ex_data;
+		RSA_get_ex_data;
+		RSA_get_ex_new_index;
+		RSA_padding_add_PKCS1_type_1;
+		RSA_padding_add_PKCS1_type_2;
+		RSA_padding_add_SSLv23;
+		RSA_padding_add_none;
+		RSA_padding_check_PKCS1_type_1;
+		RSA_padding_check_PKCS1_type_2;
+		RSA_padding_check_SSLv23;
+		RSA_padding_check_none;
+		bn_add_words;
+		d2i_Netscape_RSA_2;
+		CRYPTO_get_ex_new_index;
+		RIPEMD160_Init;
+		RIPEMD160_Update;
+		RIPEMD160_Final;
+		RIPEMD160;
+		RIPEMD160_Transform;
+		RC5_32_set_key;
+		RC5_32_ecb_encrypt;
+		RC5_32_encrypt;
+		RC5_32_decrypt;
+		RC5_32_cbc_encrypt;
+		RC5_32_cfb64_encrypt;
+		RC5_32_ofb64_encrypt;
+		BN_bn2mpi;
+		BN_mpi2bn;
+		ASN1_BIT_STRING_get_bit;
+		ASN1_BIT_STRING_set_bit;
+		BIO_get_ex_data;
+		BIO_get_ex_new_index;
+		BIO_set_ex_data;
+		X509v3_get_key_usage;
+		X509v3_set_key_usage;
+		a2i_X509v3_key_usage;
+		i2a_X509v3_key_usage;
+		EVP_PKEY_decrypt;
+		EVP_PKEY_encrypt;
+		PKCS7_RECIP_INFO_set;
+		PKCS7_add_recipient;
+		PKCS7_add_recipient_info;
+		PKCS7_set_cipher;
+		ASN1_TYPE_get_int_octetstring;
+		ASN1_TYPE_get_octetstring;
+		ASN1_TYPE_set_int_octetstring;
+		ASN1_TYPE_set_octetstring;
+		ASN1_UTCTIME_set_string;
+		ERR_add_error_data;
+		ERR_set_error_data;
+		EVP_CIPHER_asn1_to_param;
+		EVP_CIPHER_param_to_asn1;
+		EVP_CIPHER_get_asn1_iv;
+		EVP_CIPHER_set_asn1_iv;
+		EVP_rc5_32_12_16_cbc;
+		EVP_rc5_32_12_16_cfb64;
+		EVP_rc5_32_12_16_ecb;
+		EVP_rc5_32_12_16_ofb;
+		asn1_add_error;
+		d2i_ASN1_BMPSTRING;
+		i2d_ASN1_BMPSTRING;
+		BIO_f_ber;
+		BN_init;
+		COMP_CTX_new;
+		COMP_CTX_free;
+		COMP_CTX_compress_block;
+		COMP_CTX_expand_block;
+		X509_STORE_CTX_get_ex_new_index;
+		OBJ_NAME_add;
+		BIO_socket_nbio;
+		EVP_rc2_64_cbc;
+		OBJ_NAME_cleanup;
+		OBJ_NAME_get;
+		OBJ_NAME_init;
+		OBJ_NAME_new_index;
+		OBJ_NAME_remove;
+		BN_MONT_CTX_copy;
+		BIO_new_socks4a_connect;
+		BIO_s_socks4a_connect;
+		PROXY_set_connect_mode;
+		RAND_SSLeay;
+		RAND_set_rand_method;
+		RSA_memory_lock;
+		bn_sub_words;
+		bn_mul_normal;
+		bn_mul_comba8;
+		bn_mul_comba4;
+		bn_sqr_normal;
+		bn_sqr_comba8;
+		bn_sqr_comba4;
+		bn_cmp_words;
+		bn_mul_recursive;
+		bn_mul_part_recursive;
+		bn_sqr_recursive;
+		bn_mul_low_normal;
+		BN_RECP_CTX_init;
+		BN_RECP_CTX_new;
+		BN_RECP_CTX_free;
+		BN_RECP_CTX_set;
+		BN_mod_mul_reciprocal;
+		BN_mod_exp_recp;
+		BN_div_recp;
+		BN_CTX_init;
+		BN_MONT_CTX_init;
+		RAND_get_rand_method;
+		PKCS7_add_attribute;
+		PKCS7_add_signed_attribute;
+		PKCS7_digest_from_attributes;
+		PKCS7_get_attribute;
+		PKCS7_get_issuer_and_serial;
+		PKCS7_get_signed_attribute;
+		COMP_compress_block;
+		COMP_expand_block;
+		COMP_rle;
+		COMP_zlib;
+		ms_time_diff;
+		ms_time_new;
+		ms_time_free;
+		ms_time_cmp;
+		ms_time_get;
+		PKCS7_set_attributes;
+		PKCS7_set_signed_attributes;
+		X509_ATTRIBUTE_create;
+		X509_ATTRIBUTE_dup;
+		ASN1_GENERALIZEDTIME_check;
+		ASN1_GENERALIZEDTIME_print;
+		ASN1_GENERALIZEDTIME_set;
+		ASN1_GENERALIZEDTIME_set_string;
+		ASN1_TIME_print;
+		BASIC_CONSTRAINTS_free;
+		BASIC_CONSTRAINTS_new;
+		ERR_load_X509V3_strings;
+		NETSCAPE_CERT_SEQUENCE_free;
+		NETSCAPE_CERT_SEQUENCE_new;
+		OBJ_txt2obj;
+		PEM_read_NETSCAPE_CERT_SEQUENCE;
+		PEM_read_NS_CERT_SEQ;
+		PEM_read_bio_NETSCAPE_CERT_SEQUENCE;
+		PEM_read_bio_NS_CERT_SEQ;
+		PEM_write_NETSCAPE_CERT_SEQUENCE;
+		PEM_write_NS_CERT_SEQ;
+		PEM_write_bio_NETSCAPE_CERT_SEQUENCE;
+		PEM_write_bio_NS_CERT_SEQ;
+		X509V3_EXT_add;
+		X509V3_EXT_add_alias;
+		X509V3_EXT_add_conf;
+		X509V3_EXT_cleanup;
+		X509V3_EXT_conf;
+		X509V3_EXT_conf_nid;
+		X509V3_EXT_get;
+		X509V3_EXT_get_nid;
+		X509V3_EXT_print;
+		X509V3_EXT_print_fp;
+		X509V3_add_standard_extensions;
+		X509V3_add_value;
+		X509V3_add_value_bool;
+		X509V3_add_value_int;
+		X509V3_conf_free;
+		X509V3_get_value_bool;
+		X509V3_get_value_int;
+		X509V3_parse_list;
+		d2i_ASN1_GENERALIZEDTIME;
+		d2i_ASN1_TIME;
+		d2i_BASIC_CONSTRAINTS;
+		d2i_NETSCAPE_CERT_SEQUENCE;
+		d2i_ext_ku;
+		ext_ku_free;
+		ext_ku_new;
+		i2d_ASN1_GENERALIZEDTIME;
+		i2d_ASN1_TIME;
+		i2d_BASIC_CONSTRAINTS;
+		i2d_NETSCAPE_CERT_SEQUENCE;
+		i2d_ext_ku;
+		EVP_MD_CTX_copy;
+		i2d_ASN1_ENUMERATED;
+		d2i_ASN1_ENUMERATED;
+		ASN1_ENUMERATED_set;
+		ASN1_ENUMERATED_get;
+		BN_to_ASN1_ENUMERATED;
+		ASN1_ENUMERATED_to_BN;
+		i2a_ASN1_ENUMERATED;
+		a2i_ASN1_ENUMERATED;
+		i2d_GENERAL_NAME;
+		d2i_GENERAL_NAME;
+		GENERAL_NAME_new;
+		GENERAL_NAME_free;
+		GENERAL_NAMES_new;
+		GENERAL_NAMES_free;
+		d2i_GENERAL_NAMES;
+		i2d_GENERAL_NAMES;
+		i2v_GENERAL_NAMES;
+		i2s_ASN1_OCTET_STRING;
+		s2i_ASN1_OCTET_STRING;
+		X509V3_EXT_check_conf;
+		hex_to_string;
+		string_to_hex;
+		DES_ede3_cbcm_encrypt;
+		RSA_padding_add_PKCS1_OAEP;
+		RSA_padding_check_PKCS1_OAEP;
+		X509_CRL_print_fp;
+		X509_CRL_print;
+		i2v_GENERAL_NAME;
+		v2i_GENERAL_NAME;
+		i2d_PKEY_USAGE_PERIOD;
+		d2i_PKEY_USAGE_PERIOD;
+		PKEY_USAGE_PERIOD_new;
+		PKEY_USAGE_PERIOD_free;
+		v2i_GENERAL_NAMES;
+		i2s_ASN1_INTEGER;
+		X509V3_EXT_d2i;
+		name_cmp;
+		str_dup;
+		i2s_ASN1_ENUMERATED;
+		i2s_ASN1_ENUMERATED_TABLE;
+		BIO_s_log;
+		BIO_f_reliable;
+		PKCS7_dataFinal;
+		PKCS7_dataDecode;
+		X509V3_EXT_CRL_add_conf;
+		BN_set_params;
+		BN_get_params;
+		BIO_get_ex_num;
+		BIO_set_ex_free_func;
+		EVP_ripemd160;
+		ASN1_TIME_set;
+		i2d_AUTHORITY_KEYID;
+		d2i_AUTHORITY_KEYID;
+		AUTHORITY_KEYID_new;
+		AUTHORITY_KEYID_free;
+		ASN1_seq_unpack;
+		ASN1_seq_pack;
+		ASN1_unpack_string;
+		ASN1_pack_string;
+		PKCS12_pack_safebag;
+		PKCS12_MAKE_KEYBAG;
+		PKCS8_encrypt;
+		PKCS12_MAKE_SHKEYBAG;
+		PKCS12_pack_p7data;
+		PKCS12_pack_p7encdata;
+		PKCS12_add_localkeyid;
+		PKCS12_add_friendlyname_asc;
+		PKCS12_add_friendlyname_uni;
+		PKCS12_get_friendlyname;
+		PKCS12_pbe_crypt;
+		PKCS12_decrypt_d2i;
+		PKCS12_i2d_encrypt;
+		PKCS12_init;
+		PKCS12_key_gen_asc;
+		PKCS12_key_gen_uni;
+		PKCS12_gen_mac;
+		PKCS12_verify_mac;
+		PKCS12_set_mac;
+		PKCS12_setup_mac;
+		OPENSSL_asc2uni;
+		OPENSSL_uni2asc;
+		i2d_PKCS12_BAGS;
+		PKCS12_BAGS_new;
+		d2i_PKCS12_BAGS;
+		PKCS12_BAGS_free;
+		i2d_PKCS12;
+		d2i_PKCS12;
+		PKCS12_new;
+		PKCS12_free;
+		i2d_PKCS12_MAC_DATA;
+		PKCS12_MAC_DATA_new;
+		d2i_PKCS12_MAC_DATA;
+		PKCS12_MAC_DATA_free;
+		i2d_PKCS12_SAFEBAG;
+		PKCS12_SAFEBAG_new;
+		d2i_PKCS12_SAFEBAG;
+		PKCS12_SAFEBAG_free;
+		ERR_load_PKCS12_strings;
+		PKCS12_PBE_add;
+		PKCS8_add_keyusage;
+		PKCS12_get_attr_gen;
+		PKCS12_parse;
+		PKCS12_create;
+		i2d_PKCS12_bio;
+		i2d_PKCS12_fp;
+		d2i_PKCS12_bio;
+		d2i_PKCS12_fp;
+		i2d_PBEPARAM;
+		PBEPARAM_new;
+		d2i_PBEPARAM;
+		PBEPARAM_free;
+		i2d_PKCS8_PRIV_KEY_INFO;
+		PKCS8_PRIV_KEY_INFO_new;
+		d2i_PKCS8_PRIV_KEY_INFO;
+		PKCS8_PRIV_KEY_INFO_free;
+		EVP_PKCS82PKEY;
+		EVP_PKEY2PKCS8;
+		PKCS8_set_broken;
+		EVP_PBE_ALGOR_CipherInit;
+		EVP_PBE_alg_add;
+		PKCS5_pbe_set;
+		EVP_PBE_cleanup;
+		i2d_SXNET;
+		d2i_SXNET;
+		SXNET_new;
+		SXNET_free;
+		i2d_SXNETID;
+		d2i_SXNETID;
+		SXNETID_new;
+		SXNETID_free;
+		DSA_SIG_new;
+		DSA_SIG_free;
+		DSA_do_sign;
+		DSA_do_verify;
+		d2i_DSA_SIG;
+		i2d_DSA_SIG;
+		i2d_ASN1_VISIBLESTRING;
+		d2i_ASN1_VISIBLESTRING;
+		i2d_ASN1_UTF8STRING;
+		d2i_ASN1_UTF8STRING;
+		i2d_DIRECTORYSTRING;
+		d2i_DIRECTORYSTRING;
+		i2d_DISPLAYTEXT;
+		d2i_DISPLAYTEXT;
+		d2i_ASN1_SET_OF_X509;
+		i2d_ASN1_SET_OF_X509;
+		i2d_PBKDF2PARAM;
+		PBKDF2PARAM_new;
+		d2i_PBKDF2PARAM;
+		PBKDF2PARAM_free;
+		i2d_PBE2PARAM;
+		PBE2PARAM_new;
+		d2i_PBE2PARAM;
+		PBE2PARAM_free;
+		d2i_ASN1_SET_OF_GENERAL_NAME;
+		i2d_ASN1_SET_OF_GENERAL_NAME;
+		d2i_ASN1_SET_OF_SXNETID;
+		i2d_ASN1_SET_OF_SXNETID;
+		d2i_ASN1_SET_OF_POLICYQUALINFO;
+		i2d_ASN1_SET_OF_POLICYQUALINFO;
+		d2i_ASN1_SET_OF_POLICYINFO;
+		i2d_ASN1_SET_OF_POLICYINFO;
+		SXNET_add_id_asc;
+		SXNET_add_id_ulong;
+		SXNET_add_id_INTEGER;
+		SXNET_get_id_asc;
+		SXNET_get_id_ulong;
+		SXNET_get_id_INTEGER;
+		X509V3_set_conf_lhash;
+		i2d_CERTIFICATEPOLICIES;
+		CERTIFICATEPOLICIES_new;
+		CERTIFICATEPOLICIES_free;
+		d2i_CERTIFICATEPOLICIES;
+		i2d_POLICYINFO;
+		POLICYINFO_new;
+		d2i_POLICYINFO;
+		POLICYINFO_free;
+		i2d_POLICYQUALINFO;
+		POLICYQUALINFO_new;
+		d2i_POLICYQUALINFO;
+		POLICYQUALINFO_free;
+		i2d_USERNOTICE;
+		USERNOTICE_new;
+		d2i_USERNOTICE;
+		USERNOTICE_free;
+		i2d_NOTICEREF;
+		NOTICEREF_new;
+		d2i_NOTICEREF;
+		NOTICEREF_free;
+		X509V3_get_string;
+		X509V3_get_section;
+		X509V3_string_free;
+		X509V3_section_free;
+		X509V3_set_ctx;
+		s2i_ASN1_INTEGER;
+		CRYPTO_set_locked_mem_functions;
+		CRYPTO_get_locked_mem_functions;
+		CRYPTO_malloc_locked;
+		CRYPTO_free_locked;
+		BN_mod_exp2_mont;
+		ERR_get_error_line_data;
+		ERR_peek_error_line_data;
+		PKCS12_PBE_keyivgen;
+		X509_ALGOR_dup;
+		d2i_ASN1_SET_OF_DIST_POINT;
+		i2d_ASN1_SET_OF_DIST_POINT;
+		i2d_CRL_DIST_POINTS;
+		CRL_DIST_POINTS_new;
+		CRL_DIST_POINTS_free;
+		d2i_CRL_DIST_POINTS;
+		i2d_DIST_POINT;
+		DIST_POINT_new;
+		d2i_DIST_POINT;
+		DIST_POINT_free;
+		i2d_DIST_POINT_NAME;
+		DIST_POINT_NAME_new;
+		DIST_POINT_NAME_free;
+		d2i_DIST_POINT_NAME;
+		X509V3_add_value_uchar;
+		d2i_ASN1_SET_OF_X509_ATTRIBUTE;
+		i2d_ASN1_SET_OF_ASN1_TYPE;
+		d2i_ASN1_SET_OF_X509_EXTENSION;
+		d2i_ASN1_SET_OF_X509_NAME_ENTRY;
+		d2i_ASN1_SET_OF_ASN1_TYPE;
+		i2d_ASN1_SET_OF_X509_ATTRIBUTE;
+		i2d_ASN1_SET_OF_X509_EXTENSION;
+		i2d_ASN1_SET_OF_X509_NAME_ENTRY;
+		X509V3_EXT_i2d;
+		X509V3_EXT_val_prn;
+		X509V3_EXT_add_list;
+		EVP_CIPHER_type;
+		EVP_PBE_CipherInit;
+		X509V3_add_value_bool_nf;
+		d2i_ASN1_UINTEGER;
+		sk_value;
+		sk_num;
+		sk_set;
+		i2d_ASN1_SET_OF_X509_REVOKED;
+		sk_sort;
+		d2i_ASN1_SET_OF_X509_REVOKED;
+		i2d_ASN1_SET_OF_X509_ALGOR;
+		i2d_ASN1_SET_OF_X509_CRL;
+		d2i_ASN1_SET_OF_X509_ALGOR;
+		d2i_ASN1_SET_OF_X509_CRL;
+		i2d_ASN1_SET_OF_PKCS7_SIGNER_INFO;
+		i2d_ASN1_SET_OF_PKCS7_RECIP_INFO;
+		d2i_ASN1_SET_OF_PKCS7_SIGNER_INFO;
+		d2i_ASN1_SET_OF_PKCS7_RECIP_INFO;
+		PKCS5_PBE_add;
+		PEM_write_bio_PKCS8;
+		i2d_PKCS8_fp;
+		PEM_read_bio_PKCS8_PRIV_KEY_INFO;
+		PEM_read_bio_P8_PRIV_KEY_INFO;
+		d2i_PKCS8_bio;
+		d2i_PKCS8_PRIV_KEY_INFO_fp;
+		PEM_write_bio_PKCS8_PRIV_KEY_INFO;
+		PEM_write_bio_P8_PRIV_KEY_INFO;
+		PEM_read_PKCS8;
+		d2i_PKCS8_PRIV_KEY_INFO_bio;
+		d2i_PKCS8_fp;
+		PEM_write_PKCS8;
+		PEM_read_PKCS8_PRIV_KEY_INFO;
+		PEM_read_P8_PRIV_KEY_INFO;
+		PEM_read_bio_PKCS8;
+		PEM_write_PKCS8_PRIV_KEY_INFO;
+		PEM_write_P8_PRIV_KEY_INFO;
+		PKCS5_PBE_keyivgen;
+		i2d_PKCS8_bio;
+		i2d_PKCS8_PRIV_KEY_INFO_fp;
+		i2d_PKCS8_PRIV_KEY_INFO_bio;
+		BIO_s_bio;
+		PKCS5_pbe2_set;
+		PKCS5_PBKDF2_HMAC_SHA1;
+		PKCS5_v2_PBE_keyivgen;
+		PEM_write_bio_PKCS8PrivateKey;
+		PEM_write_PKCS8PrivateKey;
+		BIO_ctrl_get_read_request;
+		BIO_ctrl_pending;
+		BIO_ctrl_wpending;
+		BIO_new_bio_pair;
+		BIO_ctrl_get_write_guarantee;
+		CRYPTO_num_locks;
+		CONF_load_bio;
+		CONF_load_fp;
+		i2d_ASN1_SET_OF_ASN1_OBJECT;
+		d2i_ASN1_SET_OF_ASN1_OBJECT;
+		PKCS7_signatureVerify;
+		RSA_set_method;
+		RSA_get_method;
+		RSA_get_default_method;
+		RSA_check_key;
+		OBJ_obj2txt;
+		DSA_dup_DH;
+		X509_REQ_get_extensions;
+		X509_REQ_set_extension_nids;
+		BIO_nwrite;
+		X509_REQ_extension_nid;
+		BIO_nread;
+		X509_REQ_get_extension_nids;
+		BIO_nwrite0;
+		X509_REQ_add_extensions_nid;
+		BIO_nread0;
+		X509_REQ_add_extensions;
+		BIO_new_mem_buf;
+		DH_set_ex_data;
+		DH_set_method;
+		DSA_OpenSSL;
+		DH_get_ex_data;
+		DH_get_ex_new_index;
+		DSA_new_method;
+		DH_new_method;
+		DH_OpenSSL;
+		DSA_get_ex_new_index;
+		DH_get_default_method;
+		DSA_set_ex_data;
+		DH_set_default_method;
+		DSA_get_ex_data;
+		X509V3_EXT_REQ_add_conf;
+		NETSCAPE_SPKI_print;
+		NETSCAPE_SPKI_set_pubkey;
+		NETSCAPE_SPKI_b64_encode;
+		NETSCAPE_SPKI_get_pubkey;
+		NETSCAPE_SPKI_b64_decode;
+		UTF8_putc;
+		UTF8_getc;
+		RSA_null_method;
+		ASN1_tag2str;
+		BIO_ctrl_reset_read_request;
+		DISPLAYTEXT_new;
+		ASN1_GENERALIZEDTIME_free;
+		X509_REVOKED_get_ext_d2i;
+		X509_set_ex_data;
+		X509_reject_set_bit_asc;
+		X509_NAME_add_entry_by_txt;
+		X509_NAME_add_entry_by_NID;
+		X509_PURPOSE_get0;
+		PEM_read_X509_AUX;
+		d2i_AUTHORITY_INFO_ACCESS;
+		PEM_write_PUBKEY;
+		ACCESS_DESCRIPTION_new;
+		X509_CERT_AUX_free;
+		d2i_ACCESS_DESCRIPTION;
+		X509_trust_clear;
+		X509_TRUST_add;
+		ASN1_VISIBLESTRING_new;
+		X509_alias_set1;
+		ASN1_PRINTABLESTRING_free;
+		EVP_PKEY_get1_DSA;
+		ASN1_BMPSTRING_new;
+		ASN1_mbstring_copy;
+		ASN1_UTF8STRING_new;
+		DSA_get_default_method;
+		i2d_ASN1_SET_OF_ACCESS_DESCRIPTION;
+		ASN1_T61STRING_free;
+		DSA_set_method;
+		X509_get_ex_data;
+		ASN1_STRING_type;
+		X509_PURPOSE_get_by_sname;
+		ASN1_TIME_free;
+		ASN1_OCTET_STRING_cmp;
+		ASN1_BIT_STRING_new;
+		X509_get_ext_d2i;
+		PEM_read_bio_X509_AUX;
+		ASN1_STRING_set_default_mask_asc;
+		ASN1_STRING_set_def_mask_asc;
+		PEM_write_bio_RSA_PUBKEY;
+		ASN1_INTEGER_cmp;
+		d2i_RSA_PUBKEY_fp;
+		X509_trust_set_bit_asc;
+		PEM_write_bio_DSA_PUBKEY;
+		X509_STORE_CTX_free;
+		EVP_PKEY_set1_DSA;
+		i2d_DSA_PUBKEY_fp;
+		X509_load_cert_crl_file;
+		ASN1_TIME_new;
+		i2d_RSA_PUBKEY;
+		X509_STORE_CTX_purpose_inherit;
+		PEM_read_RSA_PUBKEY;
+		d2i_X509_AUX;
+		i2d_DSA_PUBKEY;
+		X509_CERT_AUX_print;
+		PEM_read_DSA_PUBKEY;
+		i2d_RSA_PUBKEY_bio;
+		ASN1_BIT_STRING_num_asc;
+		i2d_PUBKEY;
+		ASN1_UTCTIME_free;
+		DSA_set_default_method;
+		X509_PURPOSE_get_by_id;
+		ACCESS_DESCRIPTION_free;
+		PEM_read_bio_PUBKEY;
+		ASN1_STRING_set_by_NID;
+		X509_PURPOSE_get_id;
+		DISPLAYTEXT_free;
+		OTHERNAME_new;
+		X509_CERT_AUX_new;
+		X509_TRUST_cleanup;
+		X509_NAME_add_entry_by_OBJ;
+		X509_CRL_get_ext_d2i;
+		X509_PURPOSE_get0_name;
+		PEM_read_PUBKEY;
+		i2d_DSA_PUBKEY_bio;
+		i2d_OTHERNAME;
+		ASN1_OCTET_STRING_free;
+		ASN1_BIT_STRING_set_asc;
+		X509_get_ex_new_index;
+		ASN1_STRING_TABLE_cleanup;
+		X509_TRUST_get_by_id;
+		X509_PURPOSE_get_trust;
+		ASN1_STRING_length;
+		d2i_ASN1_SET_OF_ACCESS_DESCRIPTION;
+		ASN1_PRINTABLESTRING_new;
+		X509V3_get_d2i;
+		ASN1_ENUMERATED_free;
+		i2d_X509_CERT_AUX;
+		X509_STORE_CTX_set_trust;
+		ASN1_STRING_set_default_mask;
+		X509_STORE_CTX_new;
+		EVP_PKEY_get1_RSA;
+		DIRECTORYSTRING_free;
+		PEM_write_X509_AUX;
+		ASN1_OCTET_STRING_set;
+		d2i_DSA_PUBKEY_fp;
+		d2i_RSA_PUBKEY;
+		X509_TRUST_get0_name;
+		X509_TRUST_get0;
+		AUTHORITY_INFO_ACCESS_free;
+		ASN1_IA5STRING_new;
+		d2i_DSA_PUBKEY;
+		X509_check_purpose;
+		ASN1_ENUMERATED_new;
+		d2i_RSA_PUBKEY_bio;
+		d2i_PUBKEY;
+		X509_TRUST_get_trust;
+		X509_TRUST_get_flags;
+		ASN1_BMPSTRING_free;
+		ASN1_T61STRING_new;
+		ASN1_UTCTIME_new;
+		i2d_AUTHORITY_INFO_ACCESS;
+		EVP_PKEY_set1_RSA;
+		X509_STORE_CTX_set_purpose;
+		ASN1_IA5STRING_free;
+		PEM_write_bio_X509_AUX;
+		X509_PURPOSE_get_count;
+		CRYPTO_add_info;
+		X509_NAME_ENTRY_create_by_txt;
+		ASN1_STRING_get_default_mask;
+		X509_alias_get0;
+		ASN1_STRING_data;
+		i2d_ACCESS_DESCRIPTION;
+		X509_trust_set_bit;
+		ASN1_BIT_STRING_free;
+		PEM_read_bio_RSA_PUBKEY;
+		X509_add1_reject_object;
+		X509_check_trust;
+		PEM_read_bio_DSA_PUBKEY;
+		X509_PURPOSE_add;
+		ASN1_STRING_TABLE_get;
+		ASN1_UTF8STRING_free;
+		d2i_DSA_PUBKEY_bio;
+		PEM_write_RSA_PUBKEY;
+		d2i_OTHERNAME;
+		X509_reject_set_bit;
+		PEM_write_DSA_PUBKEY;
+		X509_PURPOSE_get0_sname;
+		EVP_PKEY_set1_DH;
+		ASN1_OCTET_STRING_dup;
+		ASN1_BIT_STRING_set;
+		X509_TRUST_get_count;
+		ASN1_INTEGER_free;
+		OTHERNAME_free;
+		i2d_RSA_PUBKEY_fp;
+		ASN1_INTEGER_dup;
+		d2i_X509_CERT_AUX;
+		PEM_write_bio_PUBKEY;
+		ASN1_VISIBLESTRING_free;
+		X509_PURPOSE_cleanup;
+		ASN1_mbstring_ncopy;
+		ASN1_GENERALIZEDTIME_new;
+		EVP_PKEY_get1_DH;
+		ASN1_OCTET_STRING_new;
+		ASN1_INTEGER_new;
+		i2d_X509_AUX;
+		ASN1_BIT_STRING_name_print;
+		X509_cmp;
+		ASN1_STRING_length_set;
+		DIRECTORYSTRING_new;
+		X509_add1_trust_object;
+		PKCS12_newpass;
+		SMIME_write_PKCS7;
+		SMIME_read_PKCS7;
+		DES_set_key_checked;
+		PKCS7_verify;
+		PKCS7_encrypt;
+		DES_set_key_unchecked;
+		SMIME_crlf_copy;
+		i2d_ASN1_PRINTABLESTRING;
+		PKCS7_get0_signers;
+		PKCS7_decrypt;
+		SMIME_text;
+		PKCS7_simple_smimecap;
+		PKCS7_get_smimecap;
+		PKCS7_sign;
+		PKCS7_add_attrib_smimecap;
+		CRYPTO_dbg_set_options;
+		CRYPTO_remove_all_info;
+		CRYPTO_get_mem_debug_functions;
+		CRYPTO_is_mem_check_on;
+		CRYPTO_set_mem_debug_functions;
+		CRYPTO_pop_info;
+		CRYPTO_push_info_;
+		CRYPTO_set_mem_debug_options;
+		PEM_write_PKCS8PrivateKey_nid;
+		PEM_write_bio_PKCS8PrivateKey_nid;
+		PEM_write_bio_PKCS8PrivKey_nid;
+		d2i_PKCS8PrivateKey_bio;
+		ASN1_NULL_free;
+		d2i_ASN1_NULL;
+		ASN1_NULL_new;
+		i2d_PKCS8PrivateKey_bio;
+		i2d_PKCS8PrivateKey_fp;
+		i2d_ASN1_NULL;
+		i2d_PKCS8PrivateKey_nid_fp;
+		d2i_PKCS8PrivateKey_fp;
+		i2d_PKCS8PrivateKey_nid_bio;
+		i2d_PKCS8PrivateKeyInfo_fp;
+		i2d_PKCS8PrivateKeyInfo_bio;
+		PEM_cb;
+		i2d_PrivateKey_fp;
+		d2i_PrivateKey_bio;
+		d2i_PrivateKey_fp;
+		i2d_PrivateKey_bio;
+		X509_reject_clear;
+		X509_TRUST_set_default;
+		d2i_AutoPrivateKey;
+		X509_ATTRIBUTE_get0_type;
+		X509_ATTRIBUTE_set1_data;
+		X509at_get_attr;
+		X509at_get_attr_count;
+		X509_ATTRIBUTE_create_by_NID;
+		X509_ATTRIBUTE_set1_object;
+		X509_ATTRIBUTE_count;
+		X509_ATTRIBUTE_create_by_OBJ;
+		X509_ATTRIBUTE_get0_object;
+		X509at_get_attr_by_NID;
+		X509at_add1_attr;
+		X509_ATTRIBUTE_get0_data;
+		X509at_delete_attr;
+		X509at_get_attr_by_OBJ;
+		RAND_add;
+		BIO_number_written;
+		BIO_number_read;
+		X509_STORE_CTX_get1_chain;
+		ERR_load_RAND_strings;
+		RAND_pseudo_bytes;
+		X509_REQ_get_attr_by_NID;
+		X509_REQ_get_attr;
+		X509_REQ_add1_attr_by_NID;
+		X509_REQ_get_attr_by_OBJ;
+		X509at_add1_attr_by_NID;
+		X509_REQ_add1_attr_by_OBJ;
+		X509_REQ_get_attr_count;
+		X509_REQ_add1_attr;
+		X509_REQ_delete_attr;
+		X509at_add1_attr_by_OBJ;
+		X509_REQ_add1_attr_by_txt;
+		X509_ATTRIBUTE_create_by_txt;
+		X509at_add1_attr_by_txt;
+		BN_pseudo_rand;
+		BN_is_prime_fasttest;
+		BN_CTX_end;
+		BN_CTX_start;
+		BN_CTX_get;
+		EVP_PKEY2PKCS8_broken;
+		ASN1_STRING_TABLE_add;
+		CRYPTO_dbg_get_options;
+		AUTHORITY_INFO_ACCESS_new;
+		CRYPTO_get_mem_debug_options;
+		DES_crypt;
+		PEM_write_bio_X509_REQ_NEW;
+		PEM_write_X509_REQ_NEW;
+		BIO_callback_ctrl;
+		RAND_egd;
+		RAND_status;
+		bn_dump1;
+		DES_check_key_parity;
+		lh_num_items;
+		RAND_event;
+		DSO_new;
+		DSO_new_method;
+		DSO_free;
+		DSO_flags;
+		DSO_up;
+		DSO_set_default_method;
+		DSO_get_default_method;
+		DSO_get_method;
+		DSO_set_method;
+		DSO_load;
+		DSO_bind_var;
+		DSO_METHOD_null;
+		DSO_METHOD_openssl;
+		DSO_METHOD_dlfcn;
+		DSO_METHOD_win32;
+		ERR_load_DSO_strings;
+		DSO_METHOD_dl;
+		NCONF_load;
+		NCONF_load_fp;
+		NCONF_new;
+		NCONF_get_string;
+		NCONF_free;
+		NCONF_get_number;
+		CONF_dump_fp;
+		NCONF_load_bio;
+		NCONF_dump_fp;
+		NCONF_get_section;
+		NCONF_dump_bio;
+		CONF_dump_bio;
+		NCONF_free_data;
+		CONF_set_default_method;
+		ERR_error_string_n;
+		BIO_snprintf;
+		DSO_ctrl;
+		i2d_ASN1_SET_OF_ASN1_INTEGER;
+		i2d_ASN1_SET_OF_PKCS12_SAFEBAG;
+		i2d_ASN1_SET_OF_PKCS7;
+		BIO_vfree;
+		d2i_ASN1_SET_OF_ASN1_INTEGER;
+		d2i_ASN1_SET_OF_PKCS12_SAFEBAG;
+		ASN1_UTCTIME_get;
+		X509_REQ_digest;
+		X509_CRL_digest;
+		d2i_ASN1_SET_OF_PKCS7;
+		EVP_CIPHER_CTX_set_key_length;
+		EVP_CIPHER_CTX_ctrl;
+		BN_mod_exp_mont_word;
+		RAND_egd_bytes;
+		X509_REQ_get1_email;
+		X509_get1_email;
+		X509_email_free;
+		i2d_RSA_NET;
+		d2i_RSA_NET_2;
+		d2i_RSA_NET;
+		DSO_bind_func;
+		CRYPTO_get_new_dynlockid;
+		sk_new_null;
+		CRYPTO_set_dynlock_destroy_callback;
+		CRYPTO_set_dynlock_destroy_cb;
+		CRYPTO_destroy_dynlockid;
+		CRYPTO_set_dynlock_size;
+		CRYPTO_set_dynlock_create_callback;
+		CRYPTO_set_dynlock_create_cb;
+		CRYPTO_set_dynlock_lock_callback;
+		CRYPTO_set_dynlock_lock_cb;
+		CRYPTO_get_dynlock_lock_callback;
+		CRYPTO_get_dynlock_lock_cb;
+		CRYPTO_get_dynlock_destroy_callback;
+		CRYPTO_get_dynlock_destroy_cb;
+		CRYPTO_get_dynlock_value;
+		CRYPTO_get_dynlock_create_callback;
+		CRYPTO_get_dynlock_create_cb;
+		c2i_ASN1_BIT_STRING;
+		i2c_ASN1_BIT_STRING;
+		RAND_poll;
+		c2i_ASN1_INTEGER;
+		i2c_ASN1_INTEGER;
+		BIO_dump_indent;
+		ASN1_parse_dump;
+		c2i_ASN1_OBJECT;
+		X509_NAME_print_ex_fp;
+		ASN1_STRING_print_ex_fp;
+		X509_NAME_print_ex;
+		ASN1_STRING_print_ex;
+		MD4;
+		MD4_Transform;
+		MD4_Final;
+		MD4_Update;
+		MD4_Init;
+		EVP_md4;
+		i2d_PUBKEY_bio;
+		i2d_PUBKEY_fp;
+		d2i_PUBKEY_bio;
+		ASN1_STRING_to_UTF8;
+		BIO_vprintf;
+		BIO_vsnprintf;
+		d2i_PUBKEY_fp;
+		X509_cmp_time;
+		X509_STORE_CTX_set_time;
+		X509_STORE_CTX_get1_issuer;
+		X509_OBJECT_retrieve_match;
+		X509_OBJECT_idx_by_subject;
+		X509_STORE_CTX_set_flags;
+		X509_STORE_CTX_trusted_stack;
+		X509_time_adj;
+		X509_check_issued;
+		ASN1_UTCTIME_cmp_time_t;
+		DES_set_weak_key_flag;
+		DES_check_key;
+		DES_rw_mode;
+		RSA_PKCS1_RSAref;
+		X509_keyid_set1;
+		BIO_next;
+		DSO_METHOD_vms;
+		BIO_f_linebuffer;
+		BN_bntest_rand;
+		OPENSSL_issetugid;
+		BN_rand_range;
+		ERR_load_ENGINE_strings;
+		ENGINE_set_DSA;
+		ENGINE_get_finish_function;
+		ENGINE_get_default_RSA;
+		ENGINE_get_BN_mod_exp;
+		DSA_get_default_openssl_method;
+		ENGINE_set_DH;
+		ENGINE_set_def_BN_mod_exp_crt;
+		ENGINE_set_default_BN_mod_exp_crt;
+		ENGINE_init;
+		DH_get_default_openssl_method;
+		RSA_set_default_openssl_method;
+		ENGINE_finish;
+		ENGINE_load_public_key;
+		ENGINE_get_DH;
+		ENGINE_ctrl;
+		ENGINE_get_init_function;
+		ENGINE_set_init_function;
+		ENGINE_set_default_DSA;
+		ENGINE_get_name;
+		ENGINE_get_last;
+		ENGINE_get_prev;
+		ENGINE_get_default_DH;
+		ENGINE_get_RSA;
+		ENGINE_set_default;
+		ENGINE_get_RAND;
+		ENGINE_get_first;
+		ENGINE_by_id;
+		ENGINE_set_finish_function;
+		ENGINE_get_def_BN_mod_exp_crt;
+		ENGINE_get_default_BN_mod_exp_crt;
+		RSA_get_default_openssl_method;
+		ENGINE_set_RSA;
+		ENGINE_load_private_key;
+		ENGINE_set_default_RAND;
+		ENGINE_set_BN_mod_exp;
+		ENGINE_remove;
+		ENGINE_free;
+		ENGINE_get_BN_mod_exp_crt;
+		ENGINE_get_next;
+		ENGINE_set_name;
+		ENGINE_get_default_DSA;
+		ENGINE_set_default_BN_mod_exp;
+		ENGINE_set_default_RSA;
+		ENGINE_get_default_RAND;
+		ENGINE_get_default_BN_mod_exp;
+		ENGINE_set_RAND;
+		ENGINE_set_id;
+		ENGINE_set_BN_mod_exp_crt;
+		ENGINE_set_default_DH;
+		ENGINE_new;
+		ENGINE_get_id;
+		DSA_set_default_openssl_method;
+		ENGINE_add;
+		DH_set_default_openssl_method;
+		ENGINE_get_DSA;
+		ENGINE_get_ctrl_function;
+		ENGINE_set_ctrl_function;
+		BN_pseudo_rand_range;
+		X509_STORE_CTX_set_verify_cb;
+		ERR_load_COMP_strings;
+		PKCS12_item_decrypt_d2i;
+		ASN1_UTF8STRING_it;
+		ENGINE_unregister_ciphers;
+		ENGINE_get_ciphers;
+		d2i_OCSP_BASICRESP;
+		KRB5_CHECKSUM_it;
+		EC_POINT_add;
+		ASN1_item_ex_i2d;
+		OCSP_CERTID_it;
+		d2i_OCSP_RESPBYTES;
+		X509V3_add1_i2d;
+		PKCS7_ENVELOPE_it;
+		UI_add_input_boolean;
+		ENGINE_unregister_RSA;
+		X509V3_EXT_nconf;
+		ASN1_GENERALSTRING_free;
+		d2i_OCSP_CERTSTATUS;
+		X509_REVOKED_set_serialNumber;
+		X509_print_ex;
+		OCSP_ONEREQ_get1_ext_d2i;
+		ENGINE_register_all_RAND;
+		ENGINE_load_dynamic;
+		PBKDF2PARAM_it;
+		EXTENDED_KEY_USAGE_new;
+		EC_GROUP_clear_free;
+		OCSP_sendreq_bio;
+		ASN1_item_digest;
+		OCSP_BASICRESP_delete_ext;
+		OCSP_SIGNATURE_it;
+		X509_CRL_it;
+		OCSP_BASICRESP_add_ext;
+		KRB5_ENCKEY_it;
+		UI_method_set_closer;
+		X509_STORE_set_purpose;
+		i2d_ASN1_GENERALSTRING;
+		OCSP_response_status;
+		i2d_OCSP_SERVICELOC;
+		ENGINE_get_digest_engine;
+		EC_GROUP_set_curve_GFp;
+		OCSP_REQUEST_get_ext_by_OBJ;
+		_ossl_old_des_random_key;
+		ASN1_T61STRING_it;
+		EC_GROUP_method_of;
+		i2d_KRB5_APREQ;
+		_ossl_old_des_encrypt;
+		ASN1_PRINTABLE_new;
+		HMAC_Init_ex;
+		d2i_KRB5_AUTHENT;
+		OCSP_archive_cutoff_new;
+		EC_POINT_set_Jprojective_coordinates_GFp;
+		EC_POINT_set_Jproj_coords_GFp;
+		_ossl_old_des_is_weak_key;
+		OCSP_BASICRESP_get_ext_by_OBJ;
+		EC_POINT_oct2point;
+		OCSP_SINGLERESP_get_ext_count;
+		UI_ctrl;
+		_shadow_DES_rw_mode;
+		asn1_do_adb;
+		ASN1_template_i2d;
+		ENGINE_register_DH;
+		UI_construct_prompt;
+		X509_STORE_set_trust;
+		UI_dup_input_string;
+		d2i_KRB5_APREQ;
+		EVP_MD_CTX_copy_ex;
+		OCSP_request_is_signed;
+		i2d_OCSP_REQINFO;
+		KRB5_ENCKEY_free;
+		OCSP_resp_get0;
+		GENERAL_NAME_it;
+		ASN1_GENERALIZEDTIME_it;
+		X509_STORE_set_flags;
+		EC_POINT_set_compressed_coordinates_GFp;
+		EC_POINT_set_compr_coords_GFp;
+		OCSP_response_status_str;
+		d2i_OCSP_REVOKEDINFO;
+		OCSP_basic_add1_cert;
+		ERR_get_implementation;
+		EVP_CipherFinal_ex;
+		OCSP_CERTSTATUS_new;
+		CRYPTO_cleanup_all_ex_data;
+		OCSP_resp_find;
+		BN_nnmod;
+		X509_CRL_sort;
+		X509_REVOKED_set_revocationDate;
+		ENGINE_register_RAND;
+		OCSP_SERVICELOC_new;
+		EC_POINT_set_affine_coordinates_GFp;
+		EC_POINT_set_affine_coords_GFp;
+		_ossl_old_des_options;
+		SXNET_it;
+		UI_dup_input_boolean;
+		PKCS12_add_CSPName_asc;
+		EC_POINT_is_at_infinity;
+		ENGINE_load_cryptodev;
+		DSO_convert_filename;
+		POLICYQUALINFO_it;
+		ENGINE_register_ciphers;
+		BN_mod_lshift_quick;
+		DSO_set_filename;
+		ASN1_item_free;
+		KRB5_TKTBODY_free;
+		AUTHORITY_KEYID_it;
+		KRB5_APREQBODY_new;
+		X509V3_EXT_REQ_add_nconf;
+		ENGINE_ctrl_cmd_string;
+		i2d_OCSP_RESPDATA;
+		EVP_MD_CTX_init;
+		EXTENDED_KEY_USAGE_free;
+		PKCS7_ATTR_SIGN_it;
+		UI_add_error_string;
+		KRB5_CHECKSUM_free;
+		OCSP_REQUEST_get_ext;
+		ENGINE_load_ubsec;
+		ENGINE_register_all_digests;
+		PKEY_USAGE_PERIOD_it;
+		PKCS12_unpack_authsafes;
+		ASN1_item_unpack;
+		NETSCAPE_SPKAC_it;
+		X509_REVOKED_it;
+		ASN1_STRING_encode;
+		EVP_aes_128_ecb;
+		KRB5_AUTHENT_free;
+		OCSP_BASICRESP_get_ext_by_critical;
+		OCSP_BASICRESP_get_ext_by_crit;
+		OCSP_cert_status_str;
+		d2i_OCSP_REQUEST;
+		UI_dup_info_string;
+		_ossl_old_des_xwhite_in2out;
+		PKCS12_it;
+		OCSP_SINGLERESP_get_ext_by_critical;
+		OCSP_SINGLERESP_get_ext_by_crit;
+		OCSP_CERTSTATUS_free;
+		_ossl_old_des_crypt;
+		ASN1_item_i2d;
+		EVP_DecryptFinal_ex;
+		ENGINE_load_openssl;
+		ENGINE_get_cmd_defns;
+		ENGINE_set_load_privkey_function;
+		ENGINE_set_load_privkey_fn;
+		EVP_EncryptFinal_ex;
+		ENGINE_set_default_digests;
+		X509_get0_pubkey_bitstr;
+		asn1_ex_i2c;
+		ENGINE_register_RSA;
+		ENGINE_unregister_DSA;
+		_ossl_old_des_key_sched;
+		X509_EXTENSION_it;
+		i2d_KRB5_AUTHENT;
+		SXNETID_it;
+		d2i_OCSP_SINGLERESP;
+		EDIPARTYNAME_new;
+		PKCS12_certbag2x509;
+		_ossl_old_des_ofb64_encrypt;
+		d2i_EXTENDED_KEY_USAGE;
+		ERR_print_errors_cb;
+		ENGINE_set_ciphers;
+		d2i_KRB5_APREQBODY;
+		UI_method_get_flusher;
+		X509_PUBKEY_it;
+		_ossl_old_des_enc_read;
+		PKCS7_ENCRYPT_it;
+		i2d_OCSP_RESPONSE;
+		EC_GROUP_get_cofactor;
+		PKCS12_unpack_p7data;
+		d2i_KRB5_AUTHDATA;
+		OCSP_copy_nonce;
+		KRB5_AUTHDATA_new;
+		OCSP_RESPDATA_new;
+		EC_GFp_mont_method;
+		OCSP_REVOKEDINFO_free;
+		UI_get_ex_data;
+		KRB5_APREQBODY_free;
+		EC_GROUP_get0_generator;
+		UI_get_default_method;
+		X509V3_set_nconf;
+		PKCS12_item_i2d_encrypt;
+		X509_add1_ext_i2d;
+		PKCS7_SIGNER_INFO_it;
+		KRB5_PRINCNAME_new;
+		PKCS12_SAFEBAG_it;
+		EC_GROUP_get_order;
+		d2i_OCSP_RESPID;
+		OCSP_request_verify;
+		NCONF_get_number_e;
+		_ossl_old_des_decrypt3;
+		X509_signature_print;
+		OCSP_SINGLERESP_free;
+		ENGINE_load_builtin_engines;
+		i2d_OCSP_ONEREQ;
+		OCSP_REQUEST_add_ext;
+		OCSP_RESPBYTES_new;
+		EVP_MD_CTX_create;
+		OCSP_resp_find_status;
+		X509_ALGOR_it;
+		ASN1_TIME_it;
+		OCSP_request_set1_name;
+		OCSP_ONEREQ_get_ext_count;
+		UI_get0_result;
+		PKCS12_AUTHSAFES_it;
+		EVP_aes_256_ecb;
+		PKCS12_pack_authsafes;
+		ASN1_IA5STRING_it;
+		UI_get_input_flags;
+		EC_GROUP_set_generator;
+		_ossl_old_des_string_to_2keys;
+		OCSP_CERTID_free;
+		X509_CERT_AUX_it;
+		CERTIFICATEPOLICIES_it;
+		_ossl_old_des_ede3_cbc_encrypt;
+		RAND_set_rand_engine;
+		DSO_get_loaded_filename;
+		X509_ATTRIBUTE_it;
+		OCSP_ONEREQ_get_ext_by_NID;
+		PKCS12_decrypt_skey;
+		KRB5_AUTHENT_it;
+		UI_dup_error_string;
+		RSAPublicKey_it;
+		i2d_OCSP_REQUEST;
+		PKCS12_x509crl2certbag;
+		OCSP_SERVICELOC_it;
+		ASN1_item_sign;
+		X509_CRL_set_issuer_name;
+		OBJ_NAME_do_all_sorted;
+		i2d_OCSP_BASICRESP;
+		i2d_OCSP_RESPBYTES;
+		PKCS12_unpack_p7encdata;
+		HMAC_CTX_init;
+		ENGINE_get_digest;
+		OCSP_RESPONSE_print;
+		KRB5_TKTBODY_it;
+		ACCESS_DESCRIPTION_it;
+		PKCS7_ISSUER_AND_SERIAL_it;
+		PBE2PARAM_it;
+		PKCS12_certbag2x509crl;
+		PKCS7_SIGNED_it;
+		ENGINE_get_cipher;
+		i2d_OCSP_CRLID;
+		OCSP_SINGLERESP_new;
+		ENGINE_cmd_is_executable;
+		RSA_up_ref;
+		ASN1_GENERALSTRING_it;
+		ENGINE_register_DSA;
+		X509V3_EXT_add_nconf_sk;
+		ENGINE_set_load_pubkey_function;
+		PKCS8_decrypt;
+		PEM_bytes_read_bio;
+		DIRECTORYSTRING_it;
+		d2i_OCSP_CRLID;
+		EC_POINT_is_on_curve;
+		CRYPTO_set_locked_mem_ex_functions;
+		CRYPTO_set_locked_mem_ex_funcs;
+		d2i_KRB5_CHECKSUM;
+		ASN1_item_dup;
+		X509_it;
+		BN_mod_add;
+		KRB5_AUTHDATA_free;
+		_ossl_old_des_cbc_cksum;
+		ASN1_item_verify;
+		CRYPTO_set_mem_ex_functions;
+		EC_POINT_get_Jprojective_coordinates_GFp;
+		EC_POINT_get_Jproj_coords_GFp;
+		ZLONG_it;
+		CRYPTO_get_locked_mem_ex_functions;
+		CRYPTO_get_locked_mem_ex_funcs;
+		ASN1_TIME_check;
+		UI_get0_user_data;
+		HMAC_CTX_cleanup;
+		DSA_up_ref;
+		_ossl_old_des_ede3_cfb64_encrypt;
+		_ossl_odes_ede3_cfb64_encrypt;
+		ASN1_BMPSTRING_it;
+		ASN1_tag2bit;
+		UI_method_set_flusher;
+		X509_ocspid_print;
+		KRB5_ENCDATA_it;
+		ENGINE_get_load_pubkey_function;
+		UI_add_user_data;
+		OCSP_REQUEST_delete_ext;
+		UI_get_method;
+		OCSP_ONEREQ_free;
+		ASN1_PRINTABLESTRING_it;
+		X509_CRL_set_nextUpdate;
+		OCSP_REQUEST_it;
+		OCSP_BASICRESP_it;
+		AES_ecb_encrypt;
+		BN_mod_sqr;
+		NETSCAPE_CERT_SEQUENCE_it;
+		GENERAL_NAMES_it;
+		AUTHORITY_INFO_ACCESS_it;
+		ASN1_FBOOLEAN_it;
+		UI_set_ex_data;
+		_ossl_old_des_string_to_key;
+		ENGINE_register_all_RSA;
+		d2i_KRB5_PRINCNAME;
+		OCSP_RESPBYTES_it;
+		X509_CINF_it;
+		ENGINE_unregister_digests;
+		d2i_EDIPARTYNAME;
+		d2i_OCSP_SERVICELOC;
+		ENGINE_get_digests;
+		_ossl_old_des_set_odd_parity;
+		OCSP_RESPDATA_free;
+		d2i_KRB5_TICKET;
+		OTHERNAME_it;
+		EVP_MD_CTX_cleanup;
+		d2i_ASN1_GENERALSTRING;
+		X509_CRL_set_version;
+		BN_mod_sub;
+		OCSP_SINGLERESP_get_ext_by_NID;
+		ENGINE_get_ex_new_index;
+		OCSP_REQUEST_free;
+		OCSP_REQUEST_add1_ext_i2d;
+		X509_VAL_it;
+		EC_POINTs_make_affine;
+		EC_POINT_mul;
+		X509V3_EXT_add_nconf;
+		X509_TRUST_set;
+		X509_CRL_add1_ext_i2d;
+		_ossl_old_des_fcrypt;
+		DISPLAYTEXT_it;
+		X509_CRL_set_lastUpdate;
+		OCSP_BASICRESP_free;
+		OCSP_BASICRESP_add1_ext_i2d;
+		d2i_KRB5_AUTHENTBODY;
+		CRYPTO_set_ex_data_implementation;
+		CRYPTO_set_ex_data_impl;
+		KRB5_ENCDATA_new;
+		DSO_up_ref;
+		OCSP_crl_reason_str;
+		UI_get0_result_string;
+		ASN1_GENERALSTRING_new;
+		X509_SIG_it;
+		ERR_set_implementation;
+		ERR_load_EC_strings;
+		UI_get0_action_string;
+		OCSP_ONEREQ_get_ext;
+		EC_POINT_method_of;
+		i2d_KRB5_APREQBODY;
+		_ossl_old_des_ecb3_encrypt;
+		CRYPTO_get_mem_ex_functions;
+		ENGINE_get_ex_data;
+		UI_destroy_method;
+		ASN1_item_i2d_bio;
+		OCSP_ONEREQ_get_ext_by_OBJ;
+		ASN1_primitive_new;
+		ASN1_PRINTABLE_it;
+		EVP_aes_192_ecb;
+		OCSP_SIGNATURE_new;
+		LONG_it;
+		ASN1_VISIBLESTRING_it;
+		OCSP_SINGLERESP_add1_ext_i2d;
+		d2i_OCSP_CERTID;
+		ASN1_item_d2i_fp;
+		CRL_DIST_POINTS_it;
+		GENERAL_NAME_print;
+		OCSP_SINGLERESP_delete_ext;
+		PKCS12_SAFEBAGS_it;
+		d2i_OCSP_SIGNATURE;
+		OCSP_request_add1_nonce;
+		ENGINE_set_cmd_defns;
+		OCSP_SERVICELOC_free;
+		EC_GROUP_free;
+		ASN1_BIT_STRING_it;
+		X509_REQ_it;
+		_ossl_old_des_cbc_encrypt;
+		ERR_unload_strings;
+		PKCS7_SIGN_ENVELOPE_it;
+		EDIPARTYNAME_free;
+		OCSP_REQINFO_free;
+		EC_GROUP_new_curve_GFp;
+		OCSP_REQUEST_get1_ext_d2i;
+		PKCS12_item_pack_safebag;
+		asn1_ex_c2i;
+		ENGINE_register_digests;
+		i2d_OCSP_REVOKEDINFO;
+		asn1_enc_restore;
+		UI_free;
+		UI_new_method;
+		EVP_EncryptInit_ex;
+		X509_pubkey_digest;
+		EC_POINT_invert;
+		OCSP_basic_sign;
+		i2d_OCSP_RESPID;
+		OCSP_check_nonce;
+		ENGINE_ctrl_cmd;
+		d2i_KRB5_ENCKEY;
+		OCSP_parse_url;
+		OCSP_SINGLERESP_get_ext;
+		OCSP_CRLID_free;
+		OCSP_BASICRESP_get1_ext_d2i;
+		RSAPrivateKey_it;
+		ENGINE_register_all_DH;
+		i2d_EDIPARTYNAME;
+		EC_POINT_get_affine_coordinates_GFp;
+		EC_POINT_get_affine_coords_GFp;
+		OCSP_CRLID_new;
+		ENGINE_get_flags;
+		OCSP_ONEREQ_it;
+		UI_process;
+		ASN1_INTEGER_it;
+		EVP_CipherInit_ex;
+		UI_get_string_type;
+		ENGINE_unregister_DH;
+		ENGINE_register_all_DSA;
+		OCSP_ONEREQ_get_ext_by_critical;
+		bn_dup_expand;
+		OCSP_cert_id_new;
+		BASIC_CONSTRAINTS_it;
+		BN_mod_add_quick;
+		EC_POINT_new;
+		EVP_MD_CTX_destroy;
+		OCSP_RESPBYTES_free;
+		EVP_aes_128_cbc;
+		OCSP_SINGLERESP_get1_ext_d2i;
+		EC_POINT_free;
+		DH_up_ref;
+		X509_NAME_ENTRY_it;
+		UI_get_ex_new_index;
+		BN_mod_sub_quick;
+		OCSP_ONEREQ_add_ext;
+		OCSP_request_sign;
+		EVP_DigestFinal_ex;
+		ENGINE_set_digests;
+		OCSP_id_issuer_cmp;
+		OBJ_NAME_do_all;
+		EC_POINTs_mul;
+		ENGINE_register_complete;
+		X509V3_EXT_nconf_nid;
+		ASN1_SEQUENCE_it;
+		UI_set_default_method;
+		RAND_query_egd_bytes;
+		UI_method_get_writer;
+		UI_OpenSSL;
+		PEM_def_callback;
+		ENGINE_cleanup;
+		DIST_POINT_it;
+		OCSP_SINGLERESP_it;
+		d2i_KRB5_TKTBODY;
+		EC_POINT_cmp;
+		OCSP_REVOKEDINFO_new;
+		i2d_OCSP_CERTSTATUS;
+		OCSP_basic_add1_nonce;
+		ASN1_item_ex_d2i;
+		BN_mod_lshift1_quick;
+		UI_set_method;
+		OCSP_id_get0_info;
+		BN_mod_sqrt;
+		EC_GROUP_copy;
+		KRB5_ENCDATA_free;
+		_ossl_old_des_cfb_encrypt;
+		OCSP_SINGLERESP_get_ext_by_OBJ;
+		OCSP_cert_to_id;
+		OCSP_RESPID_new;
+		OCSP_RESPDATA_it;
+		d2i_OCSP_RESPDATA;
+		ENGINE_register_all_complete;
+		OCSP_check_validity;
+		PKCS12_BAGS_it;
+		OCSP_url_svcloc_new;
+		ASN1_template_free;
+		OCSP_SINGLERESP_add_ext;
+		KRB5_AUTHENTBODY_it;
+		X509_supported_extension;
+		i2d_KRB5_AUTHDATA;
+		UI_method_get_opener;
+		ENGINE_set_ex_data;
+		OCSP_REQUEST_print;
+		CBIGNUM_it;
+		KRB5_TICKET_new;
+		KRB5_APREQ_new;
+		EC_GROUP_get_curve_GFp;
+		KRB5_ENCKEY_new;
+		ASN1_template_d2i;
+		_ossl_old_des_quad_cksum;
+		OCSP_single_get0_status;
+		BN_swap;
+		POLICYINFO_it;
+		ENGINE_set_destroy_function;
+		asn1_enc_free;
+		OCSP_RESPID_it;
+		EC_GROUP_new;
+		EVP_aes_256_cbc;
+		i2d_KRB5_PRINCNAME;
+		_ossl_old_des_encrypt2;
+		_ossl_old_des_encrypt3;
+		PKCS8_PRIV_KEY_INFO_it;
+		OCSP_REQINFO_it;
+		PBEPARAM_it;
+		KRB5_AUTHENTBODY_new;
+		X509_CRL_add0_revoked;
+		EDIPARTYNAME_it;
+		NETSCAPE_SPKI_it;
+		UI_get0_test_string;
+		ENGINE_get_cipher_engine;
+		ENGINE_register_all_ciphers;
+		EC_POINT_copy;
+		BN_kronecker;
+		_ossl_old_des_ede3_ofb64_encrypt;
+		_ossl_odes_ede3_ofb64_encrypt;
+		UI_method_get_reader;
+		OCSP_BASICRESP_get_ext_count;
+		ASN1_ENUMERATED_it;
+		UI_set_result;
+		i2d_KRB5_TICKET;
+		X509_print_ex_fp;
+		EVP_CIPHER_CTX_set_padding;
+		d2i_OCSP_RESPONSE;
+		ASN1_UTCTIME_it;
+		_ossl_old_des_enc_write;
+		OCSP_RESPONSE_new;
+		AES_set_encrypt_key;
+		OCSP_resp_count;
+		KRB5_CHECKSUM_new;
+		ENGINE_load_cswift;
+		OCSP_onereq_get0_id;
+		ENGINE_set_default_ciphers;
+		NOTICEREF_it;
+		X509V3_EXT_CRL_add_nconf;
+		OCSP_REVOKEDINFO_it;
+		AES_encrypt;
+		OCSP_REQUEST_new;
+		ASN1_ANY_it;
+		CRYPTO_ex_data_new_class;
+		_ossl_old_des_ncbc_encrypt;
+		i2d_KRB5_TKTBODY;
+		EC_POINT_clear_free;
+		AES_decrypt;
+		asn1_enc_init;
+		UI_get_result_maxsize;
+		OCSP_CERTID_new;
+		ENGINE_unregister_RAND;
+		UI_method_get_closer;
+		d2i_KRB5_ENCDATA;
+		OCSP_request_onereq_count;
+		OCSP_basic_verify;
+		KRB5_AUTHENTBODY_free;
+		ASN1_item_d2i;
+		ASN1_primitive_free;
+		i2d_EXTENDED_KEY_USAGE;
+		i2d_OCSP_SIGNATURE;
+		asn1_enc_save;
+		ENGINE_load_nuron;
+		_ossl_old_des_pcbc_encrypt;
+		PKCS12_MAC_DATA_it;
+		OCSP_accept_responses_new;
+		asn1_do_lock;
+		PKCS7_ATTR_VERIFY_it;
+		KRB5_APREQBODY_it;
+		i2d_OCSP_SINGLERESP;
+		ASN1_item_ex_new;
+		UI_add_verify_string;
+		_ossl_old_des_set_key;
+		KRB5_PRINCNAME_it;
+		EVP_DecryptInit_ex;
+		i2d_OCSP_CERTID;
+		ASN1_item_d2i_bio;
+		EC_POINT_dbl;
+		asn1_get_choice_selector;
+		i2d_KRB5_CHECKSUM;
+		ENGINE_set_table_flags;
+		AES_options;
+		ENGINE_load_chil;
+		OCSP_id_cmp;
+		OCSP_BASICRESP_new;
+		OCSP_REQUEST_get_ext_by_NID;
+		KRB5_APREQ_it;
+		ENGINE_get_destroy_function;
+		CONF_set_nconf;
+		ASN1_PRINTABLE_free;
+		OCSP_BASICRESP_get_ext_by_NID;
+		DIST_POINT_NAME_it;
+		X509V3_extensions_print;
+		_ossl_old_des_cfb64_encrypt;
+		X509_REVOKED_add1_ext_i2d;
+		_ossl_old_des_ofb_encrypt;
+		KRB5_TKTBODY_new;
+		ASN1_OCTET_STRING_it;
+		ERR_load_UI_strings;
+		i2d_KRB5_ENCKEY;
+		ASN1_template_new;
+		OCSP_SIGNATURE_free;
+		ASN1_item_i2d_fp;
+		KRB5_PRINCNAME_free;
+		PKCS7_RECIP_INFO_it;
+		EXTENDED_KEY_USAGE_it;
+		EC_GFp_simple_method;
+		EC_GROUP_precompute_mult;
+		OCSP_request_onereq_get0;
+		UI_method_set_writer;
+		KRB5_AUTHENT_new;
+		X509_CRL_INFO_it;
+		DSO_set_name_converter;
+		AES_set_decrypt_key;
+		PKCS7_DIGEST_it;
+		PKCS12_x5092certbag;
+		EVP_DigestInit_ex;
+		i2a_ACCESS_DESCRIPTION;
+		OCSP_RESPONSE_it;
+		PKCS7_ENC_CONTENT_it;
+		OCSP_request_add0_id;
+		EC_POINT_make_affine;
+		DSO_get_filename;
+		OCSP_CERTSTATUS_it;
+		OCSP_request_add1_cert;
+		UI_get0_output_string;
+		UI_dup_verify_string;
+		BN_mod_lshift;
+		KRB5_AUTHDATA_it;
+		asn1_set_choice_selector;
+		OCSP_basic_add1_status;
+		OCSP_RESPID_free;
+		asn1_get_field_ptr;
+		UI_add_input_string;
+		OCSP_CRLID_it;
+		i2d_KRB5_AUTHENTBODY;
+		OCSP_REQUEST_get_ext_count;
+		ENGINE_load_atalla;
+		X509_NAME_it;
+		USERNOTICE_it;
+		OCSP_REQINFO_new;
+		OCSP_BASICRESP_get_ext;
+		CRYPTO_get_ex_data_implementation;
+		CRYPTO_get_ex_data_impl;
+		ASN1_item_pack;
+		i2d_KRB5_ENCDATA;
+		X509_PURPOSE_set;
+		X509_REQ_INFO_it;
+		UI_method_set_opener;
+		ASN1_item_ex_free;
+		ASN1_BOOLEAN_it;
+		ENGINE_get_table_flags;
+		UI_create_method;
+		OCSP_ONEREQ_add1_ext_i2d;
+		_shadow_DES_check_key;
+		d2i_OCSP_REQINFO;
+		UI_add_info_string;
+		UI_get_result_minsize;
+		ASN1_NULL_it;
+		BN_mod_lshift1;
+		d2i_OCSP_ONEREQ;
+		OCSP_ONEREQ_new;
+		KRB5_TICKET_it;
+		EVP_aes_192_cbc;
+		KRB5_TICKET_free;
+		UI_new;
+		OCSP_response_create;
+		_ossl_old_des_xcbc_encrypt;
+		PKCS7_it;
+		OCSP_REQUEST_get_ext_by_critical;
+		OCSP_REQUEST_get_ext_by_crit;
+		ENGINE_set_flags;
+		_ossl_old_des_ecb_encrypt;
+		OCSP_response_get1_basic;
+		EVP_Digest;
+		OCSP_ONEREQ_delete_ext;
+		ASN1_TBOOLEAN_it;
+		ASN1_item_new;
+		ASN1_TIME_to_generalizedtime;
+		BIGNUM_it;
+		AES_cbc_encrypt;
+		ENGINE_get_load_privkey_function;
+		ENGINE_get_load_privkey_fn;
+		OCSP_RESPONSE_free;
+		UI_method_set_reader;
+		i2d_ASN1_T61STRING;
+		EC_POINT_set_to_infinity;
+		ERR_load_OCSP_strings;
+		EC_POINT_point2oct;
+		KRB5_APREQ_free;
+		ASN1_OBJECT_it;
+		OCSP_crlID_new;
+		OCSP_crlID2_new;
+		CONF_modules_load_file;
+		CONF_imodule_set_usr_data;
+		ENGINE_set_default_string;
+		CONF_module_get_usr_data;
+		ASN1_add_oid_module;
+		CONF_modules_finish;
+		OPENSSL_config;
+		CONF_modules_unload;
+		CONF_imodule_get_value;
+		CONF_module_set_usr_data;
+		CONF_parse_list;
+		CONF_module_add;
+		CONF_get1_default_config_file;
+		CONF_imodule_get_flags;
+		CONF_imodule_get_module;
+		CONF_modules_load;
+		CONF_imodule_get_name;
+		ERR_peek_top_error;
+		CONF_imodule_get_usr_data;
+		CONF_imodule_set_flags;
+		ENGINE_add_conf_module;
+		ERR_peek_last_error_line;
+		ERR_peek_last_error_line_data;
+		ERR_peek_last_error;
+		DES_read_2passwords;
+		DES_read_password;
+		UI_UTIL_read_pw;
+		UI_UTIL_read_pw_string;
+		ENGINE_load_aep;
+		ENGINE_load_sureware;
+		OPENSSL_add_all_algorithms_noconf;
+		OPENSSL_add_all_algo_noconf;
+		OPENSSL_add_all_algorithms_conf;
+		OPENSSL_add_all_algo_conf;
+		OPENSSL_load_builtin_modules;
+		AES_ofb128_encrypt;
+		AES_ctr128_encrypt;
+		AES_cfb128_encrypt;
+		ENGINE_load_4758cca;
+		_ossl_096_des_random_seed;
+		EVP_aes_256_ofb;
+		EVP_aes_192_ofb;
+		EVP_aes_128_cfb128;
+		EVP_aes_256_cfb128;
+		EVP_aes_128_ofb;
+		EVP_aes_192_cfb128;
+		CONF_modules_free;
+		NCONF_default;
+		OPENSSL_no_config;
+		NCONF_WIN32;
+		ASN1_UNIVERSALSTRING_new;
+		EVP_des_ede_ecb;
+		i2d_ASN1_UNIVERSALSTRING;
+		ASN1_UNIVERSALSTRING_free;
+		ASN1_UNIVERSALSTRING_it;
+		d2i_ASN1_UNIVERSALSTRING;
+		EVP_des_ede3_ecb;
+		X509_REQ_print_ex;
+		ENGINE_up_ref;
+		BUF_MEM_grow_clean;
+		CRYPTO_realloc_clean;
+		BUF_strlcat;
+		BIO_indent;
+		BUF_strlcpy;
+		OpenSSLDie;
+		OPENSSL_cleanse;
+		ENGINE_setup_bsd_cryptodev;
+		ERR_release_err_state_table;
+		EVP_aes_128_cfb8;
+		FIPS_corrupt_rsa;
+		FIPS_selftest_des;
+		EVP_aes_128_cfb1;
+		EVP_aes_192_cfb8;
+		FIPS_mode_set;
+		FIPS_selftest_dsa;
+		EVP_aes_256_cfb8;
+		FIPS_allow_md5;
+		DES_ede3_cfb_encrypt;
+		EVP_des_ede3_cfb8;
+		FIPS_rand_seeded;
+		AES_cfbr_encrypt_block;
+		AES_cfb8_encrypt;
+		FIPS_rand_seed;
+		FIPS_corrupt_des;
+		EVP_aes_192_cfb1;
+		FIPS_selftest_aes;
+		FIPS_set_prng_key;
+		EVP_des_cfb8;
+		FIPS_corrupt_dsa;
+		FIPS_test_mode;
+		FIPS_rand_method;
+		EVP_aes_256_cfb1;
+		ERR_load_FIPS_strings;
+		FIPS_corrupt_aes;
+		FIPS_selftest_sha1;
+		FIPS_selftest_rsa;
+		FIPS_corrupt_sha1;
+		EVP_des_cfb1;
+		FIPS_dsa_check;
+		AES_cfb1_encrypt;
+		EVP_des_ede3_cfb1;
+		FIPS_rand_check;
+		FIPS_md5_allowed;
+		FIPS_mode;
+		FIPS_selftest_failed;
+		sk_is_sorted;
+		X509_check_ca;
+		HMAC_CTX_set_flags;
+		d2i_PROXY_CERT_INFO_EXTENSION;
+		PROXY_POLICY_it;
+		i2d_PROXY_POLICY;
+		i2d_PROXY_CERT_INFO_EXTENSION;
+		d2i_PROXY_POLICY;
+		PROXY_CERT_INFO_EXTENSION_new;
+		PROXY_CERT_INFO_EXTENSION_free;
+		PROXY_CERT_INFO_EXTENSION_it;
+		PROXY_POLICY_free;
+		PROXY_POLICY_new;
+		BN_MONT_CTX_set_locked;
+		FIPS_selftest_rng;
+		EVP_sha384;
+		EVP_sha512;
+		EVP_sha224;
+		EVP_sha256;
+		FIPS_selftest_hmac;
+		FIPS_corrupt_rng;
+		BN_mod_exp_mont_consttime;
+		RSA_X931_hash_id;
+		RSA_padding_check_X931;
+		RSA_verify_PKCS1_PSS;
+		RSA_padding_add_X931;
+		RSA_padding_add_PKCS1_PSS;
+		PKCS1_MGF1;
+		BN_X931_generate_Xpq;
+		RSA_X931_generate_key;
+		BN_X931_derive_prime;
+		BN_X931_generate_prime;
+		RSA_X931_derive;
+		BIO_new_dgram;
+		BN_get0_nist_prime_384;
+		ERR_set_mark;
+		X509_STORE_CTX_set0_crls;
+		ENGINE_set_STORE;
+		ENGINE_register_ECDSA;
+		STORE_meth_set_list_start_fn;
+		STORE_method_set_list_start_function;
+		BN_BLINDING_invert_ex;
+		NAME_CONSTRAINTS_free;
+		STORE_ATTR_INFO_set_number;
+		BN_BLINDING_get_thread_id;
+		X509_STORE_CTX_set0_param;
+		POLICY_MAPPING_it;
+		STORE_parse_attrs_start;
+		POLICY_CONSTRAINTS_free;
+		EVP_PKEY_add1_attr_by_NID;
+		BN_nist_mod_192;
+		EC_GROUP_get_trinomial_basis;
+		STORE_set_method;
+		GENERAL_SUBTREE_free;
+		NAME_CONSTRAINTS_it;
+		ECDH_get_default_method;
+		PKCS12_add_safe;
+		EC_KEY_new_by_curve_name;
+		STORE_meth_get_update_store_fn;
+		STORE_method_get_update_store_function;
+		ENGINE_register_ECDH;
+		SHA512_Update;
+		i2d_ECPrivateKey;
+		BN_get0_nist_prime_192;
+		STORE_modify_certificate;
+		EC_POINT_set_affine_coordinates_GF2m;
+		EC_POINT_set_affine_coords_GF2m;
+		BN_GF2m_mod_exp_arr;
+		STORE_ATTR_INFO_modify_number;
+		X509_keyid_get0;
+		ENGINE_load_gmp;
+		pitem_new;
+		BN_GF2m_mod_mul_arr;
+		STORE_list_public_key_endp;
+		o2i_ECPublicKey;
+		EC_KEY_copy;
+		BIO_dump_fp;
+		X509_policy_node_get0_parent;
+		EC_GROUP_check_discriminant;
+		i2o_ECPublicKey;
+		EC_KEY_precompute_mult;
+		a2i_IPADDRESS;
+		STORE_meth_set_initialise_fn;
+		STORE_method_set_initialise_function;
+		X509_STORE_CTX_set_depth;
+		X509_VERIFY_PARAM_inherit;
+		EC_POINT_point2bn;
+		STORE_ATTR_INFO_set_dn;
+		X509_policy_tree_get0_policies;
+		EC_GROUP_new_curve_GF2m;
+		STORE_destroy_method;
+		ENGINE_unregister_STORE;
+		EVP_PKEY_get1_EC_KEY;
+		STORE_ATTR_INFO_get0_number;
+		ENGINE_get_default_ECDH;
+		EC_KEY_get_conv_form;
+		ASN1_OCTET_STRING_NDEF_it;
+		STORE_delete_public_key;
+		STORE_get_public_key;
+		STORE_modify_arbitrary;
+		ENGINE_get_static_state;
+		pqueue_iterator;
+		ECDSA_SIG_new;
+		OPENSSL_DIR_end;
+		BN_GF2m_mod_sqr;
+		EC_POINT_bn2point;
+		X509_VERIFY_PARAM_set_depth;
+		EC_KEY_set_asn1_flag;
+		STORE_get_method;
+		EC_KEY_get_key_method_data;
+		ECDSA_sign_ex;
+		STORE_parse_attrs_end;
+		EC_GROUP_get_point_conversion_form;
+		EC_GROUP_get_point_conv_form;
+		STORE_method_set_store_function;
+		STORE_ATTR_INFO_in;
+		PEM_read_bio_ECPKParameters;
+		EC_GROUP_get_pentanomial_basis;
+		EVP_PKEY_add1_attr_by_txt;
+		BN_BLINDING_set_flags;
+		X509_VERIFY_PARAM_set1_policies;
+		X509_VERIFY_PARAM_set1_name;
+		X509_VERIFY_PARAM_set_purpose;
+		STORE_get_number;
+		ECDSA_sign_setup;
+		BN_GF2m_mod_solve_quad_arr;
+		EC_KEY_up_ref;
+		POLICY_MAPPING_free;
+		BN_GF2m_mod_div;
+		X509_VERIFY_PARAM_set_flags;
+		EC_KEY_free;
+		STORE_meth_set_list_next_fn;
+		STORE_method_set_list_next_function;
+		PEM_write_bio_ECPrivateKey;
+		d2i_EC_PUBKEY;
+		STORE_meth_get_generate_fn;
+		STORE_method_get_generate_function;
+		STORE_meth_set_list_end_fn;
+		STORE_method_set_list_end_function;
+		pqueue_print;
+		EC_GROUP_have_precompute_mult;
+		EC_KEY_print_fp;
+		BN_GF2m_mod_arr;
+		PEM_write_bio_X509_CERT_PAIR;
+		EVP_PKEY_cmp;
+		X509_policy_level_node_count;
+		STORE_new_engine;
+		STORE_list_public_key_start;
+		X509_VERIFY_PARAM_new;
+		ECDH_get_ex_data;
+		EVP_PKEY_get_attr;
+		ECDSA_do_sign;
+		ENGINE_unregister_ECDH;
+		ECDH_OpenSSL;
+		EC_KEY_set_conv_form;
+		EC_POINT_dup;
+		GENERAL_SUBTREE_new;
+		STORE_list_crl_endp;
+		EC_get_builtin_curves;
+		X509_policy_node_get0_qualifiers;
+		X509_pcy_node_get0_qualifiers;
+		STORE_list_crl_end;
+		EVP_PKEY_set1_EC_KEY;
+		BN_GF2m_mod_sqrt_arr;
+		i2d_ECPrivateKey_bio;
+		ECPKParameters_print_fp;
+		pqueue_find;
+		ECDSA_SIG_free;
+		PEM_write_bio_ECPKParameters;
+		STORE_method_set_ctrl_function;
+		STORE_list_public_key_end;
+		EC_KEY_set_private_key;
+		pqueue_peek;
+		STORE_get_arbitrary;
+		STORE_store_crl;
+		X509_policy_node_get0_policy;
+		PKCS12_add_safes;
+		BN_BLINDING_convert_ex;
+		X509_policy_tree_free;
+		OPENSSL_ia32cap_loc;
+		BN_GF2m_poly2arr;
+		STORE_ctrl;
+		STORE_ATTR_INFO_compare;
+		BN_get0_nist_prime_224;
+		i2d_ECParameters;
+		i2d_ECPKParameters;
+		BN_GENCB_call;
+		d2i_ECPKParameters;
+		STORE_meth_set_generate_fn;
+		STORE_method_set_generate_function;
+		ENGINE_set_ECDH;
+		NAME_CONSTRAINTS_new;
+		SHA256_Init;
+		EC_KEY_get0_public_key;
+		PEM_write_bio_EC_PUBKEY;
+		STORE_ATTR_INFO_set_cstr;
+		STORE_list_crl_next;
+		STORE_ATTR_INFO_in_range;
+		ECParameters_print;
+		STORE_meth_set_delete_fn;
+		STORE_method_set_delete_function;
+		STORE_list_certificate_next;
+		ASN1_generate_nconf;
+		BUF_memdup;
+		BN_GF2m_mod_mul;
+		STORE_meth_get_list_next_fn;
+		STORE_method_get_list_next_function;
+		STORE_ATTR_INFO_get0_dn;
+		STORE_list_private_key_next;
+		EC_GROUP_set_seed;
+		X509_VERIFY_PARAM_set_trust;
+		STORE_ATTR_INFO_free;
+		STORE_get_private_key;
+		EVP_PKEY_get_attr_count;
+		STORE_ATTR_INFO_new;
+		EC_GROUP_get_curve_GF2m;
+		STORE_meth_set_revoke_fn;
+		STORE_method_set_revoke_function;
+		STORE_store_number;
+		BN_is_prime_ex;
+		STORE_revoke_public_key;
+		X509_STORE_CTX_get0_param;
+		STORE_delete_arbitrary;
+		PEM_read_X509_CERT_PAIR;
+		X509_STORE_set_depth;
+		ECDSA_get_ex_data;
+		SHA224;
+		BIO_dump_indent_fp;
+		EC_KEY_set_group;
+		BUF_strndup;
+		STORE_list_certificate_start;
+		BN_GF2m_mod;
+		X509_REQ_check_private_key;
+		EC_GROUP_get_seed_len;
+		ERR_load_STORE_strings;
+		PEM_read_bio_EC_PUBKEY;
+		STORE_list_private_key_end;
+		i2d_EC_PUBKEY;
+		ECDSA_get_default_method;
+		ASN1_put_eoc;
+		X509_STORE_CTX_get_explicit_policy;
+		X509_STORE_CTX_get_expl_policy;
+		X509_VERIFY_PARAM_table_cleanup;
+		STORE_modify_private_key;
+		X509_VERIFY_PARAM_free;
+		EC_METHOD_get_field_type;
+		EC_GFp_nist_method;
+		STORE_meth_set_modify_fn;
+		STORE_method_set_modify_function;
+		STORE_parse_attrs_next;
+		ENGINE_load_padlock;
+		EC_GROUP_set_curve_name;
+		X509_CERT_PAIR_it;
+		STORE_meth_get_revoke_fn;
+		STORE_method_get_revoke_function;
+		STORE_method_set_get_function;
+		STORE_modify_number;
+		STORE_method_get_store_function;
+		STORE_store_private_key;
+		BN_GF2m_mod_sqr_arr;
+		RSA_setup_blinding;
+		BIO_s_datagram;
+		STORE_Memory;
+		sk_find_ex;
+		EC_GROUP_set_curve_GF2m;
+		ENGINE_set_default_ECDSA;
+		POLICY_CONSTRAINTS_new;
+		BN_GF2m_mod_sqrt;
+		ECDH_set_default_method;
+		EC_KEY_generate_key;
+		SHA384_Update;
+		BN_GF2m_arr2poly;
+		STORE_method_get_get_function;
+		STORE_meth_set_cleanup_fn;
+		STORE_method_set_cleanup_function;
+		EC_GROUP_check;
+		d2i_ECPrivateKey_bio;
+		EC_KEY_insert_key_method_data;
+		STORE_meth_get_lock_store_fn;
+		STORE_method_get_lock_store_function;
+		X509_VERIFY_PARAM_get_depth;
+		SHA224_Final;
+		STORE_meth_set_update_store_fn;
+		STORE_method_set_update_store_function;
+		SHA224_Update;
+		d2i_ECPrivateKey;
+		ASN1_item_ndef_i2d;
+		STORE_delete_private_key;
+		ERR_pop_to_mark;
+		ENGINE_register_all_STORE;
+		X509_policy_level_get0_node;
+		i2d_PKCS7_NDEF;
+		EC_GROUP_get_degree;
+		ASN1_generate_v3;
+		STORE_ATTR_INFO_modify_cstr;
+		X509_policy_tree_level_count;
+		BN_GF2m_add;
+		EC_KEY_get0_group;
+		STORE_generate_crl;
+		STORE_store_public_key;
+		X509_CERT_PAIR_free;
+		STORE_revoke_private_key;
+		BN_nist_mod_224;
+		SHA512_Final;
+		STORE_ATTR_INFO_modify_dn;
+		STORE_meth_get_initialise_fn;
+		STORE_method_get_initialise_function;
+		STORE_delete_number;
+		i2d_EC_PUBKEY_bio;
+		BIO_dgram_non_fatal_error;
+		EC_GROUP_get_asn1_flag;
+		STORE_ATTR_INFO_in_ex;
+		STORE_list_crl_start;
+		ECDH_get_ex_new_index;
+		STORE_meth_get_modify_fn;
+		STORE_method_get_modify_function;
+		v2i_ASN1_BIT_STRING;
+		STORE_store_certificate;
+		OBJ_bsearch_ex;
+		X509_STORE_CTX_set_default;
+		STORE_ATTR_INFO_set_sha1str;
+		BN_GF2m_mod_inv;
+		BN_GF2m_mod_exp;
+		STORE_modify_public_key;
+		STORE_meth_get_list_start_fn;
+		STORE_method_get_list_start_function;
+		EC_GROUP_get0_seed;
+		STORE_store_arbitrary;
+		STORE_meth_set_unlock_store_fn;
+		STORE_method_set_unlock_store_function;
+		BN_GF2m_mod_div_arr;
+		ENGINE_set_ECDSA;
+		STORE_create_method;
+		ECPKParameters_print;
+		EC_KEY_get0_private_key;
+		PEM_write_EC_PUBKEY;
+		X509_VERIFY_PARAM_set1;
+		ECDH_set_method;
+		v2i_GENERAL_NAME_ex;
+		ECDH_set_ex_data;
+		STORE_generate_key;
+		BN_nist_mod_521;
+		X509_policy_tree_get0_level;
+		EC_GROUP_set_point_conversion_form;
+		EC_GROUP_set_point_conv_form;
+		PEM_read_EC_PUBKEY;
+		i2d_ECDSA_SIG;
+		ECDSA_OpenSSL;
+		STORE_delete_crl;
+		EC_KEY_get_enc_flags;
+		ASN1_const_check_infinite_end;
+		EVP_PKEY_delete_attr;
+		ECDSA_set_default_method;
+		EC_POINT_set_compressed_coordinates_GF2m;
+		EC_POINT_set_compr_coords_GF2m;
+		EC_GROUP_cmp;
+		STORE_revoke_certificate;
+		BN_get0_nist_prime_256;
+		STORE_meth_get_delete_fn;
+		STORE_method_get_delete_function;
+		SHA224_Init;
+		PEM_read_ECPrivateKey;
+		SHA512_Init;
+		STORE_parse_attrs_endp;
+		BN_set_negative;
+		ERR_load_ECDSA_strings;
+		EC_GROUP_get_basis_type;
+		STORE_list_public_key_next;
+		i2v_ASN1_BIT_STRING;
+		STORE_OBJECT_free;
+		BN_nist_mod_384;
+		i2d_X509_CERT_PAIR;
+		PEM_write_ECPKParameters;
+		ECDH_compute_key;
+		STORE_ATTR_INFO_get0_sha1str;
+		ENGINE_register_all_ECDH;
+		pqueue_pop;
+		STORE_ATTR_INFO_get0_cstr;
+		POLICY_CONSTRAINTS_it;
+		STORE_get_ex_new_index;
+		EVP_PKEY_get_attr_by_OBJ;
+		X509_VERIFY_PARAM_add0_policy;
+		BN_GF2m_mod_solve_quad;
+		SHA256;
+		i2d_ECPrivateKey_fp;
+		X509_policy_tree_get0_user_policies;
+		X509_pcy_tree_get0_usr_policies;
+		OPENSSL_DIR_read;
+		ENGINE_register_all_ECDSA;
+		X509_VERIFY_PARAM_lookup;
+		EC_POINT_get_affine_coordinates_GF2m;
+		EC_POINT_get_affine_coords_GF2m;
+		EC_GROUP_dup;
+		ENGINE_get_default_ECDSA;
+		EC_KEY_new;
+		SHA256_Transform;
+		EC_KEY_set_enc_flags;
+		ECDSA_verify;
+		EC_POINT_point2hex;
+		ENGINE_get_STORE;
+		SHA512;
+		STORE_get_certificate;
+		ECDSA_do_sign_ex;
+		ECDSA_do_verify;
+		d2i_ECPrivateKey_fp;
+		STORE_delete_certificate;
+		SHA512_Transform;
+		X509_STORE_set1_param;
+		STORE_method_get_ctrl_function;
+		STORE_free;
+		PEM_write_ECPrivateKey;
+		STORE_meth_get_unlock_store_fn;
+		STORE_method_get_unlock_store_function;
+		STORE_get_ex_data;
+		EC_KEY_set_public_key;
+		PEM_read_ECPKParameters;
+		X509_CERT_PAIR_new;
+		ENGINE_register_STORE;
+		RSA_generate_key_ex;
+		DSA_generate_parameters_ex;
+		ECParameters_print_fp;
+		X509V3_NAME_from_section;
+		EVP_PKEY_add1_attr;
+		STORE_modify_crl;
+		STORE_list_private_key_start;
+		POLICY_MAPPINGS_it;
+		GENERAL_SUBTREE_it;
+		EC_GROUP_get_curve_name;
+		PEM_write_X509_CERT_PAIR;
+		BIO_dump_indent_cb;
+		d2i_X509_CERT_PAIR;
+		STORE_list_private_key_endp;
+		asn1_const_Finish;
+		i2d_EC_PUBKEY_fp;
+		BN_nist_mod_256;
+		X509_VERIFY_PARAM_add0_table;
+		pqueue_free;
+		BN_BLINDING_create_param;
+		ECDSA_size;
+		d2i_EC_PUBKEY_bio;
+		BN_get0_nist_prime_521;
+		STORE_ATTR_INFO_modify_sha1str;
+		BN_generate_prime_ex;
+		EC_GROUP_new_by_curve_name;
+		SHA256_Final;
+		DH_generate_parameters_ex;
+		PEM_read_bio_ECPrivateKey;
+		STORE_meth_get_cleanup_fn;
+		STORE_method_get_cleanup_function;
+		ENGINE_get_ECDH;
+		d2i_ECDSA_SIG;
+		BN_is_prime_fasttest_ex;
+		ECDSA_sign;
+		X509_policy_check;
+		EVP_PKEY_get_attr_by_NID;
+		STORE_set_ex_data;
+		ENGINE_get_ECDSA;
+		EVP_ecdsa;
+		BN_BLINDING_get_flags;
+		PKCS12_add_cert;
+		STORE_OBJECT_new;
+		ERR_load_ECDH_strings;
+		EC_KEY_dup;
+		EVP_CIPHER_CTX_rand_key;
+		ECDSA_set_method;
+		a2i_IPADDRESS_NC;
+		d2i_ECParameters;
+		STORE_list_certificate_end;
+		STORE_get_crl;
+		X509_POLICY_NODE_print;
+		SHA384_Init;
+		EC_GF2m_simple_method;
+		ECDSA_set_ex_data;
+		SHA384_Final;
+		PKCS7_set_digest;
+		EC_KEY_print;
+		STORE_meth_set_lock_store_fn;
+		STORE_method_set_lock_store_function;
+		ECDSA_get_ex_new_index;
+		SHA384;
+		POLICY_MAPPING_new;
+		STORE_list_certificate_endp;
+		X509_STORE_CTX_get0_policy_tree;
+		EC_GROUP_set_asn1_flag;
+		EC_KEY_check_key;
+		d2i_EC_PUBKEY_fp;
+		PKCS7_set0_type_other;
+		PEM_read_bio_X509_CERT_PAIR;
+		pqueue_next;
+		STORE_meth_get_list_end_fn;
+		STORE_method_get_list_end_function;
+		EVP_PKEY_add1_attr_by_OBJ;
+		X509_VERIFY_PARAM_set_time;
+		pqueue_new;
+		ENGINE_set_default_ECDH;
+		STORE_new_method;
+		PKCS12_add_key;
+		DSO_merge;
+		EC_POINT_hex2point;
+		BIO_dump_cb;
+		SHA256_Update;
+		pqueue_insert;
+		pitem_free;
+		BN_GF2m_mod_inv_arr;
+		ENGINE_unregister_ECDSA;
+		BN_BLINDING_set_thread_id;
+		get_rfc3526_prime_8192;
+		X509_VERIFY_PARAM_clear_flags;
+		get_rfc2409_prime_1024;
+		DH_check_pub_key;
+		get_rfc3526_prime_2048;
+		get_rfc3526_prime_6144;
+		get_rfc3526_prime_1536;
+		get_rfc3526_prime_3072;
+		get_rfc3526_prime_4096;
+		get_rfc2409_prime_768;
+		X509_VERIFY_PARAM_get_flags;
+		EVP_CIPHER_CTX_new;
+		EVP_CIPHER_CTX_free;
+		Camellia_cbc_encrypt;
+		Camellia_cfb128_encrypt;
+		Camellia_cfb1_encrypt;
+		Camellia_cfb8_encrypt;
+		Camellia_ctr128_encrypt;
+		Camellia_cfbr_encrypt_block;
+		Camellia_decrypt;
+		Camellia_ecb_encrypt;
+		Camellia_encrypt;
+		Camellia_ofb128_encrypt;
+		Camellia_set_key;
+		EVP_camellia_128_cbc;
+		EVP_camellia_128_cfb128;
+		EVP_camellia_128_cfb1;
+		EVP_camellia_128_cfb8;
+		EVP_camellia_128_ecb;
+		EVP_camellia_128_ofb;
+		EVP_camellia_192_cbc;
+		EVP_camellia_192_cfb128;
+		EVP_camellia_192_cfb1;
+		EVP_camellia_192_cfb8;
+		EVP_camellia_192_ecb;
+		EVP_camellia_192_ofb;
+		EVP_camellia_256_cbc;
+		EVP_camellia_256_cfb128;
+		EVP_camellia_256_cfb1;
+		EVP_camellia_256_cfb8;
+		EVP_camellia_256_ecb;
+		EVP_camellia_256_ofb;
+		a2i_ipadd;
+		ASIdentifiers_free;
+		i2d_ASIdOrRange;
+		EVP_CIPHER_block_size;
+		v3_asid_is_canonical;
+		IPAddressChoice_free;
+		EVP_CIPHER_CTX_set_app_data;
+		BIO_set_callback_arg;
+		v3_addr_add_prefix;
+		IPAddressOrRange_it;
+		BIO_set_flags;
+		ASIdentifiers_it;
+		v3_addr_get_range;
+		BIO_method_type;
+		v3_addr_inherits;
+		IPAddressChoice_it;
+		AES_ige_encrypt;
+		v3_addr_add_range;
+		EVP_CIPHER_CTX_nid;
+		d2i_ASRange;
+		v3_addr_add_inherit;
+		v3_asid_add_id_or_range;
+		v3_addr_validate_resource_set;
+		EVP_CIPHER_iv_length;
+		EVP_MD_type;
+		v3_asid_canonize;
+		IPAddressRange_free;
+		v3_asid_add_inherit;
+		EVP_CIPHER_CTX_key_length;
+		IPAddressRange_new;
+		ASIdOrRange_new;
+		EVP_MD_size;
+		EVP_MD_CTX_test_flags;
+		BIO_clear_flags;
+		i2d_ASRange;
+		IPAddressRange_it;
+		IPAddressChoice_new;
+		ASIdentifierChoice_new;
+		ASRange_free;
+		EVP_MD_pkey_type;
+		EVP_MD_CTX_clear_flags;
+		IPAddressFamily_free;
+		i2d_IPAddressFamily;
+		IPAddressOrRange_new;
+		EVP_CIPHER_flags;
+		v3_asid_validate_resource_set;
+		d2i_IPAddressRange;
+		AES_bi_ige_encrypt;
+		BIO_get_callback;
+		IPAddressOrRange_free;
+		v3_addr_subset;
+		d2i_IPAddressFamily;
+		v3_asid_subset;
+		BIO_test_flags;
+		i2d_ASIdentifierChoice;
+		ASRange_it;
+		d2i_ASIdentifiers;
+		ASRange_new;
+		d2i_IPAddressChoice;
+		v3_addr_get_afi;
+		EVP_CIPHER_key_length;
+		EVP_Cipher;
+		i2d_IPAddressOrRange;
+		ASIdOrRange_it;
+		EVP_CIPHER_nid;
+		i2d_IPAddressChoice;
+		EVP_CIPHER_CTX_block_size;
+		ASIdentifiers_new;
+		v3_addr_validate_path;
+		IPAddressFamily_new;
+		EVP_MD_CTX_set_flags;
+		v3_addr_is_canonical;
+		i2d_IPAddressRange;
+		IPAddressFamily_it;
+		v3_asid_inherits;
+		EVP_CIPHER_CTX_cipher;
+		EVP_CIPHER_CTX_get_app_data;
+		EVP_MD_block_size;
+		EVP_CIPHER_CTX_flags;
+		v3_asid_validate_path;
+		d2i_IPAddressOrRange;
+		v3_addr_canonize;
+		ASIdentifierChoice_it;
+		EVP_MD_CTX_md;
+		d2i_ASIdentifierChoice;
+		BIO_method_name;
+		EVP_CIPHER_CTX_iv_length;
+		ASIdOrRange_free;
+		ASIdentifierChoice_free;
+		BIO_get_callback_arg;
+		BIO_set_callback;
+		d2i_ASIdOrRange;
+		i2d_ASIdentifiers;
+		SEED_decrypt;
+		SEED_encrypt;
+		SEED_cbc_encrypt;
+		EVP_seed_ofb;
+		SEED_cfb128_encrypt;
+		SEED_ofb128_encrypt;
+		EVP_seed_cbc;
+		SEED_ecb_encrypt;
+		EVP_seed_ecb;
+		SEED_set_key;
+		EVP_seed_cfb128;
+		X509_EXTENSIONS_it;
+		X509_get1_ocsp;
+		OCSP_REQ_CTX_free;
+		i2d_X509_EXTENSIONS;
+		OCSP_sendreq_nbio;
+		OCSP_sendreq_new;
+		d2i_X509_EXTENSIONS;
+		X509_ALGORS_it;
+		X509_ALGOR_get0;
+		X509_ALGOR_set0;
+		AES_unwrap_key;
+		AES_wrap_key;
+		X509at_get0_data_by_OBJ;
+		ASN1_TYPE_set1;
+		ASN1_STRING_set0;
+		i2d_X509_ALGORS;
+		BIO_f_zlib;
+		COMP_zlib_cleanup;
+		d2i_X509_ALGORS;
+		CMS_ReceiptRequest_free;
+		PEM_write_CMS;
+		CMS_add0_CertificateChoices;
+		CMS_unsigned_add1_attr_by_OBJ;
+		ERR_load_CMS_strings;
+		CMS_sign_receipt;
+		i2d_CMS_ContentInfo;
+		CMS_signed_delete_attr;
+		d2i_CMS_bio;
+		CMS_unsigned_get_attr_by_NID;
+		CMS_verify;
+		SMIME_read_CMS;
+		CMS_decrypt_set1_key;
+		CMS_SignerInfo_get0_algs;
+		CMS_add1_cert;
+		CMS_set_detached;
+		CMS_encrypt;
+		CMS_EnvelopedData_create;
+		CMS_uncompress;
+		CMS_add0_crl;
+		CMS_SignerInfo_verify_content;
+		CMS_unsigned_get0_data_by_OBJ;
+		PEM_write_bio_CMS;
+		CMS_unsigned_get_attr;
+		CMS_RecipientInfo_ktri_cert_cmp;
+		CMS_RecipientInfo_ktri_get0_algs;
+		CMS_RecipInfo_ktri_get0_algs;
+		CMS_ContentInfo_free;
+		CMS_final;
+		CMS_add_simple_smimecap;
+		CMS_SignerInfo_verify;
+		CMS_data;
+		CMS_ContentInfo_it;
+		d2i_CMS_ReceiptRequest;
+		CMS_compress;
+		CMS_digest_create;
+		CMS_SignerInfo_cert_cmp;
+		CMS_SignerInfo_sign;
+		CMS_data_create;
+		i2d_CMS_bio;
+		CMS_EncryptedData_set1_key;
+		CMS_decrypt;
+		int_smime_write_ASN1;
+		CMS_unsigned_delete_attr;
+		CMS_unsigned_get_attr_count;
+		CMS_add_smimecap;
+		PEM_read_CMS;
+		CMS_signed_get_attr_by_OBJ;
+		d2i_CMS_ContentInfo;
+		CMS_add_standard_smimecap;
+		CMS_ContentInfo_new;
+		CMS_RecipientInfo_type;
+		CMS_get0_type;
+		CMS_is_detached;
+		CMS_sign;
+		CMS_signed_add1_attr;
+		CMS_unsigned_get_attr_by_OBJ;
+		SMIME_write_CMS;
+		CMS_EncryptedData_decrypt;
+		CMS_get0_RecipientInfos;
+		CMS_add0_RevocationInfoChoice;
+		CMS_decrypt_set1_pkey;
+		CMS_SignerInfo_set1_signer_cert;
+		CMS_get0_signers;
+		CMS_ReceiptRequest_get0_values;
+		CMS_signed_get0_data_by_OBJ;
+		CMS_get0_SignerInfos;
+		CMS_add0_cert;
+		CMS_EncryptedData_encrypt;
+		CMS_digest_verify;
+		CMS_set1_signers_certs;
+		CMS_signed_get_attr;
+		CMS_RecipientInfo_set0_key;
+		CMS_SignedData_init;
+		CMS_RecipientInfo_kekri_get0_id;
+		CMS_verify_receipt;
+		CMS_ReceiptRequest_it;
+		PEM_read_bio_CMS;
+		CMS_get1_crls;
+		CMS_add0_recipient_key;
+		SMIME_read_ASN1;
+		CMS_ReceiptRequest_new;
+		CMS_get0_content;
+		CMS_get1_ReceiptRequest;
+		CMS_signed_add1_attr_by_OBJ;
+		CMS_RecipientInfo_kekri_id_cmp;
+		CMS_add1_ReceiptRequest;
+		CMS_SignerInfo_get0_signer_id;
+		CMS_unsigned_add1_attr_by_NID;
+		CMS_unsigned_add1_attr;
+		CMS_signed_get_attr_by_NID;
+		CMS_get1_certs;
+		CMS_signed_add1_attr_by_NID;
+		CMS_unsigned_add1_attr_by_txt;
+		CMS_dataFinal;
+		CMS_RecipientInfo_ktri_get0_signer_id;
+		CMS_RecipInfo_ktri_get0_sigr_id;
+		i2d_CMS_ReceiptRequest;
+		CMS_add1_recipient_cert;
+		CMS_dataInit;
+		CMS_signed_add1_attr_by_txt;
+		CMS_RecipientInfo_decrypt;
+		CMS_signed_get_attr_count;
+		CMS_get0_eContentType;
+		CMS_set1_eContentType;
+		CMS_ReceiptRequest_create0;
+		CMS_add1_signer;
+		CMS_RecipientInfo_set0_pkey;
+		ENGINE_set_load_ssl_client_cert_function;
+		ENGINE_set_ld_ssl_clnt_cert_fn;
+		ENGINE_get_ssl_client_cert_function;
+		ENGINE_get_ssl_client_cert_fn;
+		ENGINE_load_ssl_client_cert;
+		ENGINE_load_capi;
+		OPENSSL_isservice;
+		FIPS_dsa_sig_decode;
+		EVP_CIPHER_CTX_clear_flags;
+		FIPS_rand_status;
+		FIPS_rand_set_key;
+		CRYPTO_set_mem_info_functions;
+		RSA_X931_generate_key_ex;
+		int_ERR_set_state_func;
+		int_EVP_MD_set_engine_callbacks;
+		int_CRYPTO_set_do_dynlock_callback;
+		FIPS_rng_stick;
+		EVP_CIPHER_CTX_set_flags;
+		BN_X931_generate_prime_ex;
+		FIPS_selftest_check;
+		FIPS_rand_set_dt;
+		CRYPTO_dbg_pop_info;
+		FIPS_dsa_free;
+		RSA_X931_derive_ex;
+		FIPS_rsa_new;
+		FIPS_rand_bytes;
+		fips_cipher_test;
+		EVP_CIPHER_CTX_test_flags;
+		CRYPTO_malloc_debug_init;
+		CRYPTO_dbg_push_info;
+		FIPS_corrupt_rsa_keygen;
+		FIPS_dh_new;
+		FIPS_corrupt_dsa_keygen;
+		FIPS_dh_free;
+		fips_pkey_signature_test;
+		EVP_add_alg_module;
+		int_RAND_init_engine_callbacks;
+		int_EVP_CIPHER_set_engine_callbacks;
+		int_EVP_MD_init_engine_callbacks;
+		FIPS_rand_test_mode;
+		FIPS_rand_reset;
+		FIPS_dsa_new;
+		int_RAND_set_callbacks;
+		BN_X931_derive_prime_ex;
+		int_ERR_lib_init;
+		int_EVP_CIPHER_init_engine_callbacks;
+		FIPS_rsa_free;
+		FIPS_dsa_sig_encode;
+		CRYPTO_dbg_remove_all_info;
+		OPENSSL_init;
+		CRYPTO_strdup;
+		JPAKE_STEP3A_process;
+		JPAKE_STEP1_release;
+		JPAKE_get_shared_key;
+		JPAKE_STEP3B_init;
+		JPAKE_STEP1_generate;
+		JPAKE_STEP1_init;
+		JPAKE_STEP3B_process;
+		JPAKE_STEP2_generate;
+		JPAKE_CTX_new;
+		JPAKE_CTX_free;
+		JPAKE_STEP3B_release;
+		JPAKE_STEP3A_release;
+		JPAKE_STEP2_process;
+		JPAKE_STEP3B_generate;
+		JPAKE_STEP1_process;
+		JPAKE_STEP3A_generate;
+		JPAKE_STEP2_release;
+		JPAKE_STEP3A_init;
+		ERR_load_JPAKE_strings;
+		JPAKE_STEP2_init;
+		pqueue_size;
+		i2d_TS_ACCURACY;
+		i2d_TS_MSG_IMPRINT_fp;
+		i2d_TS_MSG_IMPRINT;
+		EVP_PKEY_print_public;
+		EVP_PKEY_CTX_new;
+		i2d_TS_TST_INFO;
+		EVP_PKEY_asn1_find;
+		DSO_METHOD_beos;
+		TS_CONF_load_cert;
+		TS_REQ_get_ext;
+		EVP_PKEY_sign_init;
+		ASN1_item_print;
+		TS_TST_INFO_set_nonce;
+		TS_RESP_dup;
+		ENGINE_register_pkey_meths;
+		EVP_PKEY_asn1_add0;
+		PKCS7_add0_attrib_signing_time;
+		i2d_TS_TST_INFO_fp;
+		BIO_asn1_get_prefix;
+		TS_TST_INFO_set_time;
+		EVP_PKEY_meth_set_decrypt;
+		EVP_PKEY_set_type_str;
+		EVP_PKEY_CTX_get_keygen_info;
+		TS_REQ_set_policy_id;
+		d2i_TS_RESP_fp;
+		ENGINE_get_pkey_asn1_meth_engine;
+		ENGINE_get_pkey_asn1_meth_eng;
+		WHIRLPOOL_Init;
+		TS_RESP_set_status_info;
+		EVP_PKEY_keygen;
+		EVP_DigestSignInit;
+		TS_ACCURACY_set_millis;
+		TS_REQ_dup;
+		GENERAL_NAME_dup;
+		ASN1_SEQUENCE_ANY_it;
+		WHIRLPOOL;
+		X509_STORE_get1_crls;
+		ENGINE_get_pkey_asn1_meth;
+		EVP_PKEY_asn1_new;
+		BIO_new_NDEF;
+		ENGINE_get_pkey_meth;
+		TS_MSG_IMPRINT_set_algo;
+		i2d_TS_TST_INFO_bio;
+		TS_TST_INFO_set_ordering;
+		TS_TST_INFO_get_ext_by_OBJ;
+		CRYPTO_THREADID_set_pointer;
+		TS_CONF_get_tsa_section;
+		SMIME_write_ASN1;
+		TS_RESP_CTX_set_signer_key;
+		EVP_PKEY_encrypt_old;
+		EVP_PKEY_encrypt_init;
+		CRYPTO_THREADID_cpy;
+		ASN1_PCTX_get_cert_flags;
+		i2d_ESS_SIGNING_CERT;
+		TS_CONF_load_key;
+		i2d_ASN1_SEQUENCE_ANY;
+		d2i_TS_MSG_IMPRINT_bio;
+		EVP_PKEY_asn1_set_public;
+		b2i_PublicKey_bio;
+		BIO_asn1_set_prefix;
+		EVP_PKEY_new_mac_key;
+		BIO_new_CMS;
+		CRYPTO_THREADID_cmp;
+		TS_REQ_ext_free;
+		EVP_PKEY_asn1_set_free;
+		EVP_PKEY_get0_asn1;
+		d2i_NETSCAPE_X509;
+		EVP_PKEY_verify_recover_init;
+		EVP_PKEY_CTX_set_data;
+		EVP_PKEY_keygen_init;
+		TS_RESP_CTX_set_status_info;
+		TS_MSG_IMPRINT_get_algo;
+		TS_REQ_print_bio;
+		EVP_PKEY_CTX_ctrl_str;
+		EVP_PKEY_get_default_digest_nid;
+		PEM_write_bio_PKCS7_stream;
+		TS_MSG_IMPRINT_print_bio;
+		BN_asc2bn;
+		TS_REQ_get_policy_id;
+		ENGINE_set_default_pkey_asn1_meths;
+		ENGINE_set_def_pkey_asn1_meths;
+		d2i_TS_ACCURACY;
+		DSO_global_lookup;
+		TS_CONF_set_tsa_name;
+		i2d_ASN1_SET_ANY;
+		ENGINE_load_gost;
+		WHIRLPOOL_BitUpdate;
+		ASN1_PCTX_get_flags;
+		TS_TST_INFO_get_ext_by_NID;
+		TS_RESP_new;
+		ESS_CERT_ID_dup;
+		TS_STATUS_INFO_dup;
+		TS_REQ_delete_ext;
+		EVP_DigestVerifyFinal;
+		EVP_PKEY_print_params;
+		i2d_CMS_bio_stream;
+		TS_REQ_get_msg_imprint;
+		OBJ_find_sigid_by_algs;
+		TS_TST_INFO_get_serial;
+		TS_REQ_get_nonce;
+		X509_PUBKEY_set0_param;
+		EVP_PKEY_CTX_set0_keygen_info;
+		DIST_POINT_set_dpname;
+		i2d_ISSUING_DIST_POINT;
+		ASN1_SET_ANY_it;
+		EVP_PKEY_CTX_get_data;
+		TS_STATUS_INFO_print_bio;
+		EVP_PKEY_derive_init;
+		d2i_TS_TST_INFO;
+		EVP_PKEY_asn1_add_alias;
+		d2i_TS_RESP_bio;
+		OTHERNAME_cmp;
+		GENERAL_NAME_set0_value;
+		PKCS7_RECIP_INFO_get0_alg;
+		TS_RESP_CTX_new;
+		TS_RESP_set_tst_info;
+		PKCS7_final;
+		EVP_PKEY_base_id;
+		TS_RESP_CTX_set_signer_cert;
+		TS_REQ_set_msg_imprint;
+		EVP_PKEY_CTX_ctrl;
+		TS_CONF_set_digests;
+		d2i_TS_MSG_IMPRINT;
+		EVP_PKEY_meth_set_ctrl;
+		TS_REQ_get_ext_by_NID;
+		PKCS5_pbe_set0_algor;
+		BN_BLINDING_thread_id;
+		TS_ACCURACY_new;
+		X509_CRL_METHOD_free;
+		ASN1_PCTX_get_nm_flags;
+		EVP_PKEY_meth_set_sign;
+		CRYPTO_THREADID_current;
+		EVP_PKEY_decrypt_init;
+		NETSCAPE_X509_free;
+		i2b_PVK_bio;
+		EVP_PKEY_print_private;
+		GENERAL_NAME_get0_value;
+		b2i_PVK_bio;
+		ASN1_UTCTIME_adj;
+		TS_TST_INFO_new;
+		EVP_MD_do_all_sorted;
+		TS_CONF_set_default_engine;
+		TS_ACCURACY_set_seconds;
+		TS_TST_INFO_get_time;
+		PKCS8_pkey_get0;
+		EVP_PKEY_asn1_get0;
+		OBJ_add_sigid;
+		PKCS7_SIGNER_INFO_sign;
+		EVP_PKEY_paramgen_init;
+		EVP_PKEY_sign;
+		OBJ_sigid_free;
+		EVP_PKEY_meth_set_init;
+		d2i_ESS_ISSUER_SERIAL;
+		ISSUING_DIST_POINT_new;
+		ASN1_TIME_adj;
+		TS_OBJ_print_bio;
+		EVP_PKEY_meth_set_verify_recover;
+		EVP_PKEY_meth_set_vrfy_recover;
+		TS_RESP_get_status_info;
+		CMS_stream;
+		EVP_PKEY_CTX_set_cb;
+		PKCS7_to_TS_TST_INFO;
+		ASN1_PCTX_get_oid_flags;
+		TS_TST_INFO_add_ext;
+		EVP_PKEY_meth_set_derive;
+		i2d_TS_RESP_fp;
+		i2d_TS_MSG_IMPRINT_bio;
+		TS_RESP_CTX_set_accuracy;
+		TS_REQ_set_nonce;
+		ESS_CERT_ID_new;
+		ENGINE_pkey_asn1_find_str;
+		TS_REQ_get_ext_count;
+		BUF_reverse;
+		TS_TST_INFO_print_bio;
+		d2i_ISSUING_DIST_POINT;
+		ENGINE_get_pkey_meths;
+		i2b_PrivateKey_bio;
+		i2d_TS_RESP;
+		b2i_PublicKey;
+		TS_VERIFY_CTX_cleanup;
+		TS_STATUS_INFO_free;
+		TS_RESP_verify_token;
+		OBJ_bsearch_ex_;
+		ASN1_bn_print;
+		EVP_PKEY_asn1_get_count;
+		ENGINE_register_pkey_asn1_meths;
+		ASN1_PCTX_set_nm_flags;
+		EVP_DigestVerifyInit;
+		ENGINE_set_default_pkey_meths;
+		TS_TST_INFO_get_policy_id;
+		TS_REQ_get_cert_req;
+		X509_CRL_set_meth_data;
+		PKCS8_pkey_set0;
+		ASN1_STRING_copy;
+		d2i_TS_TST_INFO_fp;
+		X509_CRL_match;
+		EVP_PKEY_asn1_set_private;
+		TS_TST_INFO_get_ext_d2i;
+		TS_RESP_CTX_add_policy;
+		d2i_TS_RESP;
+		TS_CONF_load_certs;
+		TS_TST_INFO_get_msg_imprint;
+		ERR_load_TS_strings;
+		TS_TST_INFO_get_version;
+		EVP_PKEY_CTX_dup;
+		EVP_PKEY_meth_set_verify;
+		i2b_PublicKey_bio;
+		TS_CONF_set_certs;
+		EVP_PKEY_asn1_get0_info;
+		TS_VERIFY_CTX_free;
+		TS_REQ_get_ext_by_critical;
+		TS_RESP_CTX_set_serial_cb;
+		X509_CRL_get_meth_data;
+		TS_RESP_CTX_set_time_cb;
+		TS_MSG_IMPRINT_get_msg;
+		TS_TST_INFO_ext_free;
+		TS_REQ_get_version;
+		TS_REQ_add_ext;
+		EVP_PKEY_CTX_set_app_data;
+		OBJ_bsearch_;
+		EVP_PKEY_meth_set_verifyctx;
+		i2d_PKCS7_bio_stream;
+		CRYPTO_THREADID_set_numeric;
+		PKCS7_sign_add_signer;
+		d2i_TS_TST_INFO_bio;
+		TS_TST_INFO_get_ordering;
+		TS_RESP_print_bio;
+		TS_TST_INFO_get_exts;
+		HMAC_CTX_copy;
+		PKCS5_pbe2_set_iv;
+		ENGINE_get_pkey_asn1_meths;
+		b2i_PrivateKey;
+		EVP_PKEY_CTX_get_app_data;
+		TS_REQ_set_cert_req;
+		CRYPTO_THREADID_set_callback;
+		TS_CONF_set_serial;
+		TS_TST_INFO_free;
+		d2i_TS_REQ_fp;
+		TS_RESP_verify_response;
+		i2d_ESS_ISSUER_SERIAL;
+		TS_ACCURACY_get_seconds;
+		EVP_CIPHER_do_all;
+		b2i_PrivateKey_bio;
+		OCSP_CERTID_dup;
+		X509_PUBKEY_get0_param;
+		TS_MSG_IMPRINT_dup;
+		PKCS7_print_ctx;
+		i2d_TS_REQ_bio;
+		EVP_whirlpool;
+		EVP_PKEY_asn1_set_param;
+		EVP_PKEY_meth_set_encrypt;
+		ASN1_PCTX_set_flags;
+		i2d_ESS_CERT_ID;
+		TS_VERIFY_CTX_new;
+		TS_RESP_CTX_set_extension_cb;
+		ENGINE_register_all_pkey_meths;
+		TS_RESP_CTX_set_status_info_cond;
+		TS_RESP_CTX_set_stat_info_cond;
+		EVP_PKEY_verify;
+		WHIRLPOOL_Final;
+		X509_CRL_METHOD_new;
+		EVP_DigestSignFinal;
+		TS_RESP_CTX_set_def_policy;
+		NETSCAPE_X509_it;
+		TS_RESP_create_response;
+		PKCS7_SIGNER_INFO_get0_algs;
+		TS_TST_INFO_get_nonce;
+		EVP_PKEY_decrypt_old;
+		TS_TST_INFO_set_policy_id;
+		TS_CONF_set_ess_cert_id_chain;
+		EVP_PKEY_CTX_get0_pkey;
+		d2i_TS_REQ;
+		EVP_PKEY_asn1_find_str;
+		BIO_f_asn1;
+		ESS_SIGNING_CERT_new;
+		EVP_PBE_find;
+		X509_CRL_get0_by_cert;
+		EVP_PKEY_derive;
+		i2d_TS_REQ;
+		TS_TST_INFO_delete_ext;
+		ESS_ISSUER_SERIAL_free;
+		ASN1_PCTX_set_str_flags;
+		ENGINE_get_pkey_asn1_meth_str;
+		TS_CONF_set_signer_key;
+		TS_ACCURACY_get_millis;
+		TS_RESP_get_token;
+		TS_ACCURACY_dup;
+		ENGINE_register_all_pkey_asn1_meths;
+		ENGINE_reg_all_pkey_asn1_meths;
+		X509_CRL_set_default_method;
+		CRYPTO_THREADID_hash;
+		CMS_ContentInfo_print_ctx;
+		TS_RESP_free;
+		ISSUING_DIST_POINT_free;
+		ESS_ISSUER_SERIAL_new;
+		CMS_add1_crl;
+		PKCS7_add1_attrib_digest;
+		TS_RESP_CTX_add_md;
+		TS_TST_INFO_dup;
+		ENGINE_set_pkey_asn1_meths;
+		PEM_write_bio_Parameters;
+		TS_TST_INFO_get_accuracy;
+		X509_CRL_get0_by_serial;
+		TS_TST_INFO_set_version;
+		TS_RESP_CTX_get_tst_info;
+		TS_RESP_verify_signature;
+		CRYPTO_THREADID_get_callback;
+		TS_TST_INFO_get_tsa;
+		TS_STATUS_INFO_new;
+		EVP_PKEY_CTX_get_cb;
+		TS_REQ_get_ext_d2i;
+		GENERAL_NAME_set0_othername;
+		TS_TST_INFO_get_ext_count;
+		TS_RESP_CTX_get_request;
+		i2d_NETSCAPE_X509;
+		ENGINE_get_pkey_meth_engine;
+		EVP_PKEY_meth_set_signctx;
+		EVP_PKEY_asn1_copy;
+		ASN1_TYPE_cmp;
+		EVP_CIPHER_do_all_sorted;
+		EVP_PKEY_CTX_free;
+		ISSUING_DIST_POINT_it;
+		d2i_TS_MSG_IMPRINT_fp;
+		X509_STORE_get1_certs;
+		EVP_PKEY_CTX_get_operation;
+		d2i_ESS_SIGNING_CERT;
+		TS_CONF_set_ordering;
+		EVP_PBE_alg_add_type;
+		TS_REQ_set_version;
+		EVP_PKEY_get0;
+		BIO_asn1_set_suffix;
+		i2d_TS_STATUS_INFO;
+		EVP_MD_do_all;
+		TS_TST_INFO_set_accuracy;
+		PKCS7_add_attrib_content_type;
+		ERR_remove_thread_state;
+		EVP_PKEY_meth_add0;
+		TS_TST_INFO_set_tsa;
+		EVP_PKEY_meth_new;
+		WHIRLPOOL_Update;
+		TS_CONF_set_accuracy;
+		ASN1_PCTX_set_oid_flags;
+		ESS_SIGNING_CERT_dup;
+		d2i_TS_REQ_bio;
+		X509_time_adj_ex;
+		TS_RESP_CTX_add_flags;
+		d2i_TS_STATUS_INFO;
+		TS_MSG_IMPRINT_set_msg;
+		BIO_asn1_get_suffix;
+		TS_REQ_free;
+		EVP_PKEY_meth_free;
+		TS_REQ_get_exts;
+		TS_RESP_CTX_set_clock_precision_digits;
+		TS_RESP_CTX_set_clk_prec_digits;
+		TS_RESP_CTX_add_failure_info;
+		i2d_TS_RESP_bio;
+		EVP_PKEY_CTX_get0_peerkey;
+		PEM_write_bio_CMS_stream;
+		TS_REQ_new;
+		TS_MSG_IMPRINT_new;
+		EVP_PKEY_meth_find;
+		EVP_PKEY_id;
+		TS_TST_INFO_set_serial;
+		a2i_GENERAL_NAME;
+		TS_CONF_set_crypto_device;
+		EVP_PKEY_verify_init;
+		TS_CONF_set_policies;
+		ASN1_PCTX_new;
+		ESS_CERT_ID_free;
+		ENGINE_unregister_pkey_meths;
+		TS_MSG_IMPRINT_free;
+		TS_VERIFY_CTX_init;
+		PKCS7_stream;
+		TS_RESP_CTX_set_certs;
+		TS_CONF_set_def_policy;
+		ASN1_GENERALIZEDTIME_adj;
+		NETSCAPE_X509_new;
+		TS_ACCURACY_free;
+		TS_RESP_get_tst_info;
+		EVP_PKEY_derive_set_peer;
+		PEM_read_bio_Parameters;
+		TS_CONF_set_clock_precision_digits;
+		TS_CONF_set_clk_prec_digits;
+		ESS_ISSUER_SERIAL_dup;
+		TS_ACCURACY_get_micros;
+		ASN1_PCTX_get_str_flags;
+		NAME_CONSTRAINTS_check;
+		ASN1_BIT_STRING_check;
+		X509_check_akid;
+		ENGINE_unregister_pkey_asn1_meths;
+		ENGINE_unreg_pkey_asn1_meths;
+		ASN1_PCTX_free;
+		PEM_write_bio_ASN1_stream;
+		i2d_ASN1_bio_stream;
+		TS_X509_ALGOR_print_bio;
+		EVP_PKEY_meth_set_cleanup;
+		EVP_PKEY_asn1_free;
+		ESS_SIGNING_CERT_free;
+		TS_TST_INFO_set_msg_imprint;
+		GENERAL_NAME_cmp;
+		d2i_ASN1_SET_ANY;
+		ENGINE_set_pkey_meths;
+		i2d_TS_REQ_fp;
+		d2i_ASN1_SEQUENCE_ANY;
+		GENERAL_NAME_get0_otherName;
+		d2i_ESS_CERT_ID;
+		OBJ_find_sigid_algs;
+		EVP_PKEY_meth_set_keygen;
+		PKCS5_PBKDF2_HMAC;
+		EVP_PKEY_paramgen;
+		EVP_PKEY_meth_set_paramgen;
+		BIO_new_PKCS7;
+		EVP_PKEY_verify_recover;
+		TS_ext_print_bio;
+		TS_ASN1_INTEGER_print_bio;
+		check_defer;
+		DSO_pathbyaddr;
+		EVP_PKEY_set_type;
+		TS_ACCURACY_set_micros;
+		TS_REQ_to_TS_VERIFY_CTX;
+		EVP_PKEY_meth_set_copy;
+		ASN1_PCTX_set_cert_flags;
+		TS_TST_INFO_get_ext;
+		EVP_PKEY_asn1_set_ctrl;
+		TS_TST_INFO_get_ext_by_critical;
+		EVP_PKEY_CTX_new_id;
+		TS_REQ_get_ext_by_OBJ;
+		TS_CONF_set_signer_cert;
+		X509_NAME_hash_old;
+		ASN1_TIME_set_string;
+		EVP_MD_flags;
+		TS_RESP_CTX_free;
+		DSAparams_dup;
+		DHparams_dup;
+		OCSP_REQ_CTX_add1_header;
+		OCSP_REQ_CTX_set1_req;
+		X509_STORE_set_verify_cb;
+		X509_STORE_CTX_get0_current_crl;
+		X509_STORE_CTX_get0_parent_ctx;
+		X509_STORE_CTX_get0_current_issuer;
+		X509_STORE_CTX_get0_cur_issuer;
+		X509_issuer_name_hash_old;
+		X509_subject_name_hash_old;
+		EVP_CIPHER_CTX_copy;
+		UI_method_get_prompt_constructor;
+		UI_method_get_prompt_constructr;
+		UI_method_set_prompt_constructor;
+		UI_method_set_prompt_constructr;
+		EVP_read_pw_string_min;
+		CRYPTO_cts128_encrypt;
+		CRYPTO_cts128_decrypt_block;
+		CRYPTO_cfb128_1_encrypt;
+		CRYPTO_cbc128_encrypt;
+		CRYPTO_ctr128_encrypt;
+		CRYPTO_ofb128_encrypt;
+		CRYPTO_cts128_decrypt;
+		CRYPTO_cts128_encrypt_block;
+		CRYPTO_cbc128_decrypt;
+		CRYPTO_cfb128_encrypt;
+		CRYPTO_cfb128_8_encrypt;
+
+	local:
+		*;
+};
+
+
+OPENSSL_1.0.1 {
+	global:
+		SSL_renegotiate_abbreviated;
+		TLSv1_1_method;
+		TLSv1_1_client_method;
+		TLSv1_1_server_method;
+		SSL_CTX_set_srp_client_pwd_callback;
+		SSL_CTX_set_srp_client_pwd_cb;
+		SSL_get_srp_g;
+		SSL_CTX_set_srp_username_callback;
+		SSL_CTX_set_srp_un_cb;
+		SSL_get_srp_userinfo;
+		SSL_set_srp_server_param;
+		SSL_set_srp_server_param_pw;
+		SSL_get_srp_N;
+		SSL_get_srp_username;
+		SSL_CTX_set_srp_password;
+		SSL_CTX_set_srp_strength;
+		SSL_CTX_set_srp_verify_param_callback;
+		SSL_CTX_set_srp_vfy_param_cb;
+		SSL_CTX_set_srp_cb_arg;
+		SSL_CTX_set_srp_username;
+		SSL_CTX_SRP_CTX_init;
+		SSL_SRP_CTX_init;
+		SRP_Calc_A_param;
+		SRP_generate_server_master_secret;
+		SRP_gen_server_master_secret;
+		SSL_CTX_SRP_CTX_free;
+		SRP_generate_client_master_secret;
+		SRP_gen_client_master_secret;
+		SSL_srp_server_param_with_username;
+		SSL_srp_server_param_with_un;
+		SSL_SRP_CTX_free;
+		SSL_set_debug;
+		SSL_SESSION_get0_peer;
+		TLSv1_2_client_method;
+		SSL_SESSION_set1_id_context;
+		TLSv1_2_server_method;
+		SSL_cache_hit;
+		SSL_get0_kssl_ctx;
+		SSL_set0_kssl_ctx;
+		SSL_set_state;
+		SSL_CIPHER_get_id;
+		TLSv1_2_method;
+		kssl_ctx_get0_client_princ;
+		SSL_export_keying_material;
+		SSL_set_tlsext_use_srtp;
+		SSL_CTX_set_next_protos_advertised_cb;
+		SSL_CTX_set_next_protos_adv_cb;
+		SSL_get0_next_proto_negotiated;
+		SSL_get_selected_srtp_profile;
+		SSL_CTX_set_tlsext_use_srtp;
+		SSL_select_next_proto;
+		SSL_get_srtp_profiles;
+		SSL_CTX_set_next_proto_select_cb;
+		SSL_CTX_set_next_proto_sel_cb;
+		SSL_SESSION_get_compress_id;
+
+		SRP_VBASE_get_by_user;
+		SRP_Calc_server_key;
+		SRP_create_verifier;
+		SRP_create_verifier_BN;
+		SRP_Calc_u;
+		SRP_VBASE_free;
+		SRP_Calc_client_key;
+		SRP_get_default_gN;
+		SRP_Calc_x;
+		SRP_Calc_B;
+		SRP_VBASE_new;
+		SRP_check_known_gN_param;
+		SRP_Calc_A;
+		SRP_Verify_A_mod_N;
+		SRP_VBASE_init;
+		SRP_Verify_B_mod_N;
+		EC_KEY_set_public_key_affine_coordinates;
+		EC_KEY_set_pub_key_aff_coords;
+		EVP_aes_192_ctr;
+		EVP_PKEY_meth_get0_info;
+		EVP_PKEY_meth_copy;
+		ERR_add_error_vdata;
+		EVP_aes_128_ctr;
+		EVP_aes_256_ctr;
+		EC_GFp_nistp224_method;
+		EC_KEY_get_flags;
+		RSA_padding_add_PKCS1_PSS_mgf1;
+		EVP_aes_128_xts;
+		EVP_aes_256_xts;
+		EVP_aes_128_gcm;
+		EC_KEY_clear_flags;
+		EC_KEY_set_flags;
+		EVP_aes_256_ccm;
+		RSA_verify_PKCS1_PSS_mgf1;
+		EVP_aes_128_ccm;
+		EVP_aes_192_gcm;
+		X509_ALGOR_set_md;
+		RAND_init_fips;
+		EVP_aes_256_gcm;
+		EVP_aes_192_ccm;
+		CMAC_CTX_copy;
+		CMAC_CTX_free;
+		CMAC_CTX_get0_cipher_ctx;
+		CMAC_CTX_cleanup;
+		CMAC_Init;
+		CMAC_Update;
+		CMAC_resume;
+		CMAC_CTX_new;
+		CMAC_Final;
+		CRYPTO_ctr128_encrypt_ctr32;
+		CRYPTO_gcm128_release;
+		CRYPTO_ccm128_decrypt_ccm64;
+		CRYPTO_ccm128_encrypt;
+		CRYPTO_gcm128_encrypt;
+		CRYPTO_xts128_encrypt;
+		EVP_rc4_hmac_md5;
+		CRYPTO_nistcts128_decrypt_block;
+		CRYPTO_gcm128_setiv;
+		CRYPTO_nistcts128_encrypt;
+		EVP_aes_128_cbc_hmac_sha1;
+		CRYPTO_gcm128_tag;
+		CRYPTO_ccm128_encrypt_ccm64;
+		ENGINE_load_rdrand;
+		CRYPTO_ccm128_setiv;
+		CRYPTO_nistcts128_encrypt_block;
+		CRYPTO_gcm128_aad;
+		CRYPTO_ccm128_init;
+		CRYPTO_nistcts128_decrypt;
+		CRYPTO_gcm128_new;
+		CRYPTO_ccm128_tag;
+		CRYPTO_ccm128_decrypt;
+		CRYPTO_ccm128_aad;
+		CRYPTO_gcm128_init;
+		CRYPTO_gcm128_decrypt;
+		ENGINE_load_rsax;
+		CRYPTO_gcm128_decrypt_ctr32;
+		CRYPTO_gcm128_encrypt_ctr32;
+		CRYPTO_gcm128_finish;
+		EVP_aes_256_cbc_hmac_sha1;
+		PKCS5_pbkdf2_set;
+		CMS_add0_recipient_password;
+		CMS_decrypt_set1_password;
+		CMS_RecipientInfo_set0_password;
+		RAND_set_fips_drbg_type;
+		X509_REQ_sign_ctx;
+		RSA_PSS_PARAMS_new;
+		X509_CRL_sign_ctx;
+		X509_signature_dump;
+		d2i_RSA_PSS_PARAMS;
+		RSA_PSS_PARAMS_it;
+		RSA_PSS_PARAMS_free;
+		X509_sign_ctx;
+		i2d_RSA_PSS_PARAMS;
+		ASN1_item_sign_ctx;
+		EC_GFp_nistp521_method;
+		EC_GFp_nistp256_method;
+		OPENSSL_stderr;
+		OPENSSL_cpuid_setup;
+		OPENSSL_showfatal;
+		BIO_new_dgram_sctp;
+		BIO_dgram_sctp_msg_waiting;
+		BIO_dgram_sctp_wait_for_dry;
+		BIO_s_datagram_sctp;
+		BIO_dgram_is_sctp;
+		BIO_dgram_sctp_notification_cb;
+} OPENSSL_1.0.0;
+
+OPENSSL_1.0.1d {
+	global:
+		CRYPTO_memcmp;
+} OPENSSL_1.0.1;
+
+OPENSSL_1.0.1s {
+	global:
+		SRP_VBASE_get1_by_user;
+		SRP_user_pwd_free;
+} OPENSSL_1.0.1d;
+
+OPENSSL_1.0.2 {
+	global:
+		SSL_CTX_set_alpn_protos;
+		SSL_set_alpn_protos;
+		SSL_CTX_set_alpn_select_cb;
+		SSL_get0_alpn_selected;
+		SSL_CTX_set_custom_cli_ext;
+		SSL_CTX_set_custom_srv_ext;
+		SSL_CTX_set_srv_supp_data;
+		SSL_CTX_set_cli_supp_data;
+		SSL_set_cert_cb;
+		SSL_CTX_use_serverinfo;
+		SSL_CTX_use_serverinfo_file;
+		SSL_CTX_set_cert_cb;
+		SSL_CTX_get0_param;
+		SSL_get0_param;
+		SSL_certs_clear;
+		DTLSv1_2_method;
+		DTLSv1_2_server_method;
+		DTLSv1_2_client_method;
+		DTLS_method;
+		DTLS_server_method;
+		DTLS_client_method;
+		SSL_CTX_get_ssl_method;
+		SSL_CTX_get0_certificate;
+		SSL_CTX_get0_privatekey;
+		SSL_COMP_set0_compression_methods;
+		SSL_COMP_free_compression_methods;
+		SSL_CIPHER_find;
+		SSL_is_server;
+		SSL_CONF_CTX_new;
+		SSL_CONF_CTX_finish;
+		SSL_CONF_CTX_free;
+		SSL_CONF_CTX_set_flags;
+		SSL_CONF_CTX_clear_flags;
+		SSL_CONF_CTX_set1_prefix;
+		SSL_CONF_CTX_set_ssl;
+		SSL_CONF_CTX_set_ssl_ctx;
+		SSL_CONF_cmd;
+		SSL_CONF_cmd_argv;
+		SSL_CONF_cmd_value_type;
+		SSL_trace;
+		SSL_CIPHER_standard_name;
+		SSL_get_tlsa_record_byname;
+		ASN1_TIME_diff;
+		BIO_hex_string;
+		CMS_RecipientInfo_get0_pkey_ctx;
+		CMS_RecipientInfo_encrypt;
+		CMS_SignerInfo_get0_pkey_ctx;
+		CMS_SignerInfo_get0_md_ctx;
+		CMS_SignerInfo_get0_signature;
+		CMS_RecipientInfo_kari_get0_alg;
+		CMS_RecipientInfo_kari_get0_reks;
+		CMS_RecipientInfo_kari_get0_orig_id;
+		CMS_RecipientInfo_kari_orig_id_cmp;
+		CMS_RecipientEncryptedKey_get0_id;
+		CMS_RecipientEncryptedKey_cert_cmp;
+		CMS_RecipientInfo_kari_set0_pkey;
+		CMS_RecipientInfo_kari_get0_ctx;
+		CMS_RecipientInfo_kari_decrypt;
+		CMS_SharedInfo_encode;
+		DH_compute_key_padded;
+		d2i_DHxparams;
+		i2d_DHxparams;
+		DH_get_1024_160;
+		DH_get_2048_224;
+		DH_get_2048_256;
+		DH_KDF_X9_42;
+		ECDH_KDF_X9_62;
+		ECDSA_METHOD_new;
+		ECDSA_METHOD_free;
+		ECDSA_METHOD_set_app_data;
+		ECDSA_METHOD_get_app_data;
+		ECDSA_METHOD_set_sign;
+		ECDSA_METHOD_set_sign_setup;
+		ECDSA_METHOD_set_verify;
+		ECDSA_METHOD_set_flags;
+		ECDSA_METHOD_set_name;
+		EVP_des_ede3_wrap;
+		EVP_aes_128_wrap;
+		EVP_aes_192_wrap;
+		EVP_aes_256_wrap;
+		EVP_aes_128_cbc_hmac_sha256;
+		EVP_aes_256_cbc_hmac_sha256;
+		CRYPTO_128_wrap;
+		CRYPTO_128_unwrap;
+		OCSP_REQ_CTX_nbio;
+		OCSP_REQ_CTX_new;
+		OCSP_set_max_response_length;
+		OCSP_REQ_CTX_i2d;
+		OCSP_REQ_CTX_nbio_d2i;
+		OCSP_REQ_CTX_get0_mem_bio;
+		OCSP_REQ_CTX_http;
+		RSA_padding_add_PKCS1_OAEP_mgf1;
+		RSA_padding_check_PKCS1_OAEP_mgf1;
+		RSA_OAEP_PARAMS_free;
+		RSA_OAEP_PARAMS_it;
+		RSA_OAEP_PARAMS_new;
+		SSL_get_sigalgs;
+		SSL_get_shared_sigalgs;
+		SSL_check_chain;
+		X509_chain_up_ref;
+		X509_http_nbio;
+		X509_CRL_http_nbio;
+		X509_REVOKED_dup;
+		i2d_re_X509_tbs;
+		X509_get0_signature;
+		X509_get_signature_nid;
+		X509_CRL_diff;
+		X509_chain_check_suiteb;
+		X509_CRL_check_suiteb;
+		X509_check_host;
+		X509_check_email;
+		X509_check_ip;
+		X509_check_ip_asc;
+		X509_STORE_set_lookup_crls_cb;
+		X509_STORE_CTX_get0_store;
+		X509_VERIFY_PARAM_set1_host;
+		X509_VERIFY_PARAM_add1_host;
+		X509_VERIFY_PARAM_set_hostflags;
+		X509_VERIFY_PARAM_get0_peername;
+		X509_VERIFY_PARAM_set1_email;
+		X509_VERIFY_PARAM_set1_ip;
+		X509_VERIFY_PARAM_set1_ip_asc;
+		X509_VERIFY_PARAM_get0_name;
+		X509_VERIFY_PARAM_get_count;
+		X509_VERIFY_PARAM_get0;
+		X509V3_EXT_free;
+		EC_GROUP_get_mont_data;
+		EC_curve_nid2nist;
+		EC_curve_nist2nid;
+		PEM_write_bio_DHxparams;
+		PEM_write_DHxparams;
+		SSL_CTX_add_client_custom_ext;
+		SSL_CTX_add_server_custom_ext;
+		SSL_extension_supported;
+		BUF_strnlen;
+		sk_deep_copy;
+		SSL_test_functions;
+} OPENSSL_1.0.1d;
diff -uNr openssl-1.0.2l.orig/ssl/s3_both.c openssl-1.0.2l/ssl/s3_both.c
--- openssl-1.0.2l.orig/ssl/s3_both.c	2017-05-25 20:54:34.000000000 +0800
+++ openssl-1.0.2l/ssl/s3_both.c	2018-07-16 17:01:21.684443274 +0800
@@ -584,6 +584,7 @@
     return (al);
 }
 
+#define OPENSSL_NO_BUF_FREELISTS
 #ifndef OPENSSL_NO_BUF_FREELISTS
 /*-
  * On some platforms, malloc() performance is bad enough that you can't just
diff -uNr openssl-1.0.2l.orig/ssl/s3_both.c.orig openssl-1.0.2l/ssl/s3_both.c.orig
--- openssl-1.0.2l.orig/ssl/s3_both.c.orig	1970-01-01 08:00:00.000000000 +0800
+++ openssl-1.0.2l/ssl/s3_both.c.orig	2017-05-25 20:54:34.000000000 +0800
@@ -0,0 +1,758 @@
+/* ssl/s3_both.c */
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ *
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ *
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+/* ====================================================================
+ * Copyright (c) 1998-2002 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+/* ====================================================================
+ * Copyright 2002 Sun Microsystems, Inc. ALL RIGHTS RESERVED.
+ * ECC cipher suite support in OpenSSL originally developed by
+ * SUN MICROSYSTEMS, INC., and contributed to the OpenSSL project.
+ */
+
+#include <limits.h>
+#include <string.h>
+#include <stdio.h>
+#include "ssl_locl.h"
+#include <openssl/buffer.h>
+#include <openssl/rand.h>
+#include <openssl/objects.h>
+#include <openssl/evp.h>
+#include <openssl/x509.h>
+
+/*
+ * send s->init_buf in records of type 'type' (SSL3_RT_HANDSHAKE or
+ * SSL3_RT_CHANGE_CIPHER_SPEC)
+ */
+int ssl3_do_write(SSL *s, int type)
+{
+    int ret;
+
+    ret = ssl3_write_bytes(s, type, &s->init_buf->data[s->init_off],
+                           s->init_num);
+    if (ret < 0)
+        return (-1);
+    if (type == SSL3_RT_HANDSHAKE)
+        /*
+         * should not be done for 'Hello Request's, but in that case we'll
+         * ignore the result anyway
+         */
+        ssl3_finish_mac(s, (unsigned char *)&s->init_buf->data[s->init_off],
+                        ret);
+
+    if (ret == s->init_num) {
+        if (s->msg_callback)
+            s->msg_callback(1, s->version, type, s->init_buf->data,
+                            (size_t)(s->init_off + s->init_num), s,
+                            s->msg_callback_arg);
+        return (1);
+    }
+    s->init_off += ret;
+    s->init_num -= ret;
+    return (0);
+}
+
+int ssl3_send_finished(SSL *s, int a, int b, const char *sender, int slen)
+{
+    unsigned char *p;
+    int i;
+    unsigned long l;
+
+    if (s->state == a) {
+        p = ssl_handshake_start(s);
+
+        i = s->method->ssl3_enc->final_finish_mac(s,
+                                                  sender, slen,
+                                                  s->s3->tmp.finish_md);
+        if (i <= 0)
+            return 0;
+        s->s3->tmp.finish_md_len = i;
+        memcpy(p, s->s3->tmp.finish_md, i);
+        l = i;
+
+        /*
+         * Copy the finished so we can use it for renegotiation checks
+         */
+        if (s->type == SSL_ST_CONNECT) {
+            OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
+            memcpy(s->s3->previous_client_finished, s->s3->tmp.finish_md, i);
+            s->s3->previous_client_finished_len = i;
+        } else {
+            OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
+            memcpy(s->s3->previous_server_finished, s->s3->tmp.finish_md, i);
+            s->s3->previous_server_finished_len = i;
+        }
+
+#ifdef OPENSSL_SYS_WIN16
+        /*
+         * MSVC 1.5 does not clear the top bytes of the word unless I do
+         * this.
+         */
+        l &= 0xffff;
+#endif
+        ssl_set_handshake_header(s, SSL3_MT_FINISHED, l);
+        s->state = b;
+    }
+
+    /* SSL3_ST_SEND_xxxxxx_HELLO_B */
+    return ssl_do_write(s);
+}
+
+#ifndef OPENSSL_NO_NEXTPROTONEG
+/*
+ * ssl3_take_mac calculates the Finished MAC for the handshakes messages seen
+ * to far.
+ */
+static void ssl3_take_mac(SSL *s)
+{
+    const char *sender;
+    int slen;
+    /*
+     * If no new cipher setup return immediately: other functions will set
+     * the appropriate error.
+     */
+    if (s->s3->tmp.new_cipher == NULL)
+        return;
+    if (s->state & SSL_ST_CONNECT) {
+        sender = s->method->ssl3_enc->server_finished_label;
+        slen = s->method->ssl3_enc->server_finished_label_len;
+    } else {
+        sender = s->method->ssl3_enc->client_finished_label;
+        slen = s->method->ssl3_enc->client_finished_label_len;
+    }
+
+    s->s3->tmp.peer_finish_md_len = s->method->ssl3_enc->final_finish_mac(s,
+                                                                          sender,
+                                                                          slen,
+                                                                          s->s3->tmp.peer_finish_md);
+}
+#endif
+
+int ssl3_get_finished(SSL *s, int a, int b)
+{
+    int al, i, ok;
+    long n;
+    unsigned char *p;
+
+#ifdef OPENSSL_NO_NEXTPROTONEG
+    /*
+     * the mac has already been generated when we received the change cipher
+     * spec message and is in s->s3->tmp.peer_finish_md
+     */
+#endif
+
+    /* 64 argument should actually be 36+4 :-) */
+    n = s->method->ssl_get_message(s, a, b, SSL3_MT_FINISHED, 64, &ok);
+
+    if (!ok)
+        return ((int)n);
+
+    /* If this occurs, we have missed a message */
+    if (!s->s3->change_cipher_spec) {
+        al = SSL_AD_UNEXPECTED_MESSAGE;
+        SSLerr(SSL_F_SSL3_GET_FINISHED, SSL_R_GOT_A_FIN_BEFORE_A_CCS);
+        goto f_err;
+    }
+    s->s3->change_cipher_spec = 0;
+
+    p = (unsigned char *)s->init_msg;
+    i = s->s3->tmp.peer_finish_md_len;
+
+    if (i != n) {
+        al = SSL_AD_DECODE_ERROR;
+        SSLerr(SSL_F_SSL3_GET_FINISHED, SSL_R_BAD_DIGEST_LENGTH);
+        goto f_err;
+    }
+
+    if (CRYPTO_memcmp(p, s->s3->tmp.peer_finish_md, i) != 0) {
+        al = SSL_AD_DECRYPT_ERROR;
+        SSLerr(SSL_F_SSL3_GET_FINISHED, SSL_R_DIGEST_CHECK_FAILED);
+        goto f_err;
+    }
+
+    /*
+     * Copy the finished so we can use it for renegotiation checks
+     */
+    if (s->type == SSL_ST_ACCEPT) {
+        OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
+        memcpy(s->s3->previous_client_finished, s->s3->tmp.peer_finish_md, i);
+        s->s3->previous_client_finished_len = i;
+    } else {
+        OPENSSL_assert(i <= EVP_MAX_MD_SIZE);
+        memcpy(s->s3->previous_server_finished, s->s3->tmp.peer_finish_md, i);
+        s->s3->previous_server_finished_len = i;
+    }
+
+    return (1);
+ f_err:
+    ssl3_send_alert(s, SSL3_AL_FATAL, al);
+    return (0);
+}
+
+/*-
+ * for these 2 messages, we need to
+ * ssl->enc_read_ctx                    re-init
+ * ssl->s3->read_sequence               zero
+ * ssl->s3->read_mac_secret             re-init
+ * ssl->session->read_sym_enc           assign
+ * ssl->session->read_compression       assign
+ * ssl->session->read_hash              assign
+ */
+int ssl3_send_change_cipher_spec(SSL *s, int a, int b)
+{
+    unsigned char *p;
+
+    if (s->state == a) {
+        p = (unsigned char *)s->init_buf->data;
+        *p = SSL3_MT_CCS;
+        s->init_num = 1;
+        s->init_off = 0;
+
+        s->state = b;
+    }
+
+    /* SSL3_ST_CW_CHANGE_B */
+    return (ssl3_do_write(s, SSL3_RT_CHANGE_CIPHER_SPEC));
+}
+
+unsigned long ssl3_output_cert_chain(SSL *s, CERT_PKEY *cpk)
+{
+    unsigned char *p;
+    unsigned long l = 3 + SSL_HM_HEADER_LENGTH(s);
+
+    if (!ssl_add_cert_chain(s, cpk, &l))
+        return 0;
+
+    l -= 3 + SSL_HM_HEADER_LENGTH(s);
+    p = ssl_handshake_start(s);
+    l2n3(l, p);
+    l += 3;
+    ssl_set_handshake_header(s, SSL3_MT_CERTIFICATE, l);
+    return l + SSL_HM_HEADER_LENGTH(s);
+}
+
+/*
+ * Obtain handshake message of message type 'mt' (any if mt == -1), maximum
+ * acceptable body length 'max'. The first four bytes (msg_type and length)
+ * are read in state 'st1', the body is read in state 'stn'.
+ */
+long ssl3_get_message(SSL *s, int st1, int stn, int mt, long max, int *ok)
+{
+    unsigned char *p;
+    unsigned long l;
+    long n;
+    int i, al;
+
+    if (s->s3->tmp.reuse_message) {
+        s->s3->tmp.reuse_message = 0;
+        if ((mt >= 0) && (s->s3->tmp.message_type != mt)) {
+            al = SSL_AD_UNEXPECTED_MESSAGE;
+            SSLerr(SSL_F_SSL3_GET_MESSAGE, SSL_R_UNEXPECTED_MESSAGE);
+            goto f_err;
+        }
+        *ok = 1;
+        s->state = stn;
+        s->init_msg = s->init_buf->data + SSL3_HM_HEADER_LENGTH;
+        s->init_num = (int)s->s3->tmp.message_size;
+        return s->init_num;
+    }
+
+    p = (unsigned char *)s->init_buf->data;
+
+    if (s->state == st1) {      /* s->init_num < SSL3_HM_HEADER_LENGTH */
+        int skip_message;
+
+        do {
+            while (s->init_num < SSL3_HM_HEADER_LENGTH) {
+                i = s->method->ssl_read_bytes(s, SSL3_RT_HANDSHAKE,
+                                              &p[s->init_num],
+                                              SSL3_HM_HEADER_LENGTH -
+                                              s->init_num, 0);
+                if (i <= 0) {
+                    s->rwstate = SSL_READING;
+                    *ok = 0;
+                    return i;
+                }
+                s->init_num += i;
+            }
+
+            skip_message = 0;
+            if (!s->server)
+                if (p[0] == SSL3_MT_HELLO_REQUEST)
+                    /*
+                     * The server may always send 'Hello Request' messages --
+                     * we are doing a handshake anyway now, so ignore them if
+                     * their format is correct. Does not count for 'Finished'
+                     * MAC.
+                     */
+                    if (p[1] == 0 && p[2] == 0 && p[3] == 0) {
+                        s->init_num = 0;
+                        skip_message = 1;
+
+                        if (s->msg_callback)
+                            s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE,
+                                            p, SSL3_HM_HEADER_LENGTH, s,
+                                            s->msg_callback_arg);
+                    }
+        }
+        while (skip_message);
+
+        /* s->init_num == SSL3_HM_HEADER_LENGTH */
+
+        if ((mt >= 0) && (*p != mt)) {
+            al = SSL_AD_UNEXPECTED_MESSAGE;
+            SSLerr(SSL_F_SSL3_GET_MESSAGE, SSL_R_UNEXPECTED_MESSAGE);
+            goto f_err;
+        }
+
+        s->s3->tmp.message_type = *(p++);
+
+        n2l3(p, l);
+        if (l > (unsigned long)max) {
+            al = SSL_AD_ILLEGAL_PARAMETER;
+            SSLerr(SSL_F_SSL3_GET_MESSAGE, SSL_R_EXCESSIVE_MESSAGE_SIZE);
+            goto f_err;
+        }
+        /*
+         * Make buffer slightly larger than message length as a precaution
+         * against small OOB reads e.g. CVE-2016-6306
+         */
+        if (l
+            && !BUF_MEM_grow_clean(s->init_buf,
+                                   (int)l + SSL3_HM_HEADER_LENGTH + 16)) {
+            SSLerr(SSL_F_SSL3_GET_MESSAGE, ERR_R_BUF_LIB);
+            goto err;
+        }
+        s->s3->tmp.message_size = l;
+        s->state = stn;
+
+        s->init_msg = s->init_buf->data + SSL3_HM_HEADER_LENGTH;
+        s->init_num = 0;
+    }
+
+    /* next state (stn) */
+    p = s->init_msg;
+    n = s->s3->tmp.message_size - s->init_num;
+    while (n > 0) {
+        i = s->method->ssl_read_bytes(s, SSL3_RT_HANDSHAKE, &p[s->init_num],
+                                      n, 0);
+        if (i <= 0) {
+            s->rwstate = SSL_READING;
+            *ok = 0;
+            return i;
+        }
+        s->init_num += i;
+        n -= i;
+    }
+
+#ifndef OPENSSL_NO_NEXTPROTONEG
+    /*
+     * If receiving Finished, record MAC of prior handshake messages for
+     * Finished verification.
+     */
+    if (*s->init_buf->data == SSL3_MT_FINISHED)
+        ssl3_take_mac(s);
+#endif
+
+    /* Feed this message into MAC computation. */
+    ssl3_finish_mac(s, (unsigned char *)s->init_buf->data,
+                    s->init_num + SSL3_HM_HEADER_LENGTH);
+    if (s->msg_callback)
+        s->msg_callback(0, s->version, SSL3_RT_HANDSHAKE, s->init_buf->data,
+                        (size_t)s->init_num + SSL3_HM_HEADER_LENGTH, s,
+                        s->msg_callback_arg);
+    *ok = 1;
+    return s->init_num;
+ f_err:
+    ssl3_send_alert(s, SSL3_AL_FATAL, al);
+ err:
+    *ok = 0;
+    return (-1);
+}
+
+int ssl_cert_type(X509 *x, EVP_PKEY *pkey)
+{
+    EVP_PKEY *pk;
+    int ret = -1, i;
+
+    if (pkey == NULL)
+        pk = X509_get_pubkey(x);
+    else
+        pk = pkey;
+    if (pk == NULL)
+        goto err;
+
+    i = pk->type;
+    if (i == EVP_PKEY_RSA) {
+        ret = SSL_PKEY_RSA_ENC;
+    } else if (i == EVP_PKEY_DSA) {
+        ret = SSL_PKEY_DSA_SIGN;
+    }
+#ifndef OPENSSL_NO_EC
+    else if (i == EVP_PKEY_EC) {
+        ret = SSL_PKEY_ECC;
+    }
+#endif
+    else if (i == NID_id_GostR3410_94 || i == NID_id_GostR3410_94_cc) {
+        ret = SSL_PKEY_GOST94;
+    } else if (i == NID_id_GostR3410_2001 || i == NID_id_GostR3410_2001_cc) {
+        ret = SSL_PKEY_GOST01;
+    } else if (x && (i == EVP_PKEY_DH || i == EVP_PKEY_DHX)) {
+        /*
+         * For DH two cases: DH certificate signed with RSA and DH
+         * certificate signed with DSA.
+         */
+        i = X509_certificate_type(x, pk);
+        if (i & EVP_PKS_RSA)
+            ret = SSL_PKEY_DH_RSA;
+        else if (i & EVP_PKS_DSA)
+            ret = SSL_PKEY_DH_DSA;
+    }
+
+ err:
+    if (!pkey)
+        EVP_PKEY_free(pk);
+    return (ret);
+}
+
+int ssl_verify_alarm_type(long type)
+{
+    int al;
+
+    switch (type) {
+    case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:
+    case X509_V_ERR_UNABLE_TO_GET_CRL:
+    case X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER:
+        al = SSL_AD_UNKNOWN_CA;
+        break;
+    case X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE:
+    case X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE:
+    case X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY:
+    case X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD:
+    case X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD:
+    case X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD:
+    case X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD:
+    case X509_V_ERR_CERT_NOT_YET_VALID:
+    case X509_V_ERR_CRL_NOT_YET_VALID:
+    case X509_V_ERR_CERT_UNTRUSTED:
+    case X509_V_ERR_CERT_REJECTED:
+    case X509_V_ERR_HOSTNAME_MISMATCH:
+    case X509_V_ERR_EMAIL_MISMATCH:
+    case X509_V_ERR_IP_ADDRESS_MISMATCH:
+        al = SSL_AD_BAD_CERTIFICATE;
+        break;
+    case X509_V_ERR_CERT_SIGNATURE_FAILURE:
+    case X509_V_ERR_CRL_SIGNATURE_FAILURE:
+        al = SSL_AD_DECRYPT_ERROR;
+        break;
+    case X509_V_ERR_CERT_HAS_EXPIRED:
+    case X509_V_ERR_CRL_HAS_EXPIRED:
+        al = SSL_AD_CERTIFICATE_EXPIRED;
+        break;
+    case X509_V_ERR_CERT_REVOKED:
+        al = SSL_AD_CERTIFICATE_REVOKED;
+        break;
+    case X509_V_ERR_UNSPECIFIED:
+    case X509_V_ERR_OUT_OF_MEM:
+    case X509_V_ERR_INVALID_CALL:
+    case X509_V_ERR_STORE_LOOKUP:
+        al = SSL_AD_INTERNAL_ERROR;
+        break;
+    case X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:
+    case X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN:
+    case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY:
+    case X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE:
+    case X509_V_ERR_CERT_CHAIN_TOO_LONG:
+    case X509_V_ERR_PATH_LENGTH_EXCEEDED:
+    case X509_V_ERR_INVALID_CA:
+        al = SSL_AD_UNKNOWN_CA;
+        break;
+    case X509_V_ERR_APPLICATION_VERIFICATION:
+        al = SSL_AD_HANDSHAKE_FAILURE;
+        break;
+    case X509_V_ERR_INVALID_PURPOSE:
+        al = SSL_AD_UNSUPPORTED_CERTIFICATE;
+        break;
+    default:
+        al = SSL_AD_CERTIFICATE_UNKNOWN;
+        break;
+    }
+    return (al);
+}
+
+#ifndef OPENSSL_NO_BUF_FREELISTS
+/*-
+ * On some platforms, malloc() performance is bad enough that you can't just
+ * free() and malloc() buffers all the time, so we need to use freelists from
+ * unused buffers.  Currently, each freelist holds memory chunks of only a
+ * given size (list->chunklen); other sized chunks are freed and malloced.
+ * This doesn't help much if you're using many different SSL option settings
+ * with a given context.  (The options affecting buffer size are
+ * max_send_fragment, read buffer vs write buffer,
+ * SSL_OP_MICROSOFT_BIG_WRITE_BUFFER, SSL_OP_NO_COMPRESSION, and
+ * SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS.)  Using a separate freelist for every
+ * possible size is not an option, since max_send_fragment can take on many
+ * different values.
+ *
+ * If you are on a platform with a slow malloc(), and you're using SSL
+ * connections with many different settings for these options, and you need to
+ * use the SSL_MOD_RELEASE_BUFFERS feature, you have a few options:
+ *    - Link against a faster malloc implementation.
+ *    - Use a separate SSL_CTX for each option set.
+ *    - Improve this code.
+ */
+static void *freelist_extract(SSL_CTX *ctx, int for_read, int sz)
+{
+    SSL3_BUF_FREELIST *list;
+    SSL3_BUF_FREELIST_ENTRY *ent = NULL;
+    void *result = NULL;
+
+    CRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);
+    list = for_read ? ctx->rbuf_freelist : ctx->wbuf_freelist;
+    if (list != NULL && sz == (int)list->chunklen)
+        ent = list->head;
+    if (ent != NULL) {
+        list->head = ent->next;
+        result = ent;
+        if (--list->len == 0)
+            list->chunklen = 0;
+    }
+    CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);
+    if (!result)
+        result = OPENSSL_malloc(sz);
+    return result;
+}
+
+static void freelist_insert(SSL_CTX *ctx, int for_read, size_t sz, void *mem)
+{
+    SSL3_BUF_FREELIST *list;
+    SSL3_BUF_FREELIST_ENTRY *ent;
+
+    CRYPTO_w_lock(CRYPTO_LOCK_SSL_CTX);
+    list = for_read ? ctx->rbuf_freelist : ctx->wbuf_freelist;
+    if (list != NULL &&
+        (sz == list->chunklen || list->chunklen == 0) &&
+        list->len < ctx->freelist_max_len && sz >= sizeof(*ent)) {
+        list->chunklen = sz;
+        ent = mem;
+        ent->next = list->head;
+        list->head = ent;
+        ++list->len;
+        mem = NULL;
+    }
+
+    CRYPTO_w_unlock(CRYPTO_LOCK_SSL_CTX);
+    if (mem)
+        OPENSSL_free(mem);
+}
+#else
+# define freelist_extract(c,fr,sz) OPENSSL_malloc(sz)
+# define freelist_insert(c,fr,sz,m) OPENSSL_free(m)
+#endif
+
+int ssl3_setup_read_buffer(SSL *s)
+{
+    unsigned char *p;
+    size_t len, align = 0, headerlen;
+
+    if (SSL_IS_DTLS(s))
+        headerlen = DTLS1_RT_HEADER_LENGTH;
+    else
+        headerlen = SSL3_RT_HEADER_LENGTH;
+
+#if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD!=0
+    align = (-SSL3_RT_HEADER_LENGTH) & (SSL3_ALIGN_PAYLOAD - 1);
+#endif
+
+    if (s->s3->rbuf.buf == NULL) {
+        len = SSL3_RT_MAX_PLAIN_LENGTH
+            + SSL3_RT_MAX_ENCRYPTED_OVERHEAD + headerlen + align;
+        if (s->options & SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER) {
+            s->s3->init_extra = 1;
+            len += SSL3_RT_MAX_EXTRA;
+        }
+#ifndef OPENSSL_NO_COMP
+        if (!(s->options & SSL_OP_NO_COMPRESSION))
+            len += SSL3_RT_MAX_COMPRESSED_OVERHEAD;
+#endif
+        if ((p = freelist_extract(s->ctx, 1, len)) == NULL)
+            goto err;
+        s->s3->rbuf.buf = p;
+        s->s3->rbuf.len = len;
+    }
+
+    s->packet = &(s->s3->rbuf.buf[0]);
+    return 1;
+
+ err:
+    SSLerr(SSL_F_SSL3_SETUP_READ_BUFFER, ERR_R_MALLOC_FAILURE);
+    return 0;
+}
+
+int ssl3_setup_write_buffer(SSL *s)
+{
+    unsigned char *p;
+    size_t len, align = 0, headerlen;
+
+    if (SSL_IS_DTLS(s))
+        headerlen = DTLS1_RT_HEADER_LENGTH + 1;
+    else
+        headerlen = SSL3_RT_HEADER_LENGTH;
+
+#if defined(SSL3_ALIGN_PAYLOAD) && SSL3_ALIGN_PAYLOAD!=0
+    align = (-SSL3_RT_HEADER_LENGTH) & (SSL3_ALIGN_PAYLOAD - 1);
+#endif
+
+    if (s->s3->wbuf.buf == NULL) {
+        len = s->max_send_fragment
+            + SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD + headerlen + align;
+#ifndef OPENSSL_NO_COMP
+        if (!(s->options & SSL_OP_NO_COMPRESSION))
+            len += SSL3_RT_MAX_COMPRESSED_OVERHEAD;
+#endif
+        if (!(s->options & SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS))
+            len += headerlen + align + SSL3_RT_SEND_MAX_ENCRYPTED_OVERHEAD;
+
+        if ((p = freelist_extract(s->ctx, 0, len)) == NULL)
+            goto err;
+        s->s3->wbuf.buf = p;
+        s->s3->wbuf.len = len;
+    }
+
+    return 1;
+
+ err:
+    SSLerr(SSL_F_SSL3_SETUP_WRITE_BUFFER, ERR_R_MALLOC_FAILURE);
+    return 0;
+}
+
+int ssl3_setup_buffers(SSL *s)
+{
+    if (!ssl3_setup_read_buffer(s))
+        return 0;
+    if (!ssl3_setup_write_buffer(s))
+        return 0;
+    return 1;
+}
+
+int ssl3_release_write_buffer(SSL *s)
+{
+    if (s->s3->wbuf.buf != NULL) {
+        freelist_insert(s->ctx, 0, s->s3->wbuf.len, s->s3->wbuf.buf);
+        s->s3->wbuf.buf = NULL;
+    }
+    return 1;
+}
+
+int ssl3_release_read_buffer(SSL *s)
+{
+    if (s->s3->rbuf.buf != NULL) {
+        freelist_insert(s->ctx, 1, s->s3->rbuf.len, s->s3->rbuf.buf);
+        s->s3->rbuf.buf = NULL;
+    }
+    return 1;
+}
diff -uNr openssl-1.0.2l.orig/ssl/s3_lib.c openssl-1.0.2l/ssl/s3_lib.c
--- openssl-1.0.2l.orig/ssl/s3_lib.c	2017-05-25 20:54:38.000000000 +0800
+++ openssl-1.0.2l/ssl/s3_lib.c	2018-07-16 17:01:21.688443302 +0800
@@ -216,6 +216,7 @@
 #endif
 
 /* Cipher 04 */
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
     {
      1,
      SSL3_TXT_RSA_RC4_128_MD5,
@@ -230,8 +231,10 @@
      128,
      128,
      },
+#endif
 
 /* Cipher 05 */
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
     {
      1,
      SSL3_TXT_RSA_RC4_128_SHA,
@@ -246,7 +249,7 @@
      128,
      128,
      },
-
+#endif
 /* Cipher 06 */
 #ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
     {
@@ -320,6 +323,7 @@
 #endif
 
 /* Cipher 0A */
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
     {
      1,
      SSL3_TXT_RSA_DES_192_CBC3_SHA,
@@ -334,6 +338,7 @@
      112,
      168,
      },
+#endif
 
 /* The DH ciphers */
 /* Cipher 0B */
@@ -373,6 +378,7 @@
 #endif
 
 /* Cipher 0D */
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
     {
      1,
      SSL3_TXT_DH_DSS_DES_192_CBC3_SHA,
@@ -387,6 +393,7 @@
      112,
      168,
      },
+#endif
 
 /* Cipher 0E */
 #ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
@@ -425,6 +432,7 @@
 #endif
 
 /* Cipher 10 */
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
     {
      1,
      SSL3_TXT_DH_RSA_DES_192_CBC3_SHA,
@@ -439,6 +447,7 @@
      112,
      168,
      },
+#endif
 
 /* The Ephemeral DH ciphers */
 /* Cipher 11 */
@@ -478,6 +487,7 @@
 #endif
 
 /* Cipher 13 */
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
     {
      1,
      SSL3_TXT_EDH_DSS_DES_192_CBC3_SHA,
@@ -492,6 +502,7 @@
      112,
      168,
      },
+#endif
 
 /* Cipher 14 */
 #ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
@@ -530,6 +541,7 @@
 #endif
 
 /* Cipher 16 */
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
     {
      1,
      SSL3_TXT_EDH_RSA_DES_192_CBC3_SHA,
@@ -544,6 +556,7 @@
      112,
      168,
      },
+#endif
 
 /* Cipher 17 */
 #ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
@@ -564,6 +577,7 @@
 #endif
 
 /* Cipher 18 */
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
     {
      1,
      SSL3_TXT_ADH_RC4_128_MD5,
@@ -578,6 +592,7 @@
      128,
      128,
      },
+#endif
 
 /* Cipher 19 */
 #ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
@@ -616,6 +631,7 @@
 #endif
 
 /* Cipher 1B */
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
     {
      1,
      SSL3_TXT_ADH_DES_192_CBC_SHA,
@@ -630,6 +646,7 @@
      112,
      168,
      },
+#endif
 
 /* Fortezza ciphersuite from SSL 3.0 spec */
 #if 0
@@ -703,6 +720,7 @@
 # endif
 
 /* Cipher 1F */
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
     {
      1,
      SSL3_TXT_KRB5_DES_192_CBC3_SHA,
@@ -717,8 +735,10 @@
      112,
      168,
      },
+#endif
 
 /* Cipher 20 */
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
     {
      1,
      SSL3_TXT_KRB5_RC4_128_SHA,
@@ -733,6 +753,7 @@
      128,
      128,
      },
+#endif
 
 /* Cipher 21 */
     {
@@ -769,6 +790,7 @@
 # endif
 
 /* Cipher 23 */
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
     {
      1,
      SSL3_TXT_KRB5_DES_192_CBC3_MD5,
@@ -783,8 +805,10 @@
      112,
      168,
      },
+#endif
 
 /* Cipher 24 */
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
     {
      1,
      SSL3_TXT_KRB5_RC4_128_MD5,
@@ -799,6 +823,7 @@
      128,
      128,
      },
+#endif
 
 /* Cipher 25 */
     {
@@ -1418,6 +1443,7 @@
 # endif
 
     /* Cipher 66 */
+# ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
     {
      1,
      TLS1_TXT_DHE_DSS_WITH_RC4_128_SHA,
@@ -1433,6 +1459,7 @@
      128,
      },
 #endif
+#endif
 
     /* TLS v1.2 ciphersuites */
     /* Cipher 67 */
@@ -1703,6 +1730,7 @@
 
 #ifndef OPENSSL_NO_PSK
     /* Cipher 8A */
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
     {
      1,
      TLS1_TXT_PSK_WITH_RC4_128_SHA,
@@ -1717,8 +1745,10 @@
      128,
      128,
      },
+#endif
 
     /* Cipher 8B */
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
     {
      1,
      TLS1_TXT_PSK_WITH_3DES_EDE_CBC_SHA,
@@ -1733,6 +1763,7 @@
      112,
      168,
      },
+#endif
 
     /* Cipher 8C */
     {
@@ -2095,6 +2126,7 @@
      },
 
     /* Cipher C002 */
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
     {
      1,
      TLS1_TXT_ECDH_ECDSA_WITH_RC4_128_SHA,
@@ -2109,8 +2141,10 @@
      128,
      128,
      },
+#endif
 
     /* Cipher C003 */
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
     {
      1,
      TLS1_TXT_ECDH_ECDSA_WITH_DES_192_CBC3_SHA,
@@ -2125,6 +2159,7 @@
      112,
      168,
      },
+#endif
 
     /* Cipher C004 */
     {
@@ -2175,6 +2210,7 @@
      },
 
     /* Cipher C007 */
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
     {
      1,
      TLS1_TXT_ECDHE_ECDSA_WITH_RC4_128_SHA,
@@ -2189,8 +2225,10 @@
      128,
      128,
      },
+#endif
 
     /* Cipher C008 */
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
     {
      1,
      TLS1_TXT_ECDHE_ECDSA_WITH_DES_192_CBC3_SHA,
@@ -2205,6 +2243,7 @@
      112,
      168,
      },
+#endif
 
     /* Cipher C009 */
     {
@@ -2255,6 +2294,7 @@
      },
 
     /* Cipher C00C */
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
     {
      1,
      TLS1_TXT_ECDH_RSA_WITH_RC4_128_SHA,
@@ -2269,8 +2309,10 @@
      128,
      128,
      },
+#endif
 
     /* Cipher C00D */
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
     {
      1,
      TLS1_TXT_ECDH_RSA_WITH_DES_192_CBC3_SHA,
@@ -2285,6 +2327,7 @@
      112,
      168,
      },
+#endif
 
     /* Cipher C00E */
     {
@@ -2335,6 +2378,7 @@
      },
 
     /* Cipher C011 */
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
     {
      1,
      TLS1_TXT_ECDHE_RSA_WITH_RC4_128_SHA,
@@ -2349,8 +2393,10 @@
      128,
      128,
      },
+#endif
 
     /* Cipher C012 */
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
     {
      1,
      TLS1_TXT_ECDHE_RSA_WITH_DES_192_CBC3_SHA,
@@ -2365,6 +2411,7 @@
      112,
      168,
      },
+#endif
 
     /* Cipher C013 */
     {
@@ -2415,6 +2462,7 @@
      },
 
     /* Cipher C016 */
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
     {
      1,
      TLS1_TXT_ECDH_anon_WITH_RC4_128_SHA,
@@ -2429,8 +2477,10 @@
      128,
      128,
      },
+#endif
 
     /* Cipher C017 */
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
     {
      1,
      TLS1_TXT_ECDH_anon_WITH_DES_192_CBC3_SHA,
@@ -2445,6 +2495,7 @@
      112,
      168,
      },
+#endif
 
     /* Cipher C018 */
     {
@@ -2481,6 +2532,7 @@
 
 #ifndef OPENSSL_NO_SRP
     /* Cipher C01A */
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
     {
      1,
      TLS1_TXT_SRP_SHA_WITH_3DES_EDE_CBC_SHA,
@@ -2495,8 +2547,10 @@
      112,
      168,
      },
+#endif
 
     /* Cipher C01B */
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
     {
      1,
      TLS1_TXT_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA,
@@ -2511,8 +2565,10 @@
      112,
      168,
      },
+#endif
 
     /* Cipher C01C */
+#ifndef OPENSSL_NO_WEAK_SSL_CIPHERS
     {
      1,
      TLS1_TXT_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA,
@@ -2527,6 +2583,7 @@
      112,
      168,
      },
+#endif
 
     /* Cipher C01D */
     {
diff -uNr openssl-1.0.2l.orig/ssl/ssl_lib.c openssl-1.0.2l/ssl/ssl_lib.c
--- openssl-1.0.2l.orig/ssl/ssl_lib.c	2017-05-25 20:54:38.000000000 +0800
+++ openssl-1.0.2l/ssl/ssl_lib.c	2018-07-16 17:01:21.684443274 +0800
@@ -162,6 +162,8 @@
 
 const char *SSL_version_str = OPENSSL_VERSION_TEXT;
 
+#define OPENSSL_NO_BUF_FREELISTS
+
 SSL3_ENC_METHOD ssl3_undef_enc_method = {
     /*
      * evil casts, but these functions are only called if there's a library
diff -uNr openssl-1.0.2l.orig/tools/c_rehash.in openssl-1.0.2l/tools/c_rehash.in
--- openssl-1.0.2l.orig/tools/c_rehash.in	2017-05-25 20:54:34.000000000 +0800
+++ openssl-1.0.2l/tools/c_rehash.in	2018-07-16 17:01:21.672443191 +0800
@@ -8,8 +8,6 @@
 
 my $openssl = $ENV{OPENSSL} || "openssl";
 my $pwd;
-my $x509hash = "-subject_hash";
-my $crlhash = "-hash";
 my $verbose = 0;
 my $symlink_exists=eval {symlink("",""); 1};
 my $removelinks = 1;
@@ -18,10 +16,7 @@
 while ( $ARGV[0] =~ /^-/ ) {
     my $flag = shift @ARGV;
     last if ( $flag eq '--');
-    if ( $flag eq '-old') {
-	    $x509hash = "-subject_hash_old";
-	    $crlhash = "-hash_old";
-    } elsif ( $flag eq '-h') {
+    if ( $flag eq '-h') {
 	    help();
     } elsif ( $flag eq '-n' ) {
 	    $removelinks = 0;
@@ -113,7 +108,9 @@
 			next;
 		}
 		link_hash_cert($fname) if($cert);
+		link_hash_cert_old($fname) if($cert);
 		link_hash_crl($fname) if($crl);
+		link_hash_crl_old($fname) if($crl);
 	}
 }
 
@@ -146,6 +143,7 @@
 
 sub link_hash_cert {
 		my $fname = $_[0];
+		my $x509hash = $_[1] || '-subject_hash';
 		$fname =~ s/'/'\\''/g;
 		my ($hash, $fprint) = `"$openssl" x509 $x509hash -fingerprint -noout -in "$fname"`;
 		chomp $hash;
@@ -177,10 +175,20 @@
 		$hashlist{$hash} = $fprint;
 }
 
+sub link_hash_cert_old {
+		link_hash_cert($_[0], '-subject_hash_old');
+}
+
+sub link_hash_crl_old {
+		link_hash_crl($_[0], '-hash_old');
+}
+
+
 # Same as above except for a CRL. CRL links are of the form <hash>.r<n>
 
 sub link_hash_crl {
 		my $fname = $_[0];
+		my $crlhash = $_[1] || "-hash";
 		$fname =~ s/'/'\\''/g;
 		my ($hash, $fprint) = `"$openssl" crl $crlhash -fingerprint -noout -in '$fname'`;
 		chomp $hash;
